diff -u -wdB spec_old/Broadcasts.h spec_new/Broadcasts.h
--- spec_old/Broadcasts.h	2015-03-03 11:54:14.000000000 -0600
+++ spec_new/Broadcasts.h	2016-07-05 15:09:41.984045144 -0500
@@ -39,6 +39,8 @@
   velocityRescaleFactorTag,
   positionRescaleFactorTag,
   tcoupleCoefficientTag,
+  langRescaleFactorTag,
+  tNHCRescaleFactorTag,
   minimizeCoefficientTag,
   momentumCorrectionTag,
 #if USE_BARRIER
@@ -60,6 +62,8 @@
   SimpleBroadcastObject<BigReal> velocityRescaleFactor;
   SimpleBroadcastObject<Tensor> positionRescaleFactor;
   SimpleBroadcastObject<BigReal> tcoupleCoefficient;
+  SimpleBroadcastObject<BigReal> langRescaleFactor;
+  SimpleBroadcastObject<BigReal> tNHCRescaleFactor;
   SimpleBroadcastObject<BigReal> minimizeCoefficient;
   SimpleBroadcastObject<Vector> momentumCorrection;
 #if USE_BARRIER
@@ -77,6 +81,8 @@
     velocityRescaleFactor(velocityRescaleFactorTag, ldObjPtr),
     positionRescaleFactor(positionRescaleFactorTag, ldObjPtr),
     tcoupleCoefficient(tcoupleCoefficientTag, ldObjPtr),
+    langRescaleFactor(langRescaleFactorTag, ldObjPtr),
+    tNHCRescaleFactor(tNHCRescaleFactorTag, ldObjPtr),
     minimizeCoefficient(minimizeCoefficientTag, ldObjPtr),
     momentumCorrection(momentumCorrectionTag, ldObjPtr),
 #if USE_BARRIER
diff -u -wdB spec_old/CollectionMaster.C spec_new/CollectionMaster.C
--- spec_old/CollectionMaster.C	2012-01-28 16:04:27.000000000 -0600
+++ spec_new/CollectionMaster.C	2016-08-09 19:01:19.692181927 -0500
@@ -43,6 +43,67 @@
 {
 }
 
+void CollectionMaster::receiveHi(int seq)
+{
+  hi.submitData(seq);
+  CollectHiInstance *c = hi.removeReady(seq);
+  if ( c != 0 ) { // collected Hi's from all nodes
+    CthAwaken(hiThread);
+    hiThread = 0;
+  }
+}
+
+void CollectionMaster::enqueueHi(int seq)
+{
+  CollectHiInstance *c = hi.removeReady(seq);
+  if ( c == 0 ) { // lock the thread
+    hiThread = CthSelf();
+    CthSuspend();
+  } else { // already collected Hi's from all nodes
+    c->free(); // empty the spot, but don't actually free the memory
+  }
+}
+
+void CollectionMaster::receiveSpecPositions(CollectVectorMsg *msg)
+{
+  specPositions.submitData(msg, numSpec);
+  delete msg;
+  
+  CollectVectorInstance *c;
+  while ( ( c = specPositions.removeReady() ) ) { disposeSpecPositions(c); }
+}
+
+void CollectionMaster::enqueueSpecPositions(int seq, Lattice &lattice)
+{
+  specPositions.enqueue(seq,lattice);
+
+  CollectVectorInstance *c;
+  while ( ( c = specPositions.removeReady() ) ) { disposeSpecPositions(c); }
+}
+ 
+void CollectionMaster::disposeSpecPositions(CollectVectorInstance *c)
+{
+    int seq = c->seq;
+    int size = c->data.size();
+    if ( ! size ) size = c->fdata.size();
+    Vector *data = c->data.begin();
+    FloatVector *fdata = c->fdata.begin();
+    //for ( int k = 0; k < c->data.size(); k++ )
+    //  CkPrintf("CollectionMaster %d: %d, %g, %g, %g\n", seq, k, data[k].x, data[k].y, data[k].z);
+
+    // Compute the end-to-end distance from the positions
+    int numAtoms = c->data.size(), k;
+    Vector del(0, 0, 0), endtoend(0, 0, 0);
+    for ( k = 0; k < numAtoms - 1; k++ ) {
+      endtoend += c->lattice.delta(data[k+1], data[k]); 
+    }
+    BigReal dist = endtoend.length();
+    CkPrintf("step %d, end-to-end distance %g\n", seq, dist);
+    //CkPrintf("step %d, end-to-end distance %g: (%g, %g, %g)\n",
+    //    seq, dist, endtoend.x, endtoend.y, endtoend.z);
+    c->free();
+}
+ 
 void CollectionMaster::receivePositions(CollectVectorMsg *msg)
 {
 #ifndef MEM_OPT_VERSION
diff -u -wdB spec_old/CollectionMaster.ci spec_new/CollectionMaster.ci
--- spec_old/CollectionMaster.ci	2011-05-20 15:17:45.000000000 -0500
+++ spec_new/CollectionMaster.ci	2016-07-05 15:13:25.041476839 -0500
@@ -35,6 +35,8 @@
     entry void startNextRoundOutputForce(double totalT);
     entry void wrapCoorFinished();
     
+    entry void receiveHi(int seq);
+    entry void receiveSpecPositions(CollectVectorMsg *);
   };
 }
 
diff -u -wdB spec_old/CollectionMaster.h spec_new/CollectionMaster.h
--- spec_old/CollectionMaster.h	2015-11-04 11:20:25.000000000 -0600
+++ spec_new/CollectionMaster.h	2016-07-05 15:14:42.840384820 -0500
@@ -297,6 +297,67 @@
 
   };
 #endif
+
+  class CollectHiInstance
+  {
+  public:
+    CollectHiInstance(void) : seq(-10) { ; }
+    void free() { seq = -10; }
+    int notfree() { return seq != -10; }
+    void reset(int s) {
+      seq = s;
+      remaining = PatchMap::Object()->numNodesWithPatches(); 
+    }
+    int seq;
+    int remaining;
+  };
+
+  class CollectHiSequence
+  {
+  public:
+    ResizeArray<CollectHiInstance *> data;
+
+    void submitData(int seq) {
+      CollectHiInstance **c, **c_e = data.end();
+      for( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      if ( c == c_e ) { // the sequence does not exist
+        // try to find an empty spot in the array
+        for( c = data.begin(); c != c_e && (*c)->notfree(); ++c )
+          ;
+        if ( c == c_e ) { // no empty spot exists, append one
+          data.add(new CollectHiInstance);
+          c = data.end() - 1;
+        }
+        (*c)->reset(seq);
+      }
+      (*c)->remaining--;
+    }
+
+    // return nonzero if all nodes have submitted data for step `seq'
+    CollectHiInstance* removeReady(int seq) {
+      CollectHiInstance *o = 0, **c, **c_e = data.end();
+      for( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      int remaining = 0;
+      if ( c != c_e && (remaining = (*c)->remaining) == 0 )
+        o = *c;
+      return o;
+    }
+
+    CollectHiSequence() { ; }
+  };
+
+public:
+  void receiveHi(int seq);
+  void enqueueHi(int seq);
+
+  int numSpec; // size of `specPositions', to be set in the Controller
+  CollectVectorSequence specPositions; // to hold positions of special atoms
+  void receiveSpecPositions(CollectVectorMsg *msg);
+  void enqueueSpecPositions(int seq, Lattice &lattice);
+  void disposeSpecPositions(CollectVectorInstance *c);
+
 private:
 
   CollectVectorSequence positions;
@@ -304,6 +365,8 @@
   CollectVectorSequence forces;
   int posTimings, velTimings, forceTimings;
   FILE *dataStreamFile;
+  CollectHiSequence hi;
+  CthThread hiThread;
 
 #ifdef MEM_OPT_VERSION
   int wrapCoorDoneCnt;
diff -u -wdB spec_old/CollectionMgr.C spec_new/CollectionMgr.C
--- spec_old/CollectionMgr.C	2015-09-04 17:20:02.000000000 -0500
+++ spec_new/CollectionMgr.C	2016-07-05 15:16:03.276183920 -0500
@@ -32,6 +32,38 @@
 {
 }
 
+void CollectionMgr::submitSpecPositions(int seq, FullAtomList &a,
+				Lattice l, int prec)
+{  
+  int numAtoms = a.size();
+  AtomIDList aid(numAtoms);
+  PositionList d(numAtoms);
+  for ( int i=0; i<numAtoms; ++i ) {
+    aid[i] = a[i].id;
+    d[i] = l.reverse_transform(a[i].position,a[i].transform);
+    //CkPrintf("CollectionMgr::submitSpecPositions %d: %d, atom %d, %g %g %g\n", seq, i, aid[i], d[i].x, d[i].y, d[i].z);
+  }
+  CollectVectorInstance *c;
+  if ( ( c = specPositions.submitData(seq,aid,d,prec) ) )
+  {
+    int aid_size = c->aid.size();
+    int data_size = c->data.size();
+    int fdata_size = c->fdata.size();
+    CollectVectorMsg *msg
+      = new (aid_size, data_size, fdata_size,0) CollectVectorMsg;
+    msg->seq = c->seq;
+    msg->aid_size = aid_size;
+    msg->data_size = data_size;
+    msg->fdata_size = fdata_size;
+    memcpy(msg->aid,c->aid.begin(),aid_size*sizeof(AtomID));
+    memcpy(msg->data,c->data.begin(),data_size*sizeof(Vector));
+    memcpy(msg->fdata,c->fdata.begin(),fdata_size*sizeof(FloatVector));
+    CProxy_CollectionMaster cm(master);
+    cm.receiveSpecPositions(msg);
+    c->free();
+  }
+}
+
 #ifdef MEM_OPT_VERSION
 //1. record the dest output rank of each atom
 //2. distribute the atoms to the corresponding output procs
@@ -305,6 +337,16 @@
 }
 #endif
 
+void CollectionMgr::submitHi(int seq) {  
+  CollectHiInstance *c = hi.submitData(seq);
+  if ( c != 0 ) {
+    // all HomePatches on the Node have submitted data
+    CProxy_CollectionMaster cm(master);
+    cm.receiveHi(c->seq);
+    c->free();
+  }
+}
+
 void CollectionMgr::sendDataStream(const char *data) {
   DataStreamMsg *msg = new DataStreamMsg;
   msg->data.resize(strlen(data)+1);
diff -u -wdB spec_old/CollectionMgr.h spec_new/CollectionMgr.h
--- spec_old/CollectionMgr.h	2013-09-06 14:11:36.000000000 -0500
+++ spec_new/CollectionMgr.h	2016-07-05 15:16:51.150622257 -0500
@@ -138,6 +138,51 @@
     ResizeArray<CollectVectorInstance*> data;
 
   };
+
+  CollectVectorSequence specPositions;
+  void submitSpecPositions(int seq, FullAtomList &a, Lattice l, int prec=2);
+
+  class CollectHiInstance
+  {
+  public:
+    CollectHiInstance(void) : seq(-10) { ; }
+    void free() { seq = -10; }
+    int notfree() { return ( seq != -10 ); }
+    void reset(int s) {
+      seq = s;
+      remaining = PatchMap::Object()->numHomePatches();
+    }
+    int seq;
+    int remaining;
+  };
+
+  class CollectHiSequence
+  {
+  public:
+    ResizeArray<CollectHiInstance*> data;
+
+    CollectHiInstance* submitData(int seq) {
+      CollectHiInstance **c, **c_e = data.end();
+      for ( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      if ( c == c_e ) { // CollectHiInstance for the sequence `seq' does not exist
+        // try to find an empty spot in the array
+        for ( c = data.begin(); c != c_e && (*c)->notfree(); ++c )
+          ;
+        if ( c == c_e ) { // no empty spot exists, append one
+         data.add(new CollectHiInstance);
+         c = data.end() - 1;
+        }
+        (*c)->reset(seq);
+      }
+      if ( --(*c)->remaining == 0 ) {
+        return *c;
+      } else {
+        return 0;
+      }
+    }
+  };
+
 private:
 
   CkChareID master;
@@ -146,6 +191,9 @@
   CollectVectorSequence velocities;
   CollectVectorSequence forces;
 
+  CollectHiSequence hi;
+public:
+  void submitHi(int);
 };
 
 #endif
diff -u -wdB spec_old/common.C spec_new/common.C
--- spec_old/common.C	2015-02-02 10:14:20.000000000 -0600
+++ spec_new/common.C	2016-08-03 20:02:45.280934670 -0500
@@ -181,7 +181,7 @@
   int fd;
 
   //  open the file and die if the open fails
-#ifdef WIN32
+#if defined(WIN32) && !defined(__CYGWIN__)
   while ( (fd = _open(fname, O_WRONLY|(append?O_APPEND:O_EXCL)|O_CREAT|O_TEXT,_S_IREAD|_S_IWRITE)) < 0) {
 #else
 #ifdef NAMD_NO_O_EXCL
@@ -223,7 +223,7 @@
 
 // same as close, only does error checking internally
 void NAMD_close(int fd, const char *fname) {
-#ifdef WIN32
+#if defined(WIN32) && !defined(__CYGWIN__)
   while ( _close(fd) ) {
 #else
   while ( close(fd) ) {
diff -u -wdB spec_old/Controller.C spec_new/Controller.C
--- spec_old/Controller.C	2015-12-17 15:22:03.000000000 -0600
+++ spec_new/Controller.C	2016-08-09 20:37:32.530700768 -0500
@@ -184,6 +184,10 @@
     random->split(0,PatchMap::Object()->numPatches()+1);
 
     rescaleVelocities_sumTemps = 0;  rescaleVelocities_numTemps = 0;
+    rescaleVelocities_sum1     = 0;
+    rescaleVelocities_sumBeta  = 0;
+    rescaleVelocities_sumBeta2 = 0;
+    rescaleVelocities_sumDbde  = 0;
     berendsenPressure_avg = 0; berendsenPressure_count = 0;
     // strainRate tensor is symmetric to avoid rotation
     langevinPiston_strainRate =
@@ -388,6 +392,15 @@
   typedef void (*namd_sighandler_t)(int);
 }
 
+// initialize special atoms
+void Controller::specInit(int scriptTask, int step)
+{
+  if ( !simParams->specAtomsOn ) return;
+  // set the number of special positions
+  Molecule *mol = Node::Object()->molecule;
+  collection->numSpec = mol->spcnt;
+}
+
 void Controller::integrate(int scriptTask) {
     char traceNote[24];
   
@@ -406,15 +419,24 @@
       slowFreq = simParams->nonbondedFrequency;
     if ( step >= numberOfSteps ) slowFreq = nbondFreq = 1;
 
+    langRescaleFactorPrev = 1;
+    tNHCInit();
+    rescaleVelocitiesInit();
+    specInit(scriptTask, step);
+
   if ( scriptTask == SCRIPT_RUN ) {
 
     reassignVelocities(step);  // only for full-step velecities
     rescaleaccelMD(step);
-    adaptTempUpdate(step); // Init adaptive tempering;
 
     receivePressure(step);
     if ( zeroMomentum && dofull && ! (step % slowFreq) )
 						correctMomentum(step);
+    // they shouldn't be called
+    //langRescaleVelocities(step, TRUE);
+    //tNHCRescaleVelocities(step, TRUE);
+    adaptTempUpdate(step); // Init adaptive tempering;
+
     printFepMessage(step);
     printTiMessage(step);
     printDynamicsEnergies(step);
@@ -429,6 +451,11 @@
     rebalanceLoad(step);
 
   }
+    keHistInit();
+    std::ofstream fsEnergyLog;
+    if ( simParams->energyLogFreq > 0 ) {
+      fsEnergyLog.open(simParams->energyLogFile, std::ios_base::app);
+    }
 
     // Handling SIGINT doesn't seem to be working on Lemieux, and it
     // sometimes causes the net-xxx versions of NAMD to segfault on exit, 
@@ -437,19 +464,37 @@
     //  (namd_sighandler_t)my_sigint_handler);
     for ( ++step ; step <= numberOfSteps; ++step )
     {
-        adaptTempUpdate(step);
         rescaleVelocities(step);
 	tcoupleVelocities(step);
+	langRescaleVelocities(step, FALSE);
+	tNHCRescaleVelocities(step, FALSE);
 	berendsenPressure(step);
 	langevinPiston1(step);
         rescaleaccelMD(step);
 	enqueueCollections(step);  // after lattice scaling!
+        // request positions of the special atoms, the results
+        // may not be immediately available after the call
+        if ( simParams->specAtomsOn
+          && step % simParams->specAtomsFreq == 0 ) {
+          collection->enqueueSpecPositions(step, state->lattice);
+        }
 	receivePressure(step);
         if ( zeroMomentum && dofull && ! (step % slowFreq) )
 						correctMomentum(step);
 	langevinPiston2(step);
         reassignVelocities(step);
+	
+        langRescaleVelocities(step, TRUE);
+        tNHCRescaleVelocities(step, TRUE);
+        Bool scaled = adaptTempUpdate(step);
+        keHistUpdate(step);
         printDynamicsEnergies(step);
+        if ( fsEnergyLog.is_open() && step % simParams->energyLogFreq == 0 ) {
+          fsEnergyLog << step << " " << (totalEnergy - kineticEnergy);
+          if ( simParams->adaptTempOn )
+            fsEnergyLog << " " << adaptTempT;
+          fsEnergyLog << std::endl;
+        }
         outputFepEnergy(step);
         outputTiEnergy(step);
         if(traceIsOn()){
@@ -493,7 +538,11 @@
 		}
 	}
 #endif
-	 
+        if ( scaled && (ldbSteps == 1 || LdbCoordinator::Object()->getNumStepsToRun() == 1) ) {
+          // collect Hi's if we're about to rebalance load
+          collection->enqueueHi(step);
+        }
+	//if ( ldbSteps == 1 ) CkPrintf("step %d, before rebalanceLoad(), Controller PE %d/%d, thread %p\n", step, CkMyPe(), CkNumPes(), CthSelf());
         rebalanceLoad(step);
 
 #if  PME_BARRIER
@@ -501,6 +550,12 @@
 #endif
     }
     // signal(SIGINT, oldhandler);
+    
+    adaptTempDone(step);
+    rescaleVelocitiesSave(step);
+    if ( fsEnergyLog.is_open() ) fsEnergyLog.close();
+    tNHCDone(step);
+    keHistDone(step);
 }
 
 
@@ -1016,6 +1071,12 @@
   const int rescaleFreq = simParams->rescaleFreq;
   if ( rescaleFreq > 0 ) {
     rescaleVelocities_sumTemps += temperature;  ++rescaleVelocities_numTemps;
+    BigReal ek = BOLTZMANN * temperature * numDegFreedom;
+    BigReal beta = (numDegFreedom - 2.0) / ek;
+    rescaleVelocities_sum1     += 1;
+    rescaleVelocities_sumBeta  += beta;
+    rescaleVelocities_sumBeta2 += beta * beta;
+    rescaleVelocities_sumDbde  += -beta / ek;
     if ( rescaleVelocities_numTemps == rescaleFreq ) {
       BigReal avgTemp = rescaleVelocities_sumTemps / rescaleVelocities_numTemps;
       BigReal rescaleTemp = simParams->rescaleTemp;
@@ -1024,6 +1085,35 @@
         rescaleTemp = adaptTempT;
       }
       BigReal factor = sqrt(rescaleTemp/avgTemp);
+      if ( simParams->rescaleAdaptiveOn ) {
+        // recompute the velocity-rescaling factor
+        BigReal bref = 1.0 / (BOLTZMANN * rescaleTemp);
+        BigReal dbeta = bref - beta;
+        BigReal dbdk = rescaleVelocities_sumDbde / rescaleVelocities_sum1;
+        BigReal bet = rescaleVelocities_sumBeta / rescaleVelocities_sum1;
+        BigReal bet2 = rescaleVelocities_sumBeta2 / rescaleVelocities_sum1 - bet * bet;
+        BigReal dbde;
+        if ( simParams->rescaleAdaptiveDedk > 0 ) { // heuristic method
+          dbde = dbdk / simParams->rescaleAdaptiveDedk;
+        } else { // exact method
+          if ( rescaleVelocities_numTemps < 10 ) {
+            dbde = dbdk;
+          } else {
+            dbde = dbdk + bet2;
+            if ( dbde > 0.01 * dbdk ) dbde = 0.01 * dbdk;
+          }
+        }
+        BigReal de = dbeta/dbde;
+        BigReal s = (de / ek) * simParams->rescaleFreq / rescaleVelocities_sum1;
+        if ( s > 0.5 ) s = 0.5;
+        else if ( s < -0.5 ) s = -0.5;
+        factor = sqrt(1 + s);
+        if ( fmod(rescaleVelocities_sum1, simParams->rescaleAdaptiveFileFreq) < 0.5 ) {
+          CkPrintf("step %d, factor %g, s %g, bet %g/%g, dbde %g/%g, bet2 %g, delE/K %g, tp %g\n",
+              step, factor, s, bet, bref, dbde, dbdk, bet2, de/ek, temperature); // getchar();
+          rescaleVelocitiesSave(step);
+        }
+      }
       broadcast->velocityRescaleFactor.publish(step,factor);
       //iout << "RESCALING VELOCITIES AT STEP " << step
       //     << " FROM AVERAGE TEMPERATURE OF " << avgTemp
@@ -1033,6 +1123,56 @@
   }
 }
 
+void Controller::rescaleVelocitiesInit(void)
+{
+  if ( numDegFreedom <= 0 )
+    numDegFreedom = Node::Object()->molecule->num_deg_freedom();
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  rescaleVelocitiesLoad();
+}
+
+void Controller::rescaleVelocitiesLoad(void)
+{
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  std::ifstream fs(simParams->rescaleAdaptiveFile);
+  if ( !fs ) return;
+  double cnt, beta, beta2, dbde;
+  fs >> cnt >> beta >> beta2 >> dbde;
+  fs.close();
+  iout << "LOADED ADAPTIVE VELOCITY-RESCALING DATA FROM "
+       << simParams->rescaleAdaptiveFile << ": STEP " << cnt
+       << ", BETA " << beta << ", VAR(BETA) " << beta2
+       << ", BETA'(E) " << dbde << "\n" << endi;
+  beta2 += beta * beta;
+  if ( fmod(cnt, simParams->rescaleFreq) > 0.5 ) {
+    cnt = cnt / simParams->rescaleFreq * simParams->rescaleFreq;
+  }
+  rescaleVelocities_sum1 = cnt;
+  rescaleVelocities_sumBeta = cnt * beta;
+  rescaleVelocities_sumBeta2 = cnt * beta2;
+  rescaleVelocities_sumDbde = cnt * dbde;
+}
+
+void Controller::rescaleVelocitiesSave(int step)
+{
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  if ( rescaleVelocities_sum1 <= 0 )
+    return;
+  NAMD_backup_file(simParams->rescaleAdaptiveFile);
+  ofstream_namd fs(simParams->rescaleAdaptiveFile);
+  if ( !fs ) return;
+  BigReal beta = rescaleVelocities_sumBeta / rescaleVelocities_sum1;
+  BigReal beta2 = rescaleVelocities_sumBeta2 / rescaleVelocities_sum1
+                - beta * beta;
+  BigReal dbde = rescaleVelocities_sumDbde / rescaleVelocities_sum1;
+  char buf[200];
+  sprintf(buf, "%.0f %.10f %.10f %.10f\n", rescaleVelocities_sum1, beta, beta2, dbde);
+  fs << buf;
+}
+
 void Controller::correctMomentum(int step) {
 
     Vector momentum;
@@ -1110,6 +1250,279 @@
   }
 }
 
+// Ref.: Canonical sampling through velocity rescaling
+// Bussi, Donadio, and Parrinello, JCP 126, 014101 (2007)
+void Controller::langRescaleVelocities(int step, Bool isPrev)
+{
+  if ( simParams->langRescaleOn ) {
+    BigReal tp = simParams->langRescaleTemp;
+    // use the temperature from adaptive tempering, if any
+    if ( simParams->adaptTempOn && simParams->adaptTempRescale
+     && (step > simParams->adaptTempFirstStep )
+     && (!(simParams->adaptTempLastStep > 0) || step < simParams->adaptTempLastStep )) {
+      tp = adaptTempT;
+    }
+    tp *= BOLTZMANN;
+
+    BigReal dt = simParams->dt / simParams->langRescaleDt;
+    dt *= 0.5; // doing a half time step, called twice in an MD step
+    BigReal c = exp(-dt);
+
+    // integrate two half steps
+    int dof = numDegFreedom;
+    if ( dof <= 0 ) dof = Node::Object()->molecule->num_deg_freedom();
+    BigReal r = random->gaussian();
+    BigReal r2 = random->chisqr(dof - 1);
+    BigReal ek1 = BOLTZMANN * temperature * dof * 0.5;
+    BigReal ek2 = ek1 + (1 - c) * ((r2 + r * r) * 0.5 * tp - ek1)
+                + 2 * r * sqrt(c * (1 - c) * ek1 * 0.5 * tp);
+    if ( ek2 < 0 ) ek2 = 0;
+    BigReal fac2 = ek2 / ek1;
+    BigReal factor = sqrt( fac2 );
+    if ( !isPrev ) {
+      // combine with the rescaling factor carried from
+      // the second half-step from the previous MD step
+      broadcast->langRescaleFactor.publish(step, factor * langRescaleFactorPrev);
+    } else {
+      // save it for the rescaling in the next step
+      langRescaleFactorPrev = factor;
+    }
+    temperature *= fac2;
+    totalEnergy += kineticEnergy * (fac2 - 1);
+    kineticEnergy *= fac2;
+    kineticEnergyCentered *= fac2;
+  }
+}
+
+void Controller::tNHCInit(void)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int nnhc = simParams->tNHCLen, i;
+  tNHCzeta = new BigReal [nnhc];
+  tNHCmass = new BigReal [nnhc];
+
+  // Note: numDegFreedom has not been set yet
+  int dof = Node::Object()->molecule->num_deg_freedom();
+  BigReal per = simParams->tNHCPeriod / (2 * M_PI);
+  BigReal kT = BOLTZMANN * simParams->tNHCTemp;
+  // reference mass choices, see Appendix B of JCP 97 (4) 2635
+  BigReal mass2 = per * per * kT;
+  BigReal mass1 = mass2 * dof;
+
+  for ( i = 0; i < nnhc; i++ ) {
+    tNHCzeta[i] = 0;
+    tNHCmass[i] = ( i == 0 ) ? mass1 : mass2;
+  }
+
+  // try to load the chain variables, ok if it fails
+  tNHCLoad();
+  CkPrintf("NHC %d, mass1 %g, mass2 %g\n", dof, mass1, mass2);
+  for ( i = 0; i < nnhc; i++ )
+    CkPrintf("NHC %d: zeta %g, mass %g\n", i+1, tNHCzeta[i], tNHCmass[i]);
+  tNHCRescaleFactorPrev = 1.0;
+}
+
+void Controller::tNHCDone(int step)
+{
+  if ( simParams->tNHCOn ) {
+    tNHCSave(step);
+    delete[] tNHCzeta;
+    delete[] tNHCmass;
+  }
+}
+
+// Nose-Hoover chain thermostat
+// Ref.: Nose-Hoover chains: The canonical ensemble via continuous dynamics 
+// Glenn J. Martyna, Michael L. Klein, and Mark Tuckerman, JCP 97 (4) 2635
+void Controller::tNHCRescaleVelocities(int step, Bool isPrev)
+{
+  if ( simParams->tNHCOn ) {
+    BigReal tp = simParams->tNHCTemp;
+    // use the temperature from adaptive tempering, if any
+    if ( simParams->adaptTempOn && simParams->adaptTempRescale
+     && (step > simParams->adaptTempFirstStep )
+     && (!(simParams->adaptTempLastStep > 0) || step < simParams->adaptTempLastStep )) {
+      tp = adaptTempT;
+    }
+    tp *= BOLTZMANN;
+
+    Real dt = simParams->dt * 0.5; // only for half step
+    int dof = numDegFreedom;
+    if ( dof <= 0 ) dof = Node::Object()->molecule->num_deg_freedom();
+    int nnhc = simParams->tNHCLen, i, j, k;
+    BigReal s, GQ, mvv, factor;
+
+    mvv = BOLTZMANN * temperature * dof;
+    for ( j = nnhc - 1; j >= 0; j-- ) {
+      s = ( j == nnhc - 1 ) ? 1 : exp(-tNHCzeta[j+1]*dt*0.25);
+      if ( j == 0 ) {
+        GQ = mvv - dof * tp;
+      } else {
+        GQ = tNHCmass[j-1] * tNHCzeta[j-1] * tNHCzeta[j-1] - tp;
+      }
+      tNHCzeta[j] = (tNHCzeta[j] * s + GQ /tNHCmass[j] * dt*0.5) * s;
+    }
+
+    // velocity rescaling factor
+    factor = exp( -tNHCzeta[0] * dt );
+    if ( !isPrev ) {
+      // combine with the rescaling factor carried from
+      // the second half-step from the previous MD step
+      broadcast->tNHCRescaleFactor.publish(step, factor * tNHCRescaleFactorPrev);
+    } else {
+      tNHCRescaleFactorPrev = factor;
+    }
+
+    BigReal fac2 = factor * factor;
+    temperature *= fac2;
+    totalEnergy += kineticEnergy * (fac2 - 1);
+    kineticEnergy *= fac2;
+    kineticEnergyCentered *= fac2;
+    mvv *= fac2;
+
+    for ( j = 0; j < nnhc; j++ ) {
+      s = ( j == nnhc - 1 ) ? 1 : exp(-tNHCzeta[j+1]*dt*0.25);
+      if ( j == 0 ) {
+        GQ = mvv - dof * tp;
+      } else {
+        GQ = tNHCmass[j-1] * tNHCzeta[j-1] * tNHCzeta[j-1] - tp;
+      }
+      tNHCzeta[j] = (tNHCzeta[j] * s + GQ /tNHCmass[j] * dt*0.5) * s;
+    }
+
+    if ( simParams->tNHCFileFreq > 0 && step % simParams->tNHCFileFreq == 0 )
+      tNHCSave(step);
+  }
+}
+
+void Controller::tNHCSave(int step)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int i, nnhc = simParams->tNHCLen;
+  NAMD_backup_file(simParams->tNHCFile);
+  ofstream_namd fs(simParams->tNHCFile);
+  if ( !fs ) {
+    iout << "Error: cannot write " << simParams->tNHCFile << "\n" << endi;
+    return;
+  }
+  fs << nnhc << " " << step << "\n";
+  for ( i = 0; i < nnhc; i++ )
+    fs << tNHCzeta[i] << " ";
+  fs << "\n";
+  for ( i = 0; i < nnhc; i++ )
+    fs << tNHCmass[i] << " ";
+  fs << "\n";
+}
+
+void Controller::tNHCLoad(void)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int i, nnhc, step;
+  std::ifstream fs(simParams->tNHCFile);
+  if ( !fs ) {
+    iout << "Cannot read " << simParams->tNHCFile << "\n" << endi;
+    return;
+  }
+  fs >> nnhc >> step;
+  if ( nnhc != simParams->tNHCLen ) {
+    iout << "Error: NH-chain length mismatch " << nnhc
+         << " vs. " << simParams->tNHCLen << "\n" << endi;
+    return;
+  }
+  for ( i = 0; i < nnhc; i++ )
+    fs >> tNHCzeta[i];
+
+  if ( simParams->tNHCFileReadMass ) {
+    for ( i = 0; i < nnhc; i++ )
+      fs >> tNHCmass[i];
+  }
+  fs.close();
+}
+
+void Controller::keHistInit(void)
+{
+  if ( !simParams->keHistOn ) return;
+  BigReal keHistTemp = simParams->thermostatTemp();
+  BigReal ke = BOLTZMANN * keHistTemp * numDegFreedom / 2;
+  keHistBinMax = (int) (5.0 * ke / simParams->keHistBin);
+  CkPrintf("keHistInit: temperature %g, dof %d, keHistBinMax %d\n", keHistTemp, numDegFreedom, keHistBinMax);
+  keHist = new BigReal [keHistBinMax];
+  int i;
+  for ( i = 0; i < keHistBinMax; i++ ) keHist[i] = 0;
+  keHistLoad(); // try to load the previous histogram
+}
+
+void Controller::keHistUpdate(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  BigReal ke = BOLTZMANN * temperature * numDegFreedom / 2;
+  if ( simParams->adaptTempOn ) {
+    ke *= simParams->thermostatTemp() / adaptTempT;
+  }
+  int i = (int) ( ke / simParams->keHistBin );
+  if ( i < keHistBinMax ) keHist[i] += 1;
+  if ( step > 0 && step % simParams->keHistFileFreq == 0 ) {
+    keHistSave(step);
+  }
+}
+
+void Controller::keHistSave(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  NAMD_backup_file(simParams->keHistFile);
+  ofstream_namd fs(simParams->keHistFile);
+  if ( !fs ) return;
+  fs << "# " << numDegFreedom << " " << step << "\n";
+  int i;
+  BigReal tot = 0;
+  for ( i = 0; i < keHistBinMax; i++ )
+    tot += keHist[i];
+
+  // normalization of the reference curve
+  BigReal norm = (numDegFreedom % 2) ? 0.5 * log(M_PI) : 0;
+  for ( i = 2 - numDegFreedom % 2; i < numDegFreedom; i += 2 )
+    norm += log(i*0.5);
+  BigReal tp = simParams->thermostatTemp() * BOLTZMANN;
+  BigReal dk = simParams->keHistBin;
+  for ( i = 0; i < keHistBinMax; i++ ) {
+    if ( keHist[i] <= 0 ) continue;
+    double hist = keHist[i] / ( dk * tot );
+    double ke = (i + 0.5) * dk;
+    double histref = exp(log(ke/tp) * (numDegFreedom*0.5-1) -ke/tp - norm) / tp;
+    fs << (i + 0.5) * dk << "\t" << hist << "\t" << histref << "\t" << keHist[i] << "\n";
+  }
+}
+
+void Controller::keHistLoad(void)
+{
+  if ( !simParams->keHistOn ) return;
+  std::ifstream fs(simParams->keHistFile);
+  if ( !fs ) return;
+  std::string buf;
+
+  std::getline(fs, buf);
+  while ( fs.good() ) {
+    double ke, hist1, hist2, hist;
+    std::getline(fs, buf);
+    sscanf(buf.c_str(), "%lf%lf%lf%lf", &ke, &hist1, &hist2, &hist);
+    int i = (int) (ke / simParams->keHistBin);
+    keHist[i] = hist;
+  }
+  fs.close();
+  iout << "Loaded previous histogram from "
+       << simParams->keHistFile << ".\n" << endi;
+}
+
+void Controller::keHistDone(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  keHistSave(step);
+  delete[] keHist;
+}
+
 static char *FORMAT(BigReal X)
 {
   static char tmp_string[25];
@@ -1577,70 +1990,133 @@
     adaptTempDtMin = 0;
     adaptTempDtMax = 0;
     adaptTempAutoDt = false;
-    if (simParams->adaptTempBins == 0) {
+    adaptTempMCTot = 0;
+    adaptTempMCAcc = 0;
+    adaptTempMCDAcc = 0;
+    if (simParams->adaptTempInFile[0] != '\0') {
       iout << iINFO << "READING ADAPTIVE TEMPERING RESTART FILE\n" << endi;
       std::ifstream adaptTempRead(simParams->adaptTempInFile);
       if (adaptTempRead) {
+        adaptTempRead.exceptions( std::ifstream::failbit | std::ifstream::badbit );
+        try {
+          std::string buf(""); // now read by lines to make extension easier
+          std::stringstream ss;
         int readInt;
         BigReal readReal;
-        bool readBool;
+          std::getline(adaptTempRead, buf);
+          ss.str(buf);
         // step
-        adaptTempRead >> readInt;
+          ss >> readInt;
         // Start with min and max temperatures
-        adaptTempRead >> adaptTempT;     // KELVIN
-        adaptTempRead >> adaptTempBetaMin;  // KELVIN
-        adaptTempRead >> adaptTempBetaMax;  // KELVIN
+          ss >> adaptTempT;     // KELVIN
+          ss >> adaptTempBetaMin;  // KELVIN
+          ss >> adaptTempBetaMax;  // KELVIN
         adaptTempBetaMin = 1./adaptTempBetaMin; // KELVIN^-1
         adaptTempBetaMax = 1./adaptTempBetaMax; // KELVIN^-1
         // In case file is manually edited
-        if (adaptTempBetaMin > adaptTempBetaMax){
-            readReal = adaptTempBetaMax;
-            adaptTempBetaMax = adaptTempBetaMin;
-            adaptTempBetaMin = adaptTempBetaMax;
-        }
-        adaptTempRead >> adaptTempBins;     
-        adaptTempRead >> adaptTempCg;
-        adaptTempRead >> adaptTempDt;
-        adaptTempPotEnergyAveNum = new BigReal[adaptTempBins];
-        adaptTempPotEnergyAveDen = new BigReal[adaptTempBins];
-        adaptTempPotEnergySamples = new int[adaptTempBins];
-        adaptTempPotEnergyVarNum = new BigReal[adaptTempBins];
-        adaptTempPotEnergyVar    = new BigReal[adaptTempBins];
-        adaptTempPotEnergyAve    = new BigReal[adaptTempBins];
-        adaptTempBetaN           = new BigReal[adaptTempBins];
+          if (adaptTempBetaMin > adaptTempBetaMax)
+            std::swap(adaptTempBetaMin, adaptTempBetaMax);
+          ss >> adaptTempBins;     
+          ss >> adaptTempCg;
+          ss >> adaptTempDt;
+          ss.clear();
+          adaptTempPotEnergyAveNum  = new double[adaptTempBins];
+          adaptTempPotEnergyAveDen  = new double[adaptTempBins];
+          adaptTempPotEnergySamples = new long[adaptTempBins];
+          adaptTempPotEnergyVarNum  = new double[adaptTempBins];
+          adaptTempPotEnergyVar     = new double[adaptTempBins];
+          adaptTempPotEnergyAve     = new double[adaptTempBins];
+          adaptTempBetaN            = new BigReal[adaptTempBins + 1];
         adaptTempDBeta = (adaptTempBetaMax - adaptTempBetaMin)/(adaptTempBins);
         for(int j = 0; j < adaptTempBins; ++j) {
-          adaptTempRead >> adaptTempPotEnergyAve[j];
-          adaptTempRead >> adaptTempPotEnergyVar[j];
-          adaptTempRead >> adaptTempPotEnergySamples[j];
-          adaptTempRead >> adaptTempPotEnergyAveNum[j];
-          adaptTempRead >> adaptTempPotEnergyVarNum[j];
-          adaptTempRead >> adaptTempPotEnergyAveDen[j];
+            std::getline(adaptTempRead, buf);
+            ss.str(buf);
+            ss >> readReal; // 1 / T
+            ss >> adaptTempPotEnergyAve[j];
+            ss >> adaptTempPotEnergyVar[j];
+            ss >> adaptTempPotEnergySamples[j];
+            ss >> adaptTempPotEnergyAveNum[j];
+            ss >> adaptTempPotEnergyVarNum[j];
+            ss >> adaptTempPotEnergyAveDen[j];
+            // ss >> readReal; // InvW
+            //CkPrintf("%d %g %g %g %ld %g %g %g\nbuf %s", j, readReal, adaptTempPotEnergyAve[j],
+            //    adaptTempPotEnergyVar[j], adaptTempPotEnergySamples[j],
+            //    adaptTempPotEnergyAveNum[j], adaptTempPotEnergyVarNum[j], adaptTempPotEnergyAveDen[j], buf.c_str()); getchar();
+          }
+          for ( int j = 0; j <= adaptTempBins; ++j ) {
           adaptTempBetaN[j] = adaptTempBetaMin + j * adaptTempDBeta;
         } 
+          adaptTempBinMinus = new int[adaptTempBins];
+          adaptTempBinPlus  = new int[adaptTempBins];
+          // read in data for separate accumulators
+          if ( simParams->adaptTempSepOn ) {
+            char info[256];
+            int attempts;
+            for ( attempts = 0; attempts < 10 && std::getline(adaptTempRead, buf); attempts++ ) {
+              if ( strncmp(buf.c_str(), "SEP BEGIN", 9) == 0 )
+                break;
+            }
+            if ( strncmp(buf.c_str(), "SEP BEGIN", 9) != 0 ) {
+              sprintf(info, "No beginning of separate accumulators, file %s, %d attempts\n%s",
+                  simParams->adaptTempInFile, attempts, buf.c_str());
+              NAMD_die(info);
+            }
+            adaptTempSepAcc = new AdaptTempSepAcc[adaptTempBins];
+            // loop over each accumulator
+            int i, j, i1, j1;
+            double total;
+            for ( i = 0; i < adaptTempBins; i++ ) {
+              AdaptTempSepAcc *acc = adaptTempSepAcc + i;
+              std::getline(adaptTempRead, buf);
+              if ( 4 != sscanf(buf.c_str(), "%d%d%d%lf", &i1, &adaptTempBinMinus[i], &adaptTempBinPlus[i], &total) ) {
+                sprintf(info, "Broken info for estimator %d, file %s\n%s",
+                    i, simParams->adaptTempInFile, buf.c_str());
+                NAMD_die(info);
+              }
+              acc->init(adaptTempBinMinus[i], adaptTempBinPlus[i]);
+              acc->total = total;
+              for ( j = 0; j < acc->winSize; j++ ) {
+                std::getline(adaptTempRead, buf);
+                if ( 5 != sscanf(buf.c_str(), "%d%lf%lf%lf%lf\n", &j1,
+                      &acc->sumw[j], &acc->ave[j], &acc->var[j], &acc->cnt[j]) ) {
+                  sprintf(info, "Broken member %d/%d for estimator %d, file %s\n%s",
+                      j, acc->winSize, i, simParams->adaptTempInFile, buf.c_str());
+                  NAMD_die(info);
+                }
+                acc->sumE[j] = acc->sumw[j] * acc->ave[j];
+                acc->sumE2[j] = acc->sumw[j] * (acc->var[j] + acc->ave[j] * acc->ave[j]);
+              }
+              std::getline(adaptTempRead, buf);
+            }
+            std::getline(adaptTempRead, buf);
+            if ( strncmp(buf.c_str(), "SEP END", 7) != 0 ) {
+              sprintf(info, "No ending for separator accumulators, file %s\n%s",
+                  simParams->adaptTempInFile, buf.c_str());
+              NAMD_die(info);
+            }
+          }
+        } catch ( std::ifstream::failure e ) {
+          NAMD_die("Failed to read the ADAPTIVE TEMPERING restart file.\n");
+        }
         adaptTempRead.close();
       }
       else NAMD_die("Could not open ADAPTIVE TEMPERING restart file.\n");
     } 
     else {
       adaptTempBins = simParams->adaptTempBins;
-      adaptTempPotEnergyAveNum = new BigReal[adaptTempBins];
-      adaptTempPotEnergyAveDen = new BigReal[adaptTempBins];
-      adaptTempPotEnergySamples = new int[adaptTempBins];
-      adaptTempPotEnergyVarNum = new BigReal[adaptTempBins];
-      adaptTempPotEnergyVar    = new BigReal[adaptTempBins];
-      adaptTempPotEnergyAve    = new BigReal[adaptTempBins];
-      adaptTempBetaN           = new BigReal[adaptTempBins];
+      adaptTempPotEnergyAveNum  = new double[adaptTempBins];
+      adaptTempPotEnergyAveDen  = new double[adaptTempBins];
+      adaptTempPotEnergySamples = new long[adaptTempBins];
+      adaptTempPotEnergyVarNum  = new double[adaptTempBins];
+      adaptTempPotEnergyVar     = new double[adaptTempBins];
+      adaptTempPotEnergyAve     = new double[adaptTempBins];
+      adaptTempBetaN            = new BigReal[adaptTempBins + 1];
       adaptTempBetaMax = 1./simParams->adaptTempTmin;
       adaptTempBetaMin = 1./simParams->adaptTempTmax;
       adaptTempCg = simParams->adaptTempCgamma;   
       adaptTempDt  = simParams->adaptTempDt;
       adaptTempDBeta = (adaptTempBetaMax - adaptTempBetaMin)/(adaptTempBins);
-      adaptTempT = simParams->initialTemp; 
-      if (simParams->langevinOn)
-        adaptTempT = simParams->langevinTemp;
-      else if (simParams->rescaleFreq > 0)
-        adaptTempT = simParams->rescaleTemp;
+      adaptTempT = simParams->thermostatTemp();
       for(int j = 0; j < adaptTempBins; ++j){
           adaptTempPotEnergyAveNum[j] = 0.;
           adaptTempPotEnergyAveDen[j] = 0.;
@@ -1648,8 +2124,31 @@
           adaptTempPotEnergyVarNum[j] = 0.;
           adaptTempPotEnergyVar[j] = 0.;
           adaptTempPotEnergyAve[j] = 0.;
+      }
+      for ( int j = 0; j <= adaptTempBins; ++j ) {
           adaptTempBetaN[j] = adaptTempBetaMin + j * adaptTempDBeta;
       }
+      // compute the window boundaries
+      adaptTempBinMinus = new int[adaptTempBins];
+      adaptTempBinPlus  = new int[adaptTempBins];
+      for ( int j = 0; j < adaptTempBins; j++ ) {
+          BigReal betaMid = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+          BigReal deltaBeta = betaMid * simParams->adaptTempWindowSize;
+          int deltaBins = (int) (deltaBeta / adaptTempDBeta + 0.5);
+          // adjust the window size such that the window does not exceed the boundaries
+          if ( j - deltaBins < 0 )
+            deltaBins = j;
+          if ( j + deltaBins + 1 > adaptTempBins )
+            deltaBins = adaptTempBins - j - 1;
+          adaptTempBinMinus[j] = j - deltaBins;
+          adaptTempBinPlus[j] = j + deltaBins + 1;
+      }
+      // initialize the separate accumulators
+      if ( simParams->adaptTempSepOn ) {
+          adaptTempSepAcc = new AdaptTempSepAcc[adaptTempBins];
+          for ( int i = 0; i < adaptTempBins; ++i )
+            adaptTempSepAcc[i].init(adaptTempBinMinus[i], adaptTempBinPlus[i]);
+      }
     }
     if (simParams->adaptTempAutoDt > 0.0) {
        adaptTempAutoDt = true;
@@ -1671,9 +2170,37 @@
     }
 }
 
+void Controller::adaptTempDone(int step) {
+    if (!simParams->adaptTempOn) return;
+    adaptTempWriteRestart(step);
+    delete [] adaptTempPotEnergyAveNum;
+    delete [] adaptTempPotEnergyAveDen;
+    delete [] adaptTempPotEnergySamples;
+    delete [] adaptTempPotEnergyVarNum;
+    delete [] adaptTempPotEnergyVar;
+    delete [] adaptTempPotEnergyAve;
+    delete [] adaptTempBetaN;
+    delete [] adaptTempBinMinus;
+    delete [] adaptTempBinPlus;
+    if ( simParams->adaptTempSepOn )
+      delete [] adaptTempSepAcc;
+}
+
 void Controller::adaptTempWriteRestart(int step) {
-    if (simParams->adaptTempOn && !(step%simParams->adaptTempRestartFreq)) {
-        adaptTempRestartFile.seekp(std::ios::beg);        
+    if ( simParams->adaptTempOn ) {
+        char s[1024];
+        if ( !simParams->adaptTempFixedAve ) {
+          // compute the average values
+          for ( int i = 0; i < adaptTempBins; i++ )
+            adaptTempPotEnergyAve[i] = adaptTempGetPEAve(i);
+        }
+        if ( !simParams->adaptTempRestartAppend ) {
+          adaptTempRestartFile.seekbegin();
+          // alternatively, we can
+          //adaptTempRestartFile.close();
+          //NAMD_backup_file(simParams->adaptTempRestartFile);
+          //adaptTempRestartFile.open(simParams->adaptTempRestartFile);
+        }
         iout << "ADAPTEMP: WRITING RESTART FILE AT STEP " << step << "\n" << endi;
         adaptTempRestartFile << step << " ";
         // Start with min and max temperatures
@@ -1685,165 +2212,123 @@
         adaptTempRestartFile << adaptTempDt ;
         adaptTempRestartFile << "\n" ;
         for(int j = 0; j < adaptTempBins; ++j) {
-          adaptTempRestartFile << adaptTempPotEnergyAve[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyVar[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergySamples[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyAveNum[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyVarNum[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyAveDen[j] << " ";
+          BigReal bet = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+          // use printf for better precision control
+          sprintf(s, "%g %g %g %ld %22.14e %22.14e %22.14e %g\n",
+              adaptTempBetaN[j], adaptTempPotEnergyAve[j], adaptTempPotEnergyVar[j],
+              adaptTempPotEnergySamples[j], adaptTempPotEnergyAveNum[j],
+              adaptTempPotEnergyVarNum[j], adaptTempPotEnergyAveDen[j],
+              adaptTempGetInvW(1.0 / bet));
+          adaptTempRestartFile << s;
+        }
+        // data for separate accumulators
+        if ( simParams->adaptTempSepOn ) {
+          adaptTempRestartFile << "SEP BEGIN\n";
+          // loop over each accumulator
+          for ( int i = 0; i < adaptTempBins; i++ ) {
+            AdaptTempSepAcc *acc = adaptTempSepAcc + i;
+            acc->trim();
+            sprintf(s, "%d %d %d %.0f\n", i,
+                adaptTempBinMinus[i], adaptTempBinPlus[i], acc->total);
+            adaptTempRestartFile << s;
+            for ( int j = 0; j < acc->winSize; j++ ) {
+              sprintf(s, "%d %22.14e %22.14e %22.14e %.0f\n", j,
+                  acc->sumw[j], acc->ave[j], acc->var[j], acc->cnt[j]);
+              adaptTempRestartFile << s;
+            }
           adaptTempRestartFile << "\n";          
         }
+          adaptTempRestartFile << "SEP END\n";
+        }
         adaptTempRestartFile.flush(); 
     }
 }    
 
-void Controller::adaptTempUpdate(int step, int minimize)
+BigReal Controller::adaptTempGetInvW(BigReal tp)
 {
-    //Beta = 1./T
-    if ( !simParams->adaptTempOn ) return;
-    int j = 0;
-    if (step == simParams->firstTimestep) {
-        adaptTempInit(step);
-        return;
+  return pow(BOLTZMANN * tp, -simParams->adaptTempWeightExp);
     }
-    if ( minimize || (step < simParams->adaptTempFirstStep ) || 
-        ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) return;
-    const int adaptTempOutFreq  = simParams->adaptTempOutFreq;
-    const bool adaptTempDebug  = simParams->adaptTempDebug;
-    //Calculate Current inverse temperature and bin 
-    BigReal adaptTempBeta = 1./adaptTempT;
-    adaptTempBin   = (int)floor((adaptTempBeta - adaptTempBetaMin)/adaptTempDBeta);
-
-    if (adaptTempBin < 0 || adaptTempBin > adaptTempBins)
-        iout << iWARN << " adaptTempBin out of range: adaptTempBin: " << adaptTempBin  
-                               << " adaptTempBeta: " << adaptTempBeta 
-                              << " adaptTempDBeta: " << adaptTempDBeta 
-                               << " betaMin:" << adaptTempBetaMin 
-                               << " betaMax: " << adaptTempBetaMax << "\n";
-    adaptTempPotEnergySamples[adaptTempBin] += 1;
-    BigReal gammaAve = 1.-adaptTempCg/adaptTempPotEnergySamples[adaptTempBin];
 
-    BigReal potentialEnergy;
+BigReal Controller::adaptTempGetPEAve(int i, BigReal def)
+{
+    const BigReal varCntMin = simParams->adaptTempFreq * 10;
     BigReal potEnergyAverage;
-    BigReal potEnergyVariance;
-    potentialEnergy = totalEnergy-kineticEnergy;
-
-    //calculate new bin average and variance using adaptive averaging
-    adaptTempPotEnergyAveNum[adaptTempBin] = adaptTempPotEnergyAveNum[adaptTempBin]*gammaAve + potentialEnergy;
-    adaptTempPotEnergyAveDen[adaptTempBin] = adaptTempPotEnergyAveDen[adaptTempBin]*gammaAve + 1;
-    adaptTempPotEnergyVarNum[adaptTempBin] = adaptTempPotEnergyVarNum[adaptTempBin]*gammaAve + potentialEnergy*potentialEnergy;
-    
-    potEnergyAverage = adaptTempPotEnergyAveNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
-    potEnergyVariance = adaptTempPotEnergyVarNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
-    potEnergyVariance -= potEnergyAverage*potEnergyAverage;
 
-    adaptTempPotEnergyAve[adaptTempBin] = potEnergyAverage;
-    adaptTempPotEnergyVar[adaptTempBin] = potEnergyVariance;
-    
-    // Weighted integral of <Delta E^2>_beta dbeta <= Eq 4 of JCP 132 244101
-    // Integrals of Eqs 5 and 6 is done as piecewise assuming <Delta E^2>_beta
-    // is constant for each bin. This is to estimate <E(beta)> where beta \in
-    // (beta_i,beta_{i+1}) using Eq 2 of JCP 132 244101
-    if ( ! ( step % simParams->adaptTempFreq ) ) {
-      // If adaptTempBin not at the edge, calculate improved average:
-      if (adaptTempBin > 0 && adaptTempBin < adaptTempBins-1) {
+    if ( simParams->adaptTempSepOn ) {
+      potEnergyAverage = adaptTempSepAcc[i].iiave(varCntMin, def);
+    } else {
+      int j;
           // Get Averaging Limits:
-          BigReal deltaBeta = 0.04*adaptTempBeta; //0.08 used in paper - make variable
-          BigReal betaPlus;
-          BigReal betaMinus;
-          int     nMinus =0;
-          int     nPlus = 0;
-          if ( adaptTempBeta-adaptTempBetaMin < deltaBeta ) deltaBeta = adaptTempBeta-adaptTempBetaMin;
-          if ( adaptTempBetaMax-adaptTempBeta < deltaBeta ) deltaBeta = adaptTempBetaMax-adaptTempBeta;
-          betaMinus = adaptTempBeta - deltaBeta;
-          betaPlus =  adaptTempBeta + deltaBeta;
-          BigReal betaMinus2 = betaMinus*betaMinus;
-          BigReal betaPlus2  = betaPlus*betaPlus;
-          nMinus = (int)floor((betaMinus-adaptTempBetaMin)/adaptTempDBeta);
-          nPlus  = (int)floor((betaPlus-adaptTempBetaMin)/adaptTempDBeta);
+      int nMinus = adaptTempBinMinus[i];
+      int nPlus  = adaptTempBinPlus[i];
           // Variables for <E(beta)> estimate:
           BigReal potEnergyAve0 = 0.0;
           BigReal potEnergyAve1 = 0.0;
+      BigReal den0 = 0.0, den1 = 0.0;
           // Integral terms
-          BigReal A0 = 0;
-          BigReal A1 = 0;
-          BigReal A2 = 0;
+      BigReal A0 = 0; // Sum_{from beta_minus to beta_{i+1} }
+                      //   (beta - beta_minus)/(beta_{i+1} - beta_minus) var(E)
+      BigReal A1 = 0; // Sum_{from beta_{i+1} to beta_plus }
+                      //   (beta - beta_plus) /(beta_plus  - beta_{i+1}) var(E)
+      BigReal A2 = 0; // 0.5 * DBeta * var(E) at bin i
           //A0 phi_s integral for beta_minus < beta < beta_{i+1}
-          BigReal betaNp1 = adaptTempBetaN[adaptTempBin+1]; 
-          BigReal DeltaE2Ave;
-          BigReal DeltaE2AveSum = 0;
-          BigReal betaj;
-          for (j = nMinus+1; j <= adaptTempBin; ++j) {
-              potEnergyAve0 += adaptTempPotEnergyAve[j]; 
-              DeltaE2Ave = adaptTempPotEnergyVar[j];
-              DeltaE2AveSum += DeltaE2Ave;
-              A0 += j*DeltaE2Ave;
-          }
-          A0 *= adaptTempDBeta;
-          A0 += (adaptTempBetaMin+0.5*adaptTempDBeta-betaMinus)*DeltaE2AveSum;
-          A0 *= adaptTempDBeta;
-          betaj = adaptTempBetaN[nMinus+1]-betaMinus; 
-          betaj *= betaj;
-          A0 += 0.5*betaj*adaptTempPotEnergyVar[nMinus];
-          A0 /= (betaNp1-betaMinus);
 
-          //A1 phi_s integral for beta_{i+1} < beta < beta_plus
-          DeltaE2AveSum = 0;
-          for (j = adaptTempBin+1; j < nPlus; j++) {
-              potEnergyAve1 += adaptTempPotEnergyAve[j];
-              DeltaE2Ave = adaptTempPotEnergyVar[j];
-              DeltaE2AveSum += DeltaE2Ave;
-              A1 += j*DeltaE2Ave;
+      // compute the default variance for lack of data
+      BigReal denMax = 0, defVar = 0;
+      for ( j = nMinus; j < nPlus; j++ ) {
+        if ( adaptTempPotEnergyAveDen[j] > denMax ) {
+          denMax = adaptTempPotEnergyAveDen[j];
+          defVar = adaptTempPotEnergyVar[j];
           }
-          A1 *= adaptTempDBeta;   
-          A1 += (adaptTempBetaMin+0.5*adaptTempDBeta-betaPlus)*DeltaE2AveSum;
-          A1 *= adaptTempDBeta;
-          if ( nPlus < adaptTempBins ) {
-            betaj = betaPlus-adaptTempBetaN[nPlus];
-            betaj *= betaj;
-            A1 -= 0.5*betaj*adaptTempPotEnergyVar[nPlus];
           }
-          A1 /= (betaPlus-betaNp1);
-
-          //A2 phi_t integral for beta_i
-          A2 = 0.5*adaptTempDBeta*potEnergyVariance;
 
-          // Now calculate a+ and a-
-          DeltaE2Ave = A0-A1;
-          BigReal aplus = 0;
-          BigReal aminus = 0;
-          if (DeltaE2Ave != 0) {
-            aplus = (A0-A2)/(A0-A1);
-            if (aplus < 0) {
-                    aplus = 0;
+      BigReal var;
+      for ( j = nMinus; j <= i; j++ ) {
+        potEnergyAve0 += adaptTempPotEnergyAveNum[j];
+        den0 += adaptTempPotEnergyAveDen[j];
+        var = (adaptTempPotEnergySamples[j] > varCntMin) ? adaptTempPotEnergyVar[j] : defVar;
+        A0 += var * (j - nMinus + 0.5);
             }
-            if (aplus > 1)  {
-                    aplus = 1;
+      if ( den0 > 0 ) {
+        potEnergyAve0 /= den0;
+        A0 /= den0;
+        //A2 phi_t integral for beta_i
+        var = (adaptTempPotEnergySamples[i] > varCntMin) ? adaptTempPotEnergyVar[i] : defVar;
+        A2 = 0.5 * var * (i - nMinus + 1) / den0;
             }
-            aminus = 1-aplus;
-            potEnergyAve0 *= adaptTempDBeta;
-            potEnergyAve0 += adaptTempPotEnergyAve[nMinus]*(adaptTempBetaN[nMinus+1]-betaMinus);
-            potEnergyAve0 /= (betaNp1-betaMinus);
-            potEnergyAve1 *= adaptTempDBeta;
-            if ( nPlus < adaptTempBins ) {
-                potEnergyAve1 += adaptTempPotEnergyAve[nPlus]*(betaPlus-adaptTempBetaN[nPlus]);
+
+      //A1 phi_s integral for beta_{i+1} < beta < beta_plus
+      for ( j = i + 1; j < nPlus; j++ ) {
+        potEnergyAve1 += adaptTempPotEnergyAveNum[j];
+        den1 += adaptTempPotEnergyAveDen[j];
+        var = (adaptTempPotEnergySamples[j] > varCntMin) ? adaptTempPotEnergyVar[j] : defVar;
+        A1 += var * (j - nPlus + 0.5);
             }
-            potEnergyAve1 /= (betaPlus-betaNp1);
-            potEnergyAverage = aminus*potEnergyAve0;
-            potEnergyAverage += aplus*potEnergyAve1;
+      if ( den1 > 0 ) {
+        potEnergyAve1 /= den1;
+        A1 /= den1;
           }
+
+      if ( den0 + den1 <= 0 ) {
+        potEnergyAverage = def;
+      } else {
+        // Now calculate a+ and a-
+        BigReal aplus = ( den0 + den1 > 0 ) ? (A0 - A2) / (A0 - A1) : 0;
+        if ( aplus < 0 ) aplus = 0;
+        if ( aplus > 1 ) aplus = 1;
+        BigReal aminus = 1 - aplus;
+        potEnergyAverage = aminus * potEnergyAve0 + aplus * potEnergyAve1;
           if (simParams->adaptTempDebug) {
        iout << "ADAPTEMP DEBUG:"  << "\n"
-            << "     adaptTempBin:    " << adaptTempBin << "\n"
-            << "     Samples:   " << adaptTempPotEnergySamples[adaptTempBin] << "\n"
-            << "     adaptTempBeta:   " << adaptTempBeta << "\n" 
+               << "     adaptTempBin:    " << i << "\n"
+               << "     Samples:   " << adaptTempPotEnergySamples[i] << "\n"
+               << "     potentialEnergeAverage:  " << potEnergyAverage << "\n"
             << "     adaptTemp:   " << adaptTempT<< "\n"
             << "     betaMin:   " << adaptTempBetaMin << "\n"
             << "     betaMax:   " << adaptTempBetaMax << "\n"
-            << "     gammaAve:  " << gammaAve << "\n"
-            << "     deltaBeta: " << deltaBeta << "\n"
-            << "     betaMinus: " << betaMinus << "\n"
-            << "     betaPlus:  " << betaPlus << "\n"
+               << "     deltaBeta: " << (i - nMinus) * adaptTempDBeta << "\n"
+               << "     betaMinus: " << adaptTempBetaN[nMinus] << "\n"
+               << "     betaPlus:  " << adaptTempBetaN[nPlus] << "\n"
             << "     nMinus:    " << nMinus << "\n"
             << "     nPlus:     " << nPlus << "\n"
             << "     A0:        " << A0 << "\n"
@@ -1851,105 +2336,206 @@
             << "     A2:        " << A2 << "\n"
             << "     a+:        " << aplus << "\n"
             << "     a-:        " << aminus << "\n"
+               << "     aveEner:   " << potEnergyAverage << "\n"
+               << "     aveEne0:   " << potEnergyAve0 << "\n"
+               << "     aveEne1:   " << potEnergyAve1 << "\n"
+               << "     den0:      " << den0 << "\n"
+               << "     den1:      " << den1 << "\n"
             << endi;
           }
       }
-      else {
-          if (simParams->adaptTempDebug) {
-       iout << "ADAPTEMP DEBUG:"  << "\n"
-            << "     adaptTempBin:    " << adaptTempBin << "\n"
-            << "     Samples:   " << adaptTempPotEnergySamples[adaptTempBin] << "\n"
-            << "     adaptTempBeta:   " << adaptTempBeta << "\n" 
-            << "     adaptTemp:   " << adaptTempT<< "\n"
-            << "     betaMin:   " << adaptTempBetaMin << "\n"
-            << "     betaMax:   " << adaptTempBetaMax << "\n"
-            << "     gammaAve:  " << gammaAve << "\n"
-            << "     deltaBeta:  N/A\n"
-            << "     betaMinus:  N/A\n"
-            << "     betaPlus:   N/A\n"
-            << "     nMinus:     N/A\n"
-            << "     nPlus:      N/A\n"
-            << "     A0:         N/A\n"
-            << "     A1:         N/A\n"
-            << "     A2:         N/A\n"
-            << "     a+:         N/A\n"
-            << "     a-:         N/A\n"
-            << endi;
           }
+    return potEnergyAverage;
       }
       
-      //dT is new temperature
-      BigReal dT = ((potentialEnergy-potEnergyAverage)/BOLTZMANN+adaptTempT)*adaptTempDt;
-      dT += random->gaussian()*sqrt(2.*adaptTempDt)*adaptTempT;
-      dT += adaptTempT;
+BigReal Controller::adaptTempMCMove(BigReal tp, BigReal ep)
+{
+    double lnbeta = log(1./tp), nlnbeta, beta, nbeta, delta, epave;
+    int i, ni, j;
+    adaptTempMCTot += 1;
+    nlnbeta = lnbeta + simParams->adaptTempMCSize * random->gaussian();
+    nbeta = exp(nlnbeta);
+    beta = 1.0 / tp;
+    i = (int) ( (beta - adaptTempBetaMin) / adaptTempDBeta );
+    ni = (int) ( (nbeta - adaptTempBetaMin) / adaptTempDBeta );
+    //CkPrintf("delta %g, beta %g, %g, ep %g, i %d, %d\n", delta, beta, nbeta, ep, i, ni);
+    if ( nbeta < adaptTempBetaMin || ni >= adaptTempBins ) {
+      // out of boundary move
+      return tp;
+    }
+    // recompute the average values
+    if ( !simParams->adaptTempFixedAve ) {
+      adaptTempPotEnergyAve[i] = epave = adaptTempGetPEAve(i);
+      if ( i <= ni ) {
+        for ( j = i + 1; j <= ni; j++ )
+          adaptTempPotEnergyAve[j] = adaptTempGetPEAve(j, epave);
+      } else { // i > ni
+        for ( j = i - 1; j >= ni; j-- )
+          adaptTempPotEnergyAve[j] = adaptTempGetPEAve(j, epave);
+      }
+    }
+    // compute Integrate E dbeta
+    if ( i < ni ) {
+      epave = adaptTempPotEnergyAve[i];
+      delta = epave * (adaptTempBetaN[i+1] - beta);
+      for ( j = i + 1; j < ni; j++ ) {
+        epave = adaptTempPotEnergyAve[j];
+        delta += epave * adaptTempDBeta;
+      }
+      epave = adaptTempPotEnergyAve[ni];
+      delta += epave * (nbeta - adaptTempBetaN[ni]);
+    } else if ( i == ni ) {
+      epave = adaptTempPotEnergyAve[i];
+      delta = epave * (nbeta - beta);
+    } else { // i > ni
+      epave = adaptTempPotEnergyAve[i];
+      delta = epave * (adaptTempBetaN[i] - beta);
+      for ( j = i - 1; j > ni; j-- ) {
+        epave = adaptTempPotEnergyAve[j];
+        delta -= epave * adaptTempDBeta;
+      }
+      epave = adaptTempPotEnergyAve[ni];
+      delta += epave * (nbeta - adaptTempBetaN[ni + 1]);
+    }
+    delta = (delta - ep * (nbeta - beta)) / BOLTZMANN
+          + (simParams->adaptTempWeightExp - 1) * log(beta/nbeta);
+    if ( simParams->adaptTempDebug ) {
+      CkPrintf("delta %g cf %g, beta %g, %g, ep %g, %g, bin %d, %d\n", delta,
+          ((adaptTempPotEnergyAve[i]+adaptTempPotEnergyAve[ni])/2 - ep) * (nbeta - beta) / BOLTZMANN,
+          beta, nbeta, ep, epave, i, ni); // getchar();
+    }
+    int acc = ( delta > 0 || random->uniform() < exp(delta) );
+    adaptTempMCAcc += acc;
+    if ( acc && delta < 0 ) { // for d(acc. ratio)/d(ln beta)
+      double del = (ep - epave) * nbeta / BOLTZMANN + (simParams->adaptTempWeightExp - 1);
+      adaptTempMCDAcc += (nbeta > beta ? -del : del);
+    }
+    return acc ? 1.0/nbeta : tp;
+}
       
-     // Check if dT in [adaptTempTmin,adaptTempTmax]. If not try simpler estimate of mean
-     // This helps sampling with poor statistics in the bins surrounding adaptTempBin.
-      if ( dT > 1./adaptTempBetaMin || dT  < 1./adaptTempBetaMax ) {
-        dT = ((potentialEnergy-adaptTempPotEnergyAve[adaptTempBin])/BOLTZMANN+adaptTempT)*adaptTempDt;
-        dT += random->gaussian()*sqrt(2.*adaptTempDt)*adaptTempT;
-        dT += adaptTempT;
-        // Check again, if not then keep original adaptTempTor assign random.
-        if ( dT > 1./adaptTempBetaMin ) {
-          if (!simParams->adaptTempRandom) {             
-             //iout << iWARN << "ADAPTEMP: " << step << " T= " << dT 
-             //     << " K higher than adaptTempTmax."
-             //     << " Keeping temperature at " 
-             //     << adaptTempT<< "\n"<< endi;             
-             dT = adaptTempT;
+Bool Controller::adaptTempUpdate(int step, int minimize)
+{
+    Bool scaled = FALSE;
+    //Beta = 1./T
+    if ( !simParams->adaptTempOn ) return scaled;
+    int j = 0;
+    if (step == simParams->firstTimestep) {
+        adaptTempInit(step);
+        return scaled;
           }
-          else {             
-             //iout << iWARN << "ADAPTEMP: " << step << " T= " << dT 
-             //     << " K higher than adaptTempTmax."
-             //     << " Assigning random temperature in range\n" << endi;
-             dT = adaptTempBetaMin +  random->uniform()*(adaptTempBetaMax-adaptTempBetaMin);             
-             dT = 1./dT;
+    if ( minimize || (step < simParams->adaptTempFirstStep ) || 
+        ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) return scaled;
+    //Calculate Current inverse temperature and bin 
+    BigReal adaptTempBeta = 1./adaptTempT;
+    adaptTempBin   = (int)floor((adaptTempBeta - adaptTempBetaMin)/adaptTempDBeta);
+
+    if (adaptTempBin < 0 || adaptTempBin > adaptTempBins)
+        iout << iWARN << " adaptTempBin out of range: adaptTempBin: " << adaptTempBin  
+                               << " adaptTempBeta: " << adaptTempBeta 
+                               << " adaptTempDBeta: " << adaptTempDBeta 
+                               << " betaMin:" << adaptTempBetaMin 
+                               << " betaMax: " << adaptTempBetaMax << "\n";
+    if ( adaptTempBin < 0 ) {
+      adaptTempBin = 0;
+    } else if ( adaptTempBin >= adaptTempBins ) {
+      adaptTempBin = adaptTempBins - 1;
           }
+    adaptTempPotEnergySamples[adaptTempBin] += 1;
+    BigReal gammaAve = 1.-adaptTempCg/adaptTempPotEnergySamples[adaptTempBin];
+    if ( gammaAve < 0 ) gammaAve = 0;
+
+    BigReal potentialEnergy;
+    BigReal potEnergyAverage;
+    BigReal potEnergyVariance;
+
+    // recompute the potential energy
+    BigReal bondEnergy = reduction->item(REDUCTION_BOND_ENERGY);
+    BigReal angleEnergy = reduction->item(REDUCTION_ANGLE_ENERGY);
+    BigReal dihedralEnergy = reduction->item(REDUCTION_DIHEDRAL_ENERGY);
+    BigReal improperEnergy = reduction->item(REDUCTION_IMPROPER_ENERGY);
+    BigReal crosstermEnergy = reduction->item(REDUCTION_CROSSTERM_ENERGY);
+    BigReal boundaryEnergy = reduction->item(REDUCTION_BC_ENERGY);
+    BigReal miscEnergy = reduction->item(REDUCTION_MISC_ENERGY);
+    if ( step % nbondFreq == 0 ) {
+      electEnergy = reduction->item(REDUCTION_ELECT_ENERGY);
+      ljEnergy = reduction->item(REDUCTION_LJ_ENERGY);
+      BigReal volume = state->lattice.volume();
+      if (simParams->LJcorrection && volume) {
+        // Apply tail correction to energy
+        ljEnergy += Node::Object()->molecule->tail_corr_ener / volume;
         } 
-        else if ( dT  < 1./adaptTempBetaMax ) {
-          if (!simParams->adaptTempRandom) {            
-            //iout << iWARN << "ADAPTEMP: " << step << " T= "<< dT 
-            //     << " K lower than adaptTempTmin."
-            //     << " Keeping temperature at " << adaptTempT<< "\n" << endi; 
-            dT = adaptTempT;
+      groLJEnergy = reduction->item(REDUCTION_GRO_LJ_ENERGY);
+      groGaussEnergy = reduction->item(REDUCTION_GRO_GAUSS_ENERGY);
+      goNativeEnergy = reduction->item(REDUCTION_GO_NATIVE_ENERGY);
+      goNonnativeEnergy = reduction->item(REDUCTION_GO_NONNATIVE_ENERGY);
+      goTotalEnergy = goNativeEnergy + goNonnativeEnergy;
           }
-          else {
-            //iout << iWARN << "ADAPTEMP: " << step << " T= "<< dT 
-            //     << " K lower than adaptTempTmin."
-            //     << " Assigning random temperature in range\n" << endi;
-            dT = adaptTempBetaMin +  random->uniform()*(adaptTempBetaMax-adaptTempBetaMin);
-            dT = 1./dT;
+    if ( step % slowFreq == 0 ) {
+      electEnergySlow = reduction->item(REDUCTION_ELECT_ENERGY_SLOW);
           }
+    potentialEnergy = bondEnergy + angleEnergy + dihedralEnergy
+	+ improperEnergy + electEnergy + electEnergySlow + ljEnergy
+	+ crosstermEnergy + boundaryEnergy + miscEnergy
+        + goTotalEnergy + groLJEnergy + groGaussEnergy;
+    totalEnergy = potentialEnergy + kineticEnergy;
+
+    if ( !simParams->adaptTempFixedAve ) {
+      BigReal invw = adaptTempGetInvW(adaptTempT);
+
+      //calculate new bin average and variance using adaptive averaging
+      adaptTempPotEnergyAveNum[adaptTempBin] = adaptTempPotEnergyAveNum[adaptTempBin]*gammaAve + potentialEnergy * invw;
+      adaptTempPotEnergyAveDen[adaptTempBin] = adaptTempPotEnergyAveDen[adaptTempBin]*gammaAve + invw;
+      adaptTempPotEnergyVarNum[adaptTempBin] = adaptTempPotEnergyVarNum[adaptTempBin]*gammaAve + potentialEnergy*potentialEnergy * invw;
+      
+      potEnergyAverage = adaptTempPotEnergyAveNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
+      potEnergyVariance = adaptTempPotEnergyVarNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
+      potEnergyVariance -= potEnergyAverage*potEnergyAverage;
+
+      adaptTempPotEnergyAve[adaptTempBin] = potEnergyAverage;
+      adaptTempPotEnergyVar[adaptTempBin] = potEnergyVariance;
+
+      if ( simParams->adaptTempSepOn ) { // update separate accumulators
+        for ( j = adaptTempBin; j >= 0; j-- ) { // search downward
+          if ( adaptTempBinPlus[j] <= adaptTempBin ) break;
+          adaptTempSepAcc[j].add(adaptTempBin, potentialEnergy, invw, adaptTempCg);
         }
-        else if (adaptTempAutoDt) {
-          //update temperature step size counter
-          //FOR "TRUE" ADAPTIVE TEMPERING 
-          BigReal adaptTempTdiff = fabs(dT-adaptTempT);
-          if (adaptTempTdiff > 0) {
-            adaptTempDTave += adaptTempTdiff; 
-            adaptTempDTavenum++;
-//            iout << "ADAPTEMP: adapTempTdiff = " << adaptTempTdiff << "\n";
+        for ( j = adaptTempBin + 1; j < adaptTempBins; j++ ) { // search upward
+          if ( adaptTempBinMinus[j] > adaptTempBin ) break;
+          adaptTempSepAcc[j].add(adaptTempBin, potentialEnergy, invw, adaptTempCg);
           }
-          if(adaptTempDTavenum == 100){
-                BigReal Frac;
-                adaptTempDTave /= adaptTempDTavenum;
-                Frac = 1./adaptTempBetaMin-1./adaptTempBetaMax;
-                Frac = adaptTempDTave/Frac;
-                //if average temperature jump is > 3% of temperature range,
-                //modify jump size to match 3%
-                iout << "ADAPTEMP: " << step << " FRAC " << Frac << "\n"; 
-                if (Frac > adaptTempDtMax || Frac < adaptTempDtMin) {
-                    Frac = adaptTempDtMax/Frac;
-                    iout << "ADAPTEMP: Updating adaptTempDt to ";
-                    adaptTempDt *= Frac;
-                    iout << adaptTempDt << "\n" << endi;
                 }
-                adaptTempDTave = 0;
-                adaptTempDTavenum = 0;
           }
+
+    // Weighted integral of <Delta E^2>_beta dbeta <= Eq 4 of JCP 132 244101
+    // Integrals of Eqs 5 and 6 is done as piecewise assuming <Delta E^2>_beta
+    // is constant for each bin. This is to estimate <E(beta)> where beta \in
+    // (beta_i,beta_{i+1}) using Eq 2 of JCP 132 244101
+    if ( ! ( step % simParams->adaptTempFreq ) ) {
+      BigReal dT; // dT is the new temperature
+
+      if ( adaptTempPotEnergySamples[adaptTempBin] <= simParams->adaptTempSamplesMin ) {
+        // avoid making temperature transitions without enough samples
+        dT = adaptTempT;
+      } else if ( simParams->adaptTempMCMove ) {
+        dT = adaptTempMCMove(adaptTempT, potentialEnergy);
+      } else {
+        if ( simParams->adaptTempFixedAve ) {
+          potEnergyAverage = adaptTempPotEnergyAve[adaptTempBin];
+        } else {
+          potEnergyAverage = adaptTempGetPEAve(adaptTempBin);
         }
+
+        dT = ( (potentialEnergy - potEnergyAverage) / BOLTZMANN
+               + adaptTempT * simParams->adaptTempWeightExp ) * adaptTempDt;
+        dT += random->gaussian()*sqrt(2.*adaptTempDt)*adaptTempT;
+        dT += adaptTempT;
       }
-      else if (adaptTempAutoDt) {
+
+     // Check if dT in [adaptTempTmin,adaptTempTmax]. If not try simpler estimate of mean
+     // This helps sampling with poor statistics in the bins surrounding adaptTempBin.
+      if ( dT > 1./adaptTempBetaMin || dT  < 1./adaptTempBetaMax ) {
+        dT = adaptTempT;
+      } else if (adaptTempAutoDt) {
           //update temperature step size counter
           // FOR "TRUE" ADAPTIVE TEMPERING
           BigReal adaptTempTdiff = fabs(dT-adaptTempT);
@@ -1979,19 +2565,48 @@
           
       }
       
+      BigReal tScale = dT / adaptTempT;
+      BigReal vScale = sqrt(tScale);
+      // for velocity-rescaling-based thermostats,
+      // carry the velocity-rescaling factor to the next step
+      if ( simParams->langRescaleOn ) {
+        langRescaleFactorPrev *= vScale;
+      } else if ( simParams->tNHCOn ) {
+        tNHCRescaleFactorPrev *= vScale;
+      }
       adaptTempT = dT; 
       broadcast->adaptTemperature.publish(step,adaptTempT);
+      scaled = TRUE;
+      // temperature is to be used for the Langevin velocity-rescaling
+      // and NH-chain thermostats, so it needs to be updated.
+      temperature *= tScale;
+      totalEnergy += kineticEnergy * (tScale - 1);
+      kineticEnergy *= tScale;
+      kineticEnergyCentered *= tScale;
     }
+    if ( step % simParams->adaptTempRestartFreq == 0 )
     adaptTempWriteRestart(step);
-    if ( ! (step % adaptTempOutFreq) ) {
+    if ( ! (step % simParams->adaptTempOutFreq) ) {
         iout << "ADAPTEMP: STEP " << step
              << " TEMP "   << adaptTempT
+             << " BIN " << adaptTempBin
              << " ENERGY " << std::setprecision(10) << potentialEnergy   
-             << " ENERGYAVG " << std::setprecision(10) << potEnergyAverage
-             << " ENERGYVAR " << std::setprecision(10) << potEnergyVariance;
+             << " ENERGYAVG " << adaptTempPotEnergyAve[adaptTempBin]
+             << " ENERGYVAR " << adaptTempPotEnergyVar[adaptTempBin];
+        if ( simParams->adaptTempMCMove && adaptTempMCTot > 0 ) {
+          BigReal acc = adaptTempMCAcc / adaptTempMCTot;
+          BigReal dacc = adaptTempMCDAcc / adaptTempMCTot;
+          if ( dacc > -0.01 ) dacc = -0.01;
+          BigReal newsize = simParams->adaptTempMCSize + (0.5 - acc) / dacc;
+          if ( newsize < 0 ) newsize = 0;
+          iout << " MC " << adaptTempMCTot
+               << " ACC. RATIO " << std::setprecision(5) << 100.0 * acc << "%"
+               << " DAR" << dacc
+               << " SIZE " << simParams->adaptTempMCSize << " -> " << newsize;
+        }
         iout << "\n" << endi;
    }
-   
+   return scaled;
 }
 
 
@@ -2277,6 +2892,15 @@
       electEnergy = reduction->item(REDUCTION_ELECT_ENERGY);
       ljEnergy = reduction->item(REDUCTION_LJ_ENERGY);
 
+      if (simParameters->LJcorrection && volume) {
+        // Apply tail correction to energy
+        //printf("Volume is %f\n", volume);
+        //printf("Applying tail correction of %f to energy\n", molecule->tail_corr_ener / volume);
+        ljEnergy += molecule->tail_corr_ener / volume;
+        ljEnergy_f += molecule->tail_corr_ener / volume;
+        ljEnergy_f_left += molecule->tail_corr_ener / volume;
+      }
+
       // JLai
       groLJEnergy = reduction->item(REDUCTION_GRO_LJ_ENERGY);
       groGaussEnergy = reduction->item(REDUCTION_GRO_GAUSS_ENERGY);
@@ -2310,16 +2934,6 @@
 //fepe
     }
 
-    if (simParameters->LJcorrection && volume) {
-      // Apply tail correction to energy
-      //printf("Volume is %f\n", volume);
-      //printf("Applying tail correction of %f to energy\n", molecule->tail_corr_ener / volume);
-      ljEnergy += molecule->tail_corr_ener / volume;
-      ljEnergy_f += molecule->tail_corr_ener / volume;
-      ljEnergy_f_left += molecule->tail_corr_ener / volume;
-    }
-
-
     momentum.x = reduction->item(REDUCTION_MOMENTUM_X);
     momentum.y = reduction->item(REDUCTION_MOMENTUM_Y);
     momentum.z = reduction->item(REDUCTION_MOMENTUM_Z);
@@ -3147,6 +3761,7 @@
     ldbSteps = LdbCoordinator::Object()->getNumStepsToRun();
   }
   if ( ! --ldbSteps ) {
+    //CkPrintf("Controller: rebalancing %d, thread %p\n", step, CthSelf());
     startBenchTime -= CmiWallTimer();
 	Node::Object()->outputPatchComputeMaps("before_ldb", step);
     LdbCoordinator::Object()->rebalance(this);	
Only in spec_new: .Controller.C.swp
diff -u -wdB spec_old/Controller.h spec_new/Controller.h
--- spec_old/Controller.h	2015-10-12 10:48:41.000000000 -0500
+++ spec_new/Controller.h	2016-08-09 19:26:59.863780865 -0500
@@ -151,10 +151,38 @@
     void enqueueCollections(int);
     void correctMomentum(int step);
     void rescaleVelocities(int);
+    void rescaleVelocitiesInit(void);
+    void rescaleVelocitiesLoad(void);
+    void rescaleVelocitiesSave(int);
       BigReal rescaleVelocities_sumTemps;
       int rescaleVelocities_numTemps;
+      BigReal rescaleVelocities_sum1;
+      BigReal rescaleVelocities_sumBeta;
+      BigReal rescaleVelocities_sumBeta2;
+      BigReal rescaleVelocities_sumDbde;
     void reassignVelocities(int);
     void tcoupleVelocities(int);
+    void langRescaleVelocities(int, Bool);
+    BigReal langRescaleFactorPrev;
+    void tNHCInit(void);
+    void tNHCDone(int);
+    void tNHCRescaleVelocities(int, Bool);
+    void tNHCSave(int);
+    void tNHCLoad(void);
+    BigReal tNHCRescaleFactorPrev;
+    BigReal *tNHCzeta;
+    BigReal *tNHCmass;
+    void keHistInit(void);
+    void keHistDone(int);
+    void keHistUpdate(int);
+    // save the kinetic energy to file
+    // the first column is the kinetic energy
+    // the second and third columns are the
+    // normalized histogram and the reference value
+    void keHistSave(int);
+    void keHistLoad(void);
+    BigReal *keHist;
+    int keHistBinMax;
     void berendsenPressure(int);
       // Tensor berendsenPressure_avg;
       // int berendsenPressure_count;
@@ -232,14 +260,166 @@
 
 //JS for adaptive temperature sampling
    void adaptTempInit(int step);
-   void adaptTempUpdate(int step, int minimize = 0);
+   void adaptTempDone(int step);
+   BigReal adaptTempGetInvW(BigReal tp);
+   BigReal adaptTempGetPEAve(int i, BigReal def = 0);
+   BigReal adaptTempMCMove(BigReal tp, BigReal ep);
+   Bool adaptTempUpdate(int step, int minimize = 0);
    void adaptTempWriteRestart(int step);
-   BigReal *adaptTempPotEnergyAveNum;
-   BigReal *adaptTempPotEnergyAveDen;
-   BigReal *adaptTempPotEnergyVarNum;
-   BigReal *adaptTempPotEnergyAve;
-   BigReal *adaptTempPotEnergyVar;
-   int     *adaptTempPotEnergySamples;
+   int *adaptTempBinMinus;
+   int *adaptTempBinPlus;
+   // separator accumulator
+   struct AdaptTempSepAcc {
+     int bin0; // first bin
+     int winSize;
+     double *sumw;
+     double *sumE;
+     double *sumE2;
+     double *ave;
+     double *var;
+     double *cnt;
+     double total;
+     double invGamma;
+
+     AdaptTempSepAcc(void) {
+       winSize = 0;
+     }
+
+     ~AdaptTempSepAcc(void) {
+       if ( winSize > 0 ) {
+         delete [] sumw;
+         delete [] sumE;
+         delete [] sumE2;
+         delete [] ave;
+         delete [] var;
+         delete [] cnt;
+       }
+     }
+
+     // initialize the window
+     void init(int minus, int plus) {
+       bin0 = minus;
+       winSize = plus - minus;
+       if ( winSize % 2 == 0 ) NAMD_die("Window size should be odd");
+       total = 0;
+       invGamma = 1;
+       sumw  = new double[winSize];
+       sumE  = new double[winSize];
+       sumE2 = new double[winSize];
+       ave   = new double[winSize];
+       var   = new double[winSize];
+       cnt   = new double[winSize];
+       for ( int j = 0; j < winSize; j++ ) {
+         sumw[j]  = 0;
+         sumE[j]  = 0;
+         sumE2[j] = 0;
+         ave[j]   = 0;
+         var[j]   = 0;
+         cnt[j]   = 0;
+       }
+     }
+
+     // compute the average and variance of each bin
+     void trim(void) {
+       if ( invGamma > 1.0 ) { // renormalize the running weight
+         double gam = 1.0/invGamma;
+         for ( int j = 0; j < winSize; j++ ) {
+           sumw[j]  *= gam;
+           sumE[j]  *= gam;
+           sumE2[j] *= gam;
+         }
+         invGamma = 1;
+       }
+       
+       for ( int j = 0; j < winSize; j++ ) {
+         if ( sumw[j] > 0 ) {
+           ave[j] = sumE[j] / sumw[j];
+           var[j] = sumE2[j] / sumw[j] - ave[j] * ave[j];
+         } else {
+           ave[j] = 0;
+           var[j] = 0;
+         }
+         //CkPrintf("j %d, %g %g %g %g %g\n", j, sumw[j], sumE[j], sumE2[j], ave[j], var[j]);
+       }
+     }
+
+     // add a data point from bin i to this accumulator
+     void add(int i, BigReal potEne, BigReal invw, BigReal cg) {
+       i -= bin0; // convert to the local index
+       if ( i < 0 || i >= winSize ) {
+         CkPrintf("Bad local index for bin0 %d: i %d, winSize %d\n", bin0, i + bin0, winSize);
+         NAMD_die("Adaptive tempering: bad local index.");
+       }
+       total += 1;
+       double gamma = 1 - cg / total;
+       if ( gamma < 1e-8 ) gamma = 1e-8;
+       invGamma /= gamma;
+       invw *= invGamma;
+       sumw[i]  += invw;
+       sumE[i]  += invw * potEne;
+       sumE2[i] += invw * potEne * potEne;
+       cnt[i]   += 1;
+       //CkPrintf("adding to bin %d with potEne %g\n", i, potEne);
+     }
+
+     // compute the average energy from the integral identity
+     BigReal iiave(BigReal varCntMin, BigReal def = 0) {
+       int j, mid = winSize / 2;
+       double ave0 = 0.0, ave1 = 0.0, den0 = 0.0, den1 = 0.0;
+       double A0 = 0, A1 = 0, A2 = 0, cntMax = 0, defVar = 0, varj;
+       trim();
+       // compute the default variance from the most populated bin
+       for ( j = 0; j < winSize; j++ ) {
+         if ( sumw[j] > cntMax ) {
+           cntMax = sumw[j];
+           defVar = var[j];
+         }
+       }
+       // left side
+       for ( j = 0; j <= mid; j++ ) {
+         ave0 += sumE[j];
+         den0 += sumw[j];
+         varj = (cnt[j] > varCntMin) ? var[j] : defVar;
+         A0 += varj * (j + 0.5);
+         //CkPrintf("+ %d %g %g %g\n", j, sumw[j], sumE[j], invw[j]);
+       }
+       if ( den0 > 0 ) {
+         ave0 /= den0;
+         A0 /= den0;
+         // middle bin correction
+         varj = (cnt[mid] > varCntMin) ? var[mid] : defVar;
+         A2 = 0.5 * varj * (mid + 1) / den0;
+       }
+       // right side
+       for ( j = mid + 1; j < winSize; j++ ) {
+         ave1 += sumE[j];
+         den1 += sumw[j];
+         varj = (cnt[j] > varCntMin) ? var[j] : defVar;
+         A1 += varj * (j - winSize + 0.5);
+         //CkPrintf("+ %d %g %g %g\n", j, sumw[j], sumE[j], invw[j]);
+       }
+       if ( den1 > 0 ) {
+         ave1 /= den1;
+         A1 /= den1;
+       }
+       if ( den0 + den1 <= 0 ) return def;
+       // compute a+ and a-
+       double aplus = ( den0 + den1 > 0 ) ? (A0 - A2) / (A0 - A1) : 0;
+       if ( aplus < 0 ) aplus = 0;
+       if ( aplus > 1 ) aplus = 1;
+       double aminus = 1 - aplus;
+       //CkPrintf("A0 %g, A1 %g, A2 %g, a- %g, a+ %g, ave %g, %g, %g\n", A0, A1, A2, aminus, aplus, ave0, ave1, aminus * ave0 + aplus * ave1); getchar();
+       return aminus * ave0 + aplus * ave1;
+     }
+   };
+   AdaptTempSepAcc *adaptTempSepAcc;
+   double  adaptTempMCTot, adaptTempMCAcc, adaptTempMCDAcc;
+   double  *adaptTempPotEnergyAveNum;
+   double  *adaptTempPotEnergyAveDen;
+   double  *adaptTempPotEnergyVarNum;
+   double  *adaptTempPotEnergyAve;
+   double  *adaptTempPotEnergyVar;
+   long    *adaptTempPotEnergySamples;
    BigReal *adaptTempBetaN;
    BigReal adaptTempT;
    BigReal adaptTempDTave;
@@ -256,6 +436,9 @@
    BigReal adaptTempDtMax;
    ofstream_namd adaptTempRestartFile;
   
+    // special atoms
+    void specInit(int scriptTask, int step);
+
 private:
     CthThread thread;
     static void threadRun(Controller*);
Only in spec_new: .Controller.h.swp
diff -u -wdB spec_old/fstream_namd.h spec_new/fstream_namd.h
--- spec_old/fstream_namd.h	2015-01-31 00:39:07.000000000 -0600
+++ spec_new/fstream_namd.h	2016-07-22 12:32:03.851785830 -0500
@@ -4,6 +4,11 @@
 
 #include <iostream>
 #include <sstream>
+#if !defined(WIN32) || defined(__CYGWIN__)
+#include <unistd.h>
+#else
+#include <io.h>
+#endif
 
 class ofstream_namd : public std::ostringstream {
 
@@ -31,6 +36,17 @@
     if ( fd ) close();
   }
 
+  void seekbegin() {
+    str("");
+#if !defined(WIN32) || defined(__CYGWIN__)
+    ftruncate(fd, 0);
+    lseek(fd, 0, SEEK_SET);
+#else
+    _chsize(fd, 0);
+    _lseek(fd, 0, SEEK_SET);
+#endif
+  }
+
   bool good() const { return true; }
   bool fail() const { return false; }
   bool bad() const { return false; }
diff -u -wdB spec_old/Molecule.C spec_new/Molecule.C
--- spec_old/Molecule.C	2015-12-07 16:17:19.000000000 -0600
+++ spec_new/Molecule.C	2016-07-19 16:39:02.544214865 -0500
@@ -5297,6 +5297,44 @@
   }
 #endif
 
+  if ( simParams->specAtomsOn ) {
+    ResizeArray<int> specIDs;
+
+    // here our sepcial atoms are the CA atoms
+    // scan all atoms and search for atom names of "CA"
+    // "CAY" and "CAT" are the atoms of the N-terminal
+    // and C-terminal caps
+    const char *specAtomNames[3] = {"CAY", "CA", "CAT"};
+    for ( int round = 0; round < 3; round++ ) {
+      const char *targetAtom = specAtomNames[round];
+      #ifdef MEM_OPT_VERSION
+      for ( int i = 0; i < numAtoms; i++ ) {
+        Index idx = atomNames[i].atomnameIdx;
+        if ( strcasecmp(atomNamePool[idx], targetAtom) == 0 ) {
+          specIDs.add(i);
+        }
+      }
+      #else
+      for ( int i = 0; i < numAtoms; i++ ) {
+        if ( strcasecmp(atomNames[i].atomname, targetAtom) == 0 ) {
+          specIDs.add(i);
+        }
+      }
+      #endif
+    }
+    
+    spcnt = specIDs.size();
+    specids = new int[spcnt];
+    // print out the special atoms
+    for ( int i = 0; i < spcnt; i++ ) {
+      specids[i] = specIDs[i];
+      CkPrintf("Mol CA %d: %d\n", i+1, specIDs[i]);
+    }
+    
+    msg->put(spcnt);
+    msg->put(spcnt, specids);
+  }
+
   // Broadcast the message to the other nodes
   msg->end();
   delete msg;
@@ -5758,6 +5796,12 @@
   }
 #endif
 
+  if ( simParams->specAtomsOn ) {
+    msg->get(spcnt);
+    specids = new int[spcnt];
+    msg->get(spcnt, specids);
+  }
+
       //  Now free the message 
       delete msg;
 
diff -u -wdB spec_old/Molecule.h spec_new/Molecule.h
--- spec_old/Molecule.h	2015-12-03 11:02:22.000000000 -0600
+++ spec_new/Molecule.h	2016-06-20 13:58:29.525793216 -0500
@@ -1266,6 +1266,10 @@
 
 #endif
 
+public:
+// special-atom stuff
+int spcnt, *specids;
+
 // Go stuff
 public:
 
diff -u -wdB spec_old/Random.h spec_new/Random.h
--- spec_old/Random.h	2003-02-10 16:41:19.000000000 -0600
+++ spec_new/Random.h	2016-07-05 15:09:41.984045144 -0500
@@ -140,6 +140,43 @@
     return Vector( gaussian(), gaussian(), gaussian() );
   }
 
+  // return a number from a gamma distribution of k degrees
+  BigReal gamma(BigReal k)
+  {
+    Bool lt1 = FALSE;
+    BigReal a, b, x, v, u;
+
+    if ( k <= 0 ) return 0;
+    if ( k < 1 ) {
+      lt1 = TRUE;
+      k += 1;
+    }
+    a = k - 1./3;
+    b = 1./3/sqrt(a);
+
+    for ( ; ; ) {
+      do {
+        x = gaussian();
+        v = 1 + b * x;
+      } while ( v <= 0 );
+      v *= v * v;
+      x *= x;
+      u = uniform();
+      if ( u <= 1 - 0.331 * x * x ) break;
+      u = log(u);
+      if ( u <= 0.5 * x + a * (1 - v + log(v)) ) break;
+    }
+
+    x = a * v;
+    if ( lt1 ) x *= pow(1. - uniform(), 1./(k - 1));
+    return x;
+  }
+
+  BigReal chisqr(BigReal k)
+  {
+    return gamma( k * 0.5 ) * 2;
+  }
+
   // return a random long
   long integer(void) {
     skip();
diff -u -wdB spec_old/Sequencer.C spec_new/Sequencer.C
--- spec_old/Sequencer.C	2016-06-01 17:24:35.531579311 -0500
+++ spec_new/Sequencer.C	2016-08-03 19:38:16.485661253 -0500
@@ -223,12 +223,7 @@
 
     // Is adaptive tempering on?
     const Bool adaptTempOn = simParams->adaptTempOn;
-    adaptTempT = simParams->initialTemp;
-    if (simParams->langevinOn)
-        adaptTempT = simParams->langevinTemp;
-    else if (simParams->rescaleFreq > 0)
-        adaptTempT = simParams->rescaleTemp;
-        
+    adaptTempT = simParams->thermostatTemp();
 
     int &doMolly = patch->flags.doMolly;
     doMolly = simParams->mollyOn && doFullElectrostatics;
@@ -274,6 +269,8 @@
     if ( accelMDOn && !accelMDdihe ) doEnergy=1;
     //Update energy every timestep for adaptive tempering
     if ( adaptTempOn ) doEnergy=1;
+    if ( simParams->energyLogFreq > 0 && step % simParams->energyLogFreq == 0 )
+      doEnergy = 1;
     runComputeObjects(1,step<numberOfSteps); // must migrate here!
     rescaleaccelMD(step, doNonbonded, doFullElectrostatics); // for accelMD 
     adaptTempUpdate(step); // update adaptive tempering temperature
@@ -325,6 +322,8 @@
     {
       rescaleVelocities(step);
       tcoupleVelocities(timestep,step);
+      langRescaleVelocities(step);
+      tNHCRescaleVelocities(step);
       berendsenPressure(step);
 
       if ( ! commOnly ) {
@@ -382,6 +381,8 @@
       doEnergy = ! ( step % energyFrequency );
       if ( accelMDOn && !accelMDdihe ) doEnergy=1;
       if ( adaptTempOn ) doEnergy=1; 
+      if ( simParams->energyLogFreq > 0 && step % simParams->energyLogFreq == 0 )
+        doEnergy = 1;
       runComputeObjects(!(step%stepsPerCycle),step<numberOfSteps);
  
       rescaleaccelMD(step, doNonbonded, doFullElectrostatics); // for accelMD
@@ -437,8 +438,20 @@
 
 	submitReductions(step);
 	submitCollections(step);
+
+        // submit special atoms
+        if ( simParams->specAtomsOn
+          && step % simParams->specAtomsFreq == 0 ) {
+          submitSpecPositions(step);
+        }
+
        //Update adaptive tempering temperature
-        adaptTempUpdate(step);
+        Bool scaled = adaptTempUpdate(step);
+        if ( scaled && (ldbSteps == 1 || LdbCoordinator::Object()->getNumStepsToRun() == 1) ) {
+          // submit Hi's if we're about to rebalance load
+          collection->submitHi(step);
+          //CkPrintf("Sequencer step %d, thread %p\n", step, CthSelf());
+        }
 
 #if CYCLE_BARRIER
         cycleBarrier(!((step+1) % stepsPerCycle), step);
@@ -471,6 +484,7 @@
             sprintf(traceNote, "%s%d",tracePrefix,step); 
             traceUserSuppliedNote(traceNote);
         }
+        //if ( ldbSteps == 1 ) CkPrintf("step %d, before rebalanceLoad(), Sequencer PE %d/%d, thread %p\n", step, CkMyPe(), CkNumPes(), CthSelf());
 	rebalanceLoad(step);
 
 #if PME_BARRIER
@@ -1182,19 +1196,28 @@
 
 }
 
-void Sequencer::adaptTempUpdate(int step)
+Bool Sequencer::adaptTempUpdate(int step)
 {
+   Bool scaled = FALSE;
+
    //check if adaptive tempering is enabled and in the right timestep range
-   if (!simParams->adaptTempOn) return;
+   if (!simParams->adaptTempOn) return scaled;
    if ( (step < simParams->adaptTempFirstStep ) || 
      ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) {
-        if (simParams->langevinOn) // restore langevin temperature
-            adaptTempT = simParams->langevinTemp;
-        return;
+        // restore the temperature of the active thermostat
+        adaptTempT = simParams->thermostatTemp();
+        return scaled;
    }
    // Get Updated Temperature
    if ( !(step % simParams->adaptTempFreq ) && (step > simParams->firstTimestep ))
+   {
+    BigReal adaptTempTOld = adaptTempT;
     adaptTempT = broadcast->adaptTemperature.get(step);
+    scaled = TRUE;
+    if ( !simParams->langRescaleOn && !simParams->tNHCOn )
+      rescaleVelocitiesByFactor( sqrt(adaptTempT / adaptTempTOld) );
+   }
+   return scaled;
 }
 
 void Sequencer::reassignVelocities(BigReal timestep, int step)
@@ -1289,6 +1312,26 @@
   }
 }
 
+void Sequencer::langRescaleVelocities(int step)
+{
+  if ( simParams->langRescaleOn ) {
+    FullAtom *a = patch->atom.begin();
+    BigReal factor = broadcast->langRescaleFactor.get(step);
+    for ( int i = 0; i < patch->numAtoms; ++i )
+      a[i].velocity *= factor;
+  }
+}
+
+void Sequencer::tNHCRescaleVelocities(int step)
+{
+  if ( simParams->tNHCOn ) {
+    FullAtom *a = patch->atom.begin();
+    BigReal factor = broadcast->tNHCRescaleFactor.get(step);
+    for ( int i = 0; i < patch->numAtoms; ++i )
+      a[i].velocity *= factor;
+  }
+}
+
 void Sequencer::saveForce(const int ftag)
 {
   patch->saveForce(ftag);
@@ -1952,6 +1995,28 @@
   }
 }
 
+void Sequencer::submitSpecPositions(int step)
+{
+  Molecule *mol = Node::Object()->molecule;
+  FullAtom *a = patch->atom.begin(), ai;
+  FullAtomList specArr;
+
+  for ( int i = 0; i < patch->numAtoms; i++ ) {
+    // see if local atom i is a special atom
+    for ( int j = 0; j < mol->spcnt; j++ ) {
+      if ( mol->specids[j] == a[i].id ) {
+        ai = a[i]; // copy the atom information
+        ai.id = j; // modify the ID to the special ID
+        specArr.add( ai );
+      }
+    }
+  }
+
+  //for ( int k = 0; k < al.size(); k++ )
+  //  CkPrintf("Sequencer::submitSpecPositions %d: %d, atom %d, %g %g %g\n", step, k, al[k].id, al[k].position.x, al[k].position.y, al[k].position.z);
+  collection->submitSpecPositions(step, specArr, patch->lattice);
+}
+
 void Sequencer::runComputeObjects(int migration, int pairlists)
 {
   if ( migration ) pairlistsAreValid = 0;
@@ -2127,6 +2192,7 @@
     ldbSteps = LdbCoordinator::Object()->getNumStepsToRun();
   }
   if ( ! --ldbSteps ) {
+    //CkPrintf("Sequencer : rebalancing %d, thread %p\n", timestep, CthSelf());
     patch->submitLoadStats(timestep);
     ldbCoordinator->rebalance(this,patch->getPatchID());
     pairlistsAreValid = 0;
diff -u -wdB spec_old/Sequencer.h spec_new/Sequencer.h
--- spec_old/Sequencer.h	2013-10-30 13:26:16.000000000 -0500
+++ spec_new/Sequencer.h	2016-07-05 15:22:15.630744564 -0500
@@ -47,6 +47,8 @@
     void submitMinimizeReductions(int, BigReal fmax2);
     void submitCollections(int step, int zeroVel = 0);
 
+    void submitSpecPositions(int step);
+
     void submitMomentum(int step);
     void correctMomentum(int step, BigReal drifttime);
 
@@ -74,7 +76,7 @@
     void reloadCharges();
 
     BigReal adaptTempT;         // adaptive tempering temperature
-    void adaptTempUpdate(int); // adaptive tempering temperature update
+    Bool adaptTempUpdate(int); // adaptive tempering temperature update
 
     void rescaleVelocities(int);
     void rescaleaccelMD(int, int, int); // for accelMD
@@ -83,6 +85,8 @@
     void reinitVelocities(void);
     void rescaleVelocitiesByFactor(BigReal);
     void tcoupleVelocities(BigReal,int);
+    void langRescaleVelocities(int);
+    void tNHCRescaleVelocities(int);
     void berendsenPressure(int);
       int berendsenPressure_count;
       int checkpoint_berendsenPressure_count;
diff -u -wdB spec_old/SimParameters.C spec_new/SimParameters.C
--- spec_old/SimParameters.C	2015-12-08 09:41:37.000000000 -0600
+++ spec_new/SimParameters.C	2016-08-09 20:50:32.513638793 -0500
@@ -187,6 +187,12 @@
   }
   SCRIPT_PARSE_FLOAT("reassignTemp",reassignTemp)
   SCRIPT_PARSE_FLOAT("rescaleTemp",rescaleTemp)
+  SCRIPT_PARSE_BOOL("rescaleAdaptive",rescaleAdaptiveOn)
+  SCRIPT_PARSE_FLOAT("rescaleAdaptiveDedk",rescaleAdaptiveDedk)
+  SCRIPT_PARSE_FLOAT("langRescaleTemp",langRescaleTemp)
+  SCRIPT_PARSE_FLOAT("langRescaleDt",langRescaleDt)
+  SCRIPT_PARSE_FLOAT("tNHCTemp",langRescaleTemp)
+  SCRIPT_PARSE_FLOAT("tNHCPeriod",langRescaleDt)
   SCRIPT_PARSE_BOOL("velocityQuenching",minimizeOn)
   SCRIPT_PARSE_BOOL("maximumMove",maximumMove)
   // SCRIPT_PARSE_BOOL("Langevin",langevinOn)
@@ -1178,6 +1184,58 @@
      "containing the temperature coupling term B(i);\n"
      "default is 'O'", PARSE_STRING);
 
+   //  Get parameters for the Langevin velocity-rescaling thermostat
+   opts.optionalB("main", "langrescale", 
+      "Should Langevin velocity-rescaling thermostat be turned on?",
+      &langRescaleOn, FALSE);
+   opts.require("langrescale", "langRescaleTemp",
+    "Temperature for Langevin velocity-rescaling thermostat",
+    &langRescaleTemp);
+   opts.range("langRescaleTemp", NOT_NEGATIVE);
+   opts.units("langRescaleTemp", N_KELVIN);
+   opts.optional("langrescale", "langRescaleDt",
+    "Inverse viscosity in femtoseconds for Langevin velocity-rescaling thermostat",
+    &langRescaleDt, 20.0);
+
+   //  Get parameters for the Nose-Hoover chain thermostat
+   //  Nose-Hoover chains: The canonical ensemble via continuous dynamics 
+   //  Glenn J. Martyna, Michael L. Klein, and Mark Tuckerman, JCP 97 (4) 2635
+   opts.optionalB("main", "tNHC", "Should Nose-Hoover chain thermostat be turned on?",
+      &tNHCOn, FALSE);
+   opts.require("tNHC", "tNHCTemp", "Temperature for Nose-Hoover chain thermostat",
+    &tNHCTemp);
+   opts.range("tNHCTemp", NOT_NEGATIVE);
+   opts.units("tNHCTemp", N_KELVIN);
+   opts.require("tNHC", "tNHCLen", "Length of Nose-Hoover chain",
+    &tNHCLen, 1);
+   opts.range("tNHCLen", POSITIVE);
+   opts.optional("tNHC", "tNHCPeriod", "Oscillation period in femtoseconds of the Nose-Hoover chain",
+    &tNHCPeriod, 100.0);
+   opts.range("tNHCPeriod", POSITIVE);
+   opts.optional("tNHC", "tNHCFile", "Restart file for the NH-chain",
+       tNHCFile);
+   opts.optional("tNHC", "tNHCFileFreq", "Frequency of writing restart file for the NH-chain",
+       &tNHCFileFreq, 10000);
+   opts.range("tNHCFileFreq", POSITIVE);
+   opts.optionalB("tNHC", "tNHCFileReadMass", "Read mass from the restart file, if any",
+       &tNHCFileReadMass, FALSE);
+
+   opts.optionalB("main", "keHist", "Should kinetic energy histogram be turned on?",
+       &keHistOn, FALSE);
+   opts.optional("keHist", "keHistBin", "Bin size of the histogram of the kinetic energy",
+       &keHistBin, 1.0);
+   opts.optional("keHist", "keHistFile", "Histogram file for the kinetic energy",
+       keHistFile);
+   opts.optional("keHist", "keHistFileFreq", "Frequency of writing the histogram file for the kinetic energy",
+       &keHistFileFreq, 10000);
+   opts.range("keHistFileFreq", POSITIVE);
+
+   opts.optional("main", "energyLogFile", "Energy log file",
+       energyLogFile);
+   opts.optional("energyLogFile", "energyLogFreq", "Frequency of writing the energy log file",
+       &energyLogFreq, 1);
+   opts.range("energyLogFreq", POSITIVE);
+
    opts.optional("main", "rescaleFreq", "Number of steps between "
     "velocity rescaling", &rescaleFreq);
    opts.range("rescaleFreq", POSITIVE);
@@ -1185,6 +1243,17 @@
     &rescaleTemp);
    opts.range("rescaleTemp", NOT_NEGATIVE);
    opts.units("rescaleTemp", N_KELVIN);
+   opts.optionalB("main", "rescaleAdaptive", "Adaptively reduce the magnitude "
+    "of the velocity rescaling", &rescaleAdaptiveOn, FALSE);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveDedk", "Heuristic multiple of the reduction factor ",
+    &rescaleAdaptiveDedk, 0.0);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveFile",
+       "File for writing the adaptive velocity-rescaling restart information",
+       rescaleAdaptiveFile);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveFileFreq",
+       "Frequency of writing the adaptive velocity-rescaling restart information",
+       &rescaleAdaptiveFileFreq, 10000);
+   opts.range("rescaleAdaptiveFileFreq", POSITIVE);
 
    opts.optional("main", "reassignFreq", "Number of steps between "
     "velocity reassignment", &reassignFreq);
@@ -1374,7 +1443,12 @@
    opts.range("adaptTempTmax", POSITIVE);
    opts.optional("adaptTempMD", "adaptTempBins","Number of bins to store average energies", &adaptTempBins,0);
    opts.range("adaptTempBins", NOT_NEGATIVE);
-   opts.optional("adaptTempMD", "adaptTempDt", "Integration timestep for Temp. updates", &adaptTempDt, 0.0001);
+   opts.optional("adaptTempMD", "adaptTempWindowSize", "Window size as a fraction of the inverse temperature range", &adaptTempWindowSize, 0.02);
+   opts.range("adaptTempWindowSize", NOT_NEGATIVE);
+   opts.optional("adaptTempMD", "adaptTempWeightExp", "Exponent x as in the inverse-temperature density, w(beta) ~ beta^(-x), 0: flat-beta, 1: flat-lnT, 2: flat-T distribution", &adaptTempWeightExp, 1.0);
+   opts.optionalB("adaptTempMD", "adaptTempMCMove", "Use Monte Carlo to update the temperature", &adaptTempMCMove, FALSE);
+   opts.optional("adaptTempMCMove", "adaptTempMCSize", "Magnitude of Monte Carlo temperature moves as a fraction of the current temperature", &adaptTempMCSize, 0.01);
+   opts.optional("adaptTempMD", "adaptTempDt", "Integration timestep for Temp. updates", &adaptTempDt, 0.00001);
    opts.units("adaptTempDt", N_FSEC);
    opts.range("adaptTempDt", NOT_NEGATIVE);
    opts.optional("adaptTempMD", "adaptTempAutoDt", "Average temperature update in percent of temperature range", &adaptTempAutoDt, 0.0);
@@ -1383,11 +1457,23 @@
    opts.range("adaptTempCgamma", NOT_NEGATIVE);
    opts.optionalB("adaptTempMD","adaptTempLangevin","Send adaptTemp temperature to langevin thermostat",&adaptTempLangevin,TRUE);
    opts.optionalB("adaptTempMD","adaptTempRescaling","Send adaptTemp temperature to velocity rescaling thermostat", &adaptTempRescale,TRUE);
+   opts.optionalB("adaptTempMD","adaptTempLangRescale","Send adaptTemp temperature to Langevin-style velocity rescaling thermostat", &adaptTempLangRescale,TRUE);
+   opts.optionalB("adaptTempMD","adaptTempTNHC","Send adaptTemp temperature to Nose-Hoover chain thermostat",&adaptTempTNHC,TRUE);
    opts.optional("adaptTempMD", "adaptTempInFile", "File containing restart information for adaptTemp", adaptTempInFile);
+   opts.optionalB("adaptTempInFile", "adaptTempFixedAve", "Fixing the average values from the input restart file", &adaptTempFixedAve, FALSE);
    opts.optional("adaptTempMD", "adaptTempRestartFile", "File for writing adaptTemp restart information", adaptTempRestartFile);
    opts.require("adaptTempRestartFile","adaptTempRestartFreq", "Frequency of writing restart file", &adaptTempRestartFreq,0);
    opts.range("adaptTempRestartFreq",NOT_NEGATIVE);
+   opts.optionalB("adaptTempRestartFile", "adaptTempRestartAppend", "Appending instead of overwriting the restart file", &adaptTempRestartAppend, FALSE);
+   opts.optionalB("adaptTempMD", "adaptTempSep", "Using a separate multiple-bin estimator for each bin", &adaptTempSepOn, FALSE);
+   opts.optional("adaptTempMD", "adaptTempSamplesMin", "Minimal number of samples in a bin to start temperature transitions", &adaptTempSamplesMin, 1000);
+   opts.range("adaptTempSamplesMin", NOT_NEGATIVE);
    opts.optionalB("adaptTempMD", "adaptTempRandom", "Randomly assign a temperature if we step out of range", &adaptTempRandom, FALSE);
+
+   // special atoms
+   opts.optionalB("main", "specAtoms", "Turn on calculations on the special atoms", &specAtomsOn, FALSE);
+   opts.optional("specAtoms", "specAtomsFreq", "Frequency of outputing the end-to-end distance of the special atoms", &specAtomsFreq, 1);
+   opts.range("specAtomsFreq", POSITIVE);
 }
 
 void SimParameters::config_parser_constraints(ParseOptions &opts) {
@@ -2174,6 +2260,22 @@
 
 }
 
+// return the temperature of the active thermostat
+BigReal SimParameters::thermostatTemp(void)
+{
+  if ( langRescaleOn ) {
+    return langRescaleTemp;
+  } else if ( tNHCOn ) {
+    return tNHCTemp;
+  } else if ( langevinOn ) {
+    return langevinTemp;
+  } else if ( rescaleFreq > 0 ) {
+    return rescaleTemp;
+  } else {
+    return initialTemp;
+  }
+}
+
 #ifdef MEM_OPT_VERSION
 //This global var is defined in mainfunc.C
 extern char *gWorkDir;
@@ -2989,9 +3091,15 @@
    }
    // END LA
 
-   if (tCoupleOn && opts.defined("rescaleFreq") )
+   int thstat_cnt = 0;
+   if ( tCoupleOn ) thstat_cnt++;
+   if ( opts.defined("rescaleFreq") ) thstat_cnt++;
+   if ( langRescaleOn ) thstat_cnt++;
+   if ( tNHCOn ) thstat_cnt++;
+
+   if ( thstat_cnt > 1 )
    {
-      NAMD_die("Temperature coupling and temperature rescaling are mutually exclusive");
+      NAMD_die("Temperature coupling, temperature rescaling, Langevin-style velocity rescaling thermostat, and Nose-Hoover chain thermostat are mutually exclusive");
    }
 
    if (globalOn && CkNumPes() > 1)
@@ -3033,16 +3141,29 @@
       maximumMove = 0.75 * pairlistDist/stepsPerCycle;
    }
    if (adaptTempOn) {
-     if (!adaptTempRescale && !adaptTempLangevin) 
-        NAMD_die("Adaptive tempering needs to be coupled to either the Langevin thermostat or velocity rescaling.");
-     if (opts.defined("adaptTempInFile") && (opts.defined("adaptTempTmin") ||
-                                             opts.defined("adaptTempTmax") ||
-                                             adaptTempBins != 0)) 
-        NAMD_die("cannot simultaneously specify adaptTempInFile and any of {adaptTempTmin, adaptTempTmax,adaptTempBins} as these are read from the input file");
+     if (!adaptTempRescale && !adaptTempLangevin && !adaptTempLangRescale && !adaptTempTNHC) 
+        NAMD_die("Adaptive tempering needs to be coupled to one of following: Langevin thermostat, velocity rescaling, Langevin velocity rescaling thermostat, and Nose-Hoover chain thermostat.");
+     if ( !opts.defined("adaptTempInFile") ) {
+       adaptTempInFile[0] = '\0';
+       adaptTempFixedAve = FALSE;
+     }
+     //if (opts.defined("adaptTempInFile") && (opts.defined("adaptTempTmin") ||
+     //                                        opts.defined("adaptTempTmax") ||
+     //                                        adaptTempBins != 0)) 
+     //   NAMD_die("cannot simultaneously specify adaptTempInFile and any of {adaptTempTmin, adaptTempTmax,adaptTempBins} as these are read from the input file");
      if (!opts.defined("adaptTempInFile") && !(opts.defined("adaptTempTmin") &&
                                              opts.defined("adaptTempTmax") &&
                                              adaptTempBins != 0 ))  
         NAMD_die("Need to specify either adaptTempInFile or all of {adaptTempTmin, adaptTempTmax,adaptTempBins} if adaptTempMD is on.");
+     if ( rescaleFreq > 0 )
+       iout << iWARN << "Velocity rescaling does not sample the exact Boltzmann distribution "
+	 "and adaptive tempering will not work properly\n" << endi;
+   }
+   if ( specAtomsOn ) {
+     if ( !opts.defined("specAtomsFreq") && dcdFrequency > 0 ) {
+       // set the default specAtomsFreq to dcdFrequency
+       specAtomsFreq = dcdFrequency;
+     }
    }
    if (langevinOn) {
      if ( ! opts.defined("langevinDamping") ) langevinDamping = 0.0;
@@ -3089,6 +3210,16 @@
   }
    }
 
+    if ( rescaleAdaptiveOn ) {
+      if ( !opts.defined("rescaleAdaptiveFile") ) {
+        strcpy(rescaleAdaptiveFile, "adaptvrescale.dat");
+      }
+    }
+
+   if ( !opts.defined("energyLogFile") ) { // disable energy logging
+     energyLogFreq = 0;
+   }
+
    if (opts.defined("reassignFreq"))
    {
   if (!opts.defined("reassignTemp"))
@@ -3188,6 +3319,8 @@
      else if (reassignFreq > 0)	alchTemp = reassignTemp;
      else if (langevinOn) 	alchTemp = langevinTemp;
      else if (tCoupleOn) 	alchTemp = tCoupleTemp;
+     else if (langRescaleOn)    alchTemp = tNHCTemp;
+     else if (tNHCOn)           alchTemp = tNHCTemp;
      else NAMD_die("Alchemical FEP can be performed only in constant temperature simulations\n");
 
      if (reassignFreq > 0 && reassignIncr != 0)
@@ -3820,6 +3953,16 @@
   tCoupleTemp = 0.0;
    }
 
+   if (!opts.defined("langRescale"))
+   {
+     langRescaleTemp = 0.0;
+   }
+
+   if (!opts.defined("tNHC"))
+   {
+     tNHCTemp = 0.0;
+   }
+
    if (HydrogenBonds)
    {
      if (daCutoffDist > pairlistDist)
@@ -4890,6 +5033,26 @@
       iout << endi;
    }
 
+   if (langRescaleOn)
+   {
+      iout << iINFO << "LANGEVIN-STYLE VELOCITY RESCALING THERMOSTAT ACTIVE\n";
+      iout << iINFO << "    TARGET TEMPERATURE " << langRescaleTemp << " K\n";
+      iout << iINFO << "    INVERSE VISCOSITY  " << langRescaleDt << " fs\n";
+      iout << endi;
+   }
+
+   if (tNHCOn)
+   {
+      iout << iINFO << "NOSE-HOOVER CHAIN THERMOSTAT ACTIVE\n";
+      iout << iINFO << "    TARGET TEMPERATURE " << tNHCTemp << " K\n";
+      iout << iINFO << "    CHAIN LENGTH       " << tNHCLen << "\n";
+      iout << iINFO << "    OSCILLATION PERIOD " << tNHCPeriod << " fs\n";
+      if ( tNHCFileReadMass ) {
+        iout << iINFO << "    READ MASS FROM     " << tNHCFile << "\n";
+      }
+      iout << endi;
+   }
+
    if (minimizeOn)
    {
       iout << iINFO << "OLD STYLE MINIMIZATION ACTIVE\n";
@@ -5088,6 +5251,7 @@
      iout << iINFO << "ADAPTIVE TEMPERING ACTIVE:\n";
      iout << iINFO << "      OUTPUT FREQUENCY: " << adaptTempOutFreq << "\n";
      iout << iINFO << "      TEMPERATURE UPDATE FREQUENCY: " << adaptTempFreq << "\n";
+     iout << iINFO << "      OVERALL INVERSE-TEMPERATURE DISTRIBUTION: W(BETA) ~ BETA^(" << (-adaptTempWeightExp) << ")\n";
      if ( adaptTempLastStep > 0 )
         iout << iINFO << "      ADAPTIVE TEMPERING WILL BE DONE FROM STEP " << adaptTempFirstStep  << " TO " << adaptTempLastStep << "\n";
      else
@@ -5096,12 +5260,21 @@
         iout << iINFO << "      ADAPTIVE TEMPERING COUPLED TO LANGEVIN THERMOSTAT\n";
      if ( adaptTempRescale )
         iout << iINFO << "      ADAPTIVE TEMPERING COUPLED TO VELOCITY RESCALING\n";
+     if (adaptTempInFile[0] != '\0') {
+        iout << iINFO << "      READING RESTART INFORMATION FROM " << adaptTempInFile << " "
+             << (adaptTempFixedAve ? "(FIXED)" : "") << "\n";
+     }
      if (adaptTempRestartFreq > 0) {
         iout << iINFO << "      WRITING RESTART INFORMATION TO " << adaptTempRestartFile << " EVERY " << adaptTempRestartFreq << " STEPS\n";
      }
         
    }
 
+   if (specAtomsOn) {
+     iout << iINFO << "SPECIAL ATOMS ACTIVE:\n";
+     iout << iINFO << "      FREQUENCY: " << specAtomsFreq << "\n";
+   }
+
    if (FMAOn)
    {
      iout << iINFO << "FMA ACTIVE\n";
diff -u -wdB spec_old/SimParameters.h spec_new/SimParameters.h
--- spec_old/SimParameters.h	2015-09-04 17:20:03.000000000 -0500
+++ spec_new/SimParameters.h	2016-08-09 18:39:29.051598414 -0500
@@ -497,8 +497,35 @@
 					//  active
 	BigReal tCoupleTemp;		//  Temperature for temp coupling
 
+	Bool langRescaleOn;		//  Flag TRUE-> Langevin velocity-rescaling thermostat active
+	                   		//  Bussi, Donadio, and Parrinello, JCP 126, 014101 (2007)
+	BigReal langRescaleTemp;	//  Temperature for Langevin velocity-rescaling thermostat
+	BigReal langRescaleDt;	        //  Inverse viscosity in femtoseconds for Langevin velocity-rescaling thermostat
+	int langRescaleFreq;	        //  number of MD steps between two Langevin velocity-rescaling steps
+
+	Bool tNHCOn;			// Flag TRUE-> Nose-Hoover chain thermostat
+	            			// Martyna, Klein, and Tuckerman, JCP 97, 2635 (1992)
+	BigReal tNHCTemp;		// Temperature of the Nose-Hoover chain
+	int tNHCLen;			// Length of the Nose-Hoover chain
+	BigReal tNHCPeriod;		// Oscillation period in femtoseconds of the Nose-Hoover chain
+	char tNHCFile[128];		// Restart file for the NH-chain
+	int tNHCFileFreq;		// Frequency of writing the NH-chain restart file
+	Bool tNHCFileReadMass;		// Read mass from the restart file
+
+	Bool keHistOn;			// Flag TRUE-> Kinetic energy histogram
+	BigReal keHistBin;		// Bin size of the histogram of the kinetic energy
+	char keHistFile[128];		// Histogram file for the kinetic energy 
+	int keHistFileFreq;		// Frequency of writing the kinetic energy histogram file
+
+        char energyLogFile[128];        // Energy log file
+        int energyLogFreq;              // Frequency of writing the energy log file
+
 	int rescaleFreq;		//  Velocity rescale frequency
 	BigReal rescaleTemp;		//  Temperature to rescale to
+	Bool rescaleAdaptiveOn;		//  Adaptively reduce the velocity-rescaling factor
+	BigReal rescaleAdaptiveDedk;	//  Heuristic multiple of the reduction factor
+	char rescaleAdaptiveFile[128];	//  File to save the adaptive veloctiy-rescaling data
+	int rescaleAdaptiveFileFreq;	//  Frequency to save the adaptive veloctiy-rescaling restart file
 
         Bool accelMDOn;                 //  Perform accelerated MD
         Bool accelMDdihe;               //  Apply boost to the dihedral potential
@@ -523,16 +550,29 @@
         BigReal adaptTempTmax;                 //  Upper temperature bound
         BigReal adaptTempAutoDt;               //  Auto jump size. Value determines upper bound, adaotTempDt determines lower bound 
         int adaptTempBins;                     //  Number of bins to store average energy values
+        BigReal adaptTempWindowSize;           //  Window size as a fraction of the inverse temperature range
+        BigReal adaptTempWeightExp;            //  Exponent x as in the inverse-temperature density w(beta) ~ beta^(-x), 0: flat-beta, 1: flat-lnT, 2: flat-T distribution
+        Bool adaptTempMCMove;                  //  Use Monte Carlo to update the temperature
+        BigReal adaptTempMCSize;               //  Magnitude of Monte Carlo temperature moves a faction of the current temperture
         BigReal adaptTempDt;                   //  timestep for adaptTemp updates - only affects Temperature random walk
         BigReal adaptTempCgamma;               //  Cgamma variable for adaptive bin averaging Cgamma = 0 is normal Averaging. 1 > Cgamma >= 0
         Bool adaptTempLangevin;                //  Couple to Langevin Thermostat
         Bool adaptTempRescale;                 //  Couple to Vel. Rescaling
+        Bool adaptTempLangRescale;             //  Couple to Langevin-style velocity rescaling thermostat
+        Bool adaptTempTNHC;                    //  Couple to Nose-Hoover chain thermostat
         char adaptTempInFile[128];             //  Restart information for adaptTemp to read
+        Bool adaptTempFixedAve;                //  Fixing the average values from the input restart file
         char adaptTempRestartFile[128];        //  File to write restart information
         int  adaptTempRestartFreq;             //  Frequency of writing restart output
+        Bool adaptTempRestartAppend;           //  Appending instead of overwriting the restart file
+        Bool adaptTempSepOn;                   //  Using a separate multiple-bin estimator for each bin
+        BigReal adaptTempSamplesMin;           //  Minimal number of samples in a bin to start temperature transitions
         Bool adaptTempRandom;                  //  Do we assign random temperatures when we step out of [Tmin,Tmax]?
         /* End Adaptive Temperature Sampling */
 
+        Bool specAtomsOn;                      //  Turn on calculation on the end-to-end distance
+        int  specAtomsFreq;                    //  Frequency of outputing the end-to-end distance of the special atoms
+
 	int reassignFreq;		//  Velocity reassignment frequency
 	BigReal reassignTemp;		//  Temperature to reassign to
 	BigReal reassignIncr;		//  Added to reassignTemp each time
@@ -921,6 +961,7 @@
         int issetinparseopts(const char* name);
 
        	void readExtendedSystem(const char *filename, Lattice *latptr=0);
+        BigReal thermostatTemp(void);
 private:
         ParseOptions *parseopts;
 
