diff -u -wdB thstat_old/Broadcasts.h thstat_new/Broadcasts.h
--- thstat_old/Broadcasts.h	2015-03-03 11:54:14.000000000 -0600
+++ thstat_new/Broadcasts.h	2016-08-09 16:39:50.303991203 -0500
@@ -39,6 +39,8 @@
   velocityRescaleFactorTag,
   positionRescaleFactorTag,
   tcoupleCoefficientTag,
+  langRescaleFactorTag,
+  tNHCRescaleFactorTag,
   minimizeCoefficientTag,
   momentumCorrectionTag,
 #if USE_BARRIER
@@ -60,6 +62,8 @@
   SimpleBroadcastObject<BigReal> velocityRescaleFactor;
   SimpleBroadcastObject<Tensor> positionRescaleFactor;
   SimpleBroadcastObject<BigReal> tcoupleCoefficient;
+  SimpleBroadcastObject<BigReal> langRescaleFactor;
+  SimpleBroadcastObject<BigReal> tNHCRescaleFactor;
   SimpleBroadcastObject<BigReal> minimizeCoefficient;
   SimpleBroadcastObject<Vector> momentumCorrection;
 #if USE_BARRIER
@@ -77,6 +81,8 @@
     velocityRescaleFactor(velocityRescaleFactorTag, ldObjPtr),
     positionRescaleFactor(positionRescaleFactorTag, ldObjPtr),
     tcoupleCoefficient(tcoupleCoefficientTag, ldObjPtr),
+    langRescaleFactor(langRescaleFactorTag, ldObjPtr),
+    tNHCRescaleFactor(tNHCRescaleFactorTag, ldObjPtr),
     minimizeCoefficient(minimizeCoefficientTag, ldObjPtr),
     momentumCorrection(momentumCorrectionTag, ldObjPtr),
 #if USE_BARRIER
diff -u -wdB thstat_old/CollectionMaster.C thstat_new/CollectionMaster.C
--- thstat_old/CollectionMaster.C	2012-01-28 16:04:27.000000000 -0600
+++ thstat_new/CollectionMaster.C	2016-07-08 20:14:02.400812886 -0500
@@ -43,6 +43,27 @@
 {
 }
 
+void CollectionMaster::receiveHi(int seq)
+{
+  hi.submitData(seq);
+  CollectHiInstance *c = hi.removeReady(seq);
+  if ( c != 0 ) { // collected Hi's from all nodes
+    CthAwaken(hiThread);
+    hiThread = 0;
+  }
+}
+
+void CollectionMaster::enqueueHi(int seq)
+{
+  CollectHiInstance *c = hi.removeReady(seq);
+  if ( c == 0 ) { // lock the thread
+    hiThread = CthSelf();
+    CthSuspend();
+  } else { // already collected Hi's from all nodes
+    c->free(); // empty the spot, but don't actually free the memory
+  }
+}
+
 void CollectionMaster::receivePositions(CollectVectorMsg *msg)
 {
 #ifndef MEM_OPT_VERSION
diff -u -wdB thstat_old/CollectionMaster.ci thstat_new/CollectionMaster.ci
--- thstat_old/CollectionMaster.ci	2011-05-20 15:17:45.000000000 -0500
+++ thstat_new/CollectionMaster.ci	2016-07-08 20:14:02.401812883 -0500
@@ -35,6 +35,7 @@
     entry void startNextRoundOutputForce(double totalT);
     entry void wrapCoorFinished();
     
+    entry void receiveHi(int seq);
   };
 }
 
diff -u -wdB thstat_old/CollectionMaster.h thstat_new/CollectionMaster.h
--- thstat_old/CollectionMaster.h	2015-11-04 11:20:25.000000000 -0600
+++ thstat_new/CollectionMaster.h	2016-08-19 15:31:07.844116809 -0500
@@ -297,6 +297,59 @@
 
   };
 #endif
+
+  class CollectHiInstance
+  {
+  public:
+    CollectHiInstance(void) : seq(-10) { ; }
+    void free() { seq = -10; }
+    int notfree() { return seq != -10; }
+    void reset(int s) {
+      seq = s;
+      remaining = PatchMap::Object()->numNodesWithPatches(); 
+    }
+    int seq;
+    int remaining;
+  };
+
+  class CollectHiSequence
+  {
+  public:
+    ResizeArray<CollectHiInstance *> data;
+
+    void submitData(int seq) {
+      CollectHiInstance **c, **c_e = data.end();
+      for( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      if ( c == c_e ) { // the sequence does not exist
+        // try to find an empty spot in the array
+        for( c = data.begin(); c != c_e && (*c)->notfree(); ++c )
+          ;
+        if ( c == c_e ) { // no empty spot exists, append one
+          data.add(new CollectHiInstance);
+          c = data.end() - 1;
+        }
+        (*c)->reset(seq);
+      }
+      (*c)->remaining--;
+    }
+
+    // return nonzero if all nodes have submitted data for step `seq'
+    CollectHiInstance* removeReady(int seq) {
+      CollectHiInstance *o = 0, **c, **c_e = data.end();
+      for( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      int remaining = 0;
+      if ( c != c_e && (remaining = (*c)->remaining) == 0 )
+        o = *c;
+      return o;
+    }
+  };
+
+public:
+  void receiveHi(int seq);
+  void enqueueHi(int seq);
+
 private:
 
   CollectVectorSequence positions;
@@ -304,6 +357,8 @@
   CollectVectorSequence forces;
   int posTimings, velTimings, forceTimings;
   FILE *dataStreamFile;
+  CollectHiSequence hi;
+  CthThread hiThread;
 
 #ifdef MEM_OPT_VERSION
   int wrapCoorDoneCnt;
diff -u -wdB thstat_old/CollectionMgr.C thstat_new/CollectionMgr.C
--- thstat_old/CollectionMgr.C	2015-09-04 17:20:02.000000000 -0500
+++ thstat_new/CollectionMgr.C	2016-07-08 20:14:02.401812883 -0500
@@ -305,6 +305,16 @@
 }
 #endif
 
+void CollectionMgr::submitHi(int seq) {  
+  CollectHiInstance *c = hi.submitData(seq);
+  if ( c != 0 ) {
+    // all HomePatches on the Node have submitted data
+    CProxy_CollectionMaster cm(master);
+    cm.receiveHi(c->seq);
+    c->free();
+  }
+}
+
 void CollectionMgr::sendDataStream(const char *data) {
   DataStreamMsg *msg = new DataStreamMsg;
   msg->data.resize(strlen(data)+1);
diff -u -wdB thstat_old/CollectionMgr.h thstat_new/CollectionMgr.h
--- thstat_old/CollectionMgr.h	2013-09-06 14:11:36.000000000 -0500
+++ thstat_new/CollectionMgr.h	2016-08-09 16:39:50.303991203 -0500
@@ -138,6 +138,50 @@
     ResizeArray<CollectVectorInstance*> data;
 
   };
+
+
+
+  class CollectHiInstance
+  {
+  public:
+    CollectHiInstance(void) : seq(-10) { ; }
+    void free() { seq = -10; }
+    int notfree() { return ( seq != -10 ); }
+    void reset(int s) {
+      seq = s;
+      remaining = PatchMap::Object()->numHomePatches();
+    }
+    int seq;
+    int remaining;
+  };
+
+  class CollectHiSequence
+  {
+  public:
+    ResizeArray<CollectHiInstance*> data;
+
+    CollectHiInstance* submitData(int seq) {
+      CollectHiInstance **c, **c_e = data.end();
+      for ( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      if ( c == c_e ) { // CollectHiInstance for the sequence `seq' does not exist
+        // try to find an empty spot in the array
+        for ( c = data.begin(); c != c_e && (*c)->notfree(); ++c )
+          ;
+        if ( c == c_e ) { // no empty spot exists, append one
+         data.add(new CollectHiInstance);
+         c = data.end() - 1;
+        }
+        (*c)->reset(seq);
+      }
+      if ( --(*c)->remaining == 0 ) {
+        return *c;
+      } else {
+        return 0;
+      }
+    }
+  };
+
 private:
 
   CkChareID master;
@@ -146,6 +190,9 @@
   CollectVectorSequence velocities;
   CollectVectorSequence forces;
 
+  CollectHiSequence hi;
+public:
+  void submitHi(int);
 };
 
 #endif
diff -u -wdB thstat_old/common.C thstat_new/common.C
--- thstat_old/common.C	2015-02-02 10:14:20.000000000 -0600
+++ thstat_new/common.C	2016-07-22 16:23:22.575103687 -0500
@@ -181,7 +181,7 @@
   int fd;
 
   //  open the file and die if the open fails
-#ifdef WIN32
+#if defined(WIN32) && !defined(__CYGWIN__)
   while ( (fd = _open(fname, O_WRONLY|(append?O_APPEND:O_EXCL)|O_CREAT|O_TEXT,_S_IREAD|_S_IWRITE)) < 0) {
 #else
 #ifdef NAMD_NO_O_EXCL
@@ -223,7 +223,7 @@
 
 // same as close, only does error checking internally
 void NAMD_close(int fd, const char *fname) {
-#ifdef WIN32
+#if defined(WIN32) && !defined(__CYGWIN__)
   while ( _close(fd) ) {
 #else
   while ( close(fd) ) {
diff -u -wdB thstat_old/Controller.C thstat_new/Controller.C
--- thstat_old/Controller.C	2015-12-17 15:22:03.000000000 -0600
+++ thstat_new/Controller.C	2016-09-01 20:39:23.373669098 -0500
@@ -184,6 +184,10 @@
     random->split(0,PatchMap::Object()->numPatches()+1);
 
     rescaleVelocities_sumTemps = 0;  rescaleVelocities_numTemps = 0;
+    rescaleVelocities_sum1     = 0;
+    rescaleVelocities_sumBeta  = 0;
+    rescaleVelocities_sumBeta2 = 0;
+    rescaleVelocities_sumDbde  = 0;
     berendsenPressure_avg = 0; berendsenPressure_count = 0;
     // strainRate tensor is symmetric to avoid rotation
     langevinPiston_strainRate =
@@ -406,15 +410,23 @@
       slowFreq = simParams->nonbondedFrequency;
     if ( step >= numberOfSteps ) slowFreq = nbondFreq = 1;
 
+    langRescaleFactorPrev = 1;
+    tNHCInit();
+    rescaleVelocitiesInit();
+
   if ( scriptTask == SCRIPT_RUN ) {
 
     reassignVelocities(step);  // only for full-step velecities
     rescaleaccelMD(step);
-    adaptTempUpdate(step); // Init adaptive tempering;
 
     receivePressure(step);
     if ( zeroMomentum && dofull && ! (step % slowFreq) )
 						correctMomentum(step);
+    // they shouldn't be called
+    //langRescaleVelocities(step, TRUE);
+    //tNHCRescaleVelocities(step, TRUE);
+    adaptTempUpdate(step); // Init adaptive tempering;
+
     printFepMessage(step);
     printTiMessage(step);
     printDynamicsEnergies(step);
@@ -429,6 +441,11 @@
     rebalanceLoad(step);
 
   }
+    keHistInit();
+    std::ofstream fsEnergyLog;
+    if ( simParams->energyLogFreq > 0 ) {
+      fsEnergyLog.open(simParams->energyLogFile, std::ios_base::app);
+    }
 
     // Handling SIGINT doesn't seem to be working on Lemieux, and it
     // sometimes causes the net-xxx versions of NAMD to segfault on exit, 
@@ -437,19 +454,31 @@
     //  (namd_sighandler_t)my_sigint_handler);
     for ( ++step ; step <= numberOfSteps; ++step )
     {
-        adaptTempUpdate(step);
         rescaleVelocities(step);
 	tcoupleVelocities(step);
+	langRescaleVelocities(step, FALSE);
+	tNHCRescaleVelocities(step, FALSE);
 	berendsenPressure(step);
 	langevinPiston1(step);
         rescaleaccelMD(step);
 	enqueueCollections(step);  // after lattice scaling!
-	receivePressure(step);
+	receivePressure(step); // calling reduction->require()
         if ( zeroMomentum && dofull && ! (step % slowFreq) )
 						correctMomentum(step);
 	langevinPiston2(step);
         reassignVelocities(step);
+	
+        langRescaleVelocities(step, TRUE);
+        tNHCRescaleVelocities(step, TRUE);
+        Bool scaled = adaptTempUpdate(step);
+        keHistUpdate(step);
         printDynamicsEnergies(step);
+        if ( fsEnergyLog.is_open() && step % simParams->energyLogFreq == 0 ) {
+          fsEnergyLog << step << " " << (totalEnergy - kineticEnergy);
+          if ( simParams->adaptTempOn )
+            fsEnergyLog << " " << adaptTempT;
+          fsEnergyLog << std::endl;
+        }
         outputFepEnergy(step);
         outputTiEnergy(step);
         if(traceIsOn()){
@@ -493,7 +522,11 @@
 		}
 	}
 #endif
-	 
+        if ( scaled && (ldbSteps == 1 || LdbCoordinator::Object()->getNumStepsToRun() == 1) ) {
+          // collect Hi's if we're about to rebalance load
+          collection->enqueueHi(step);
+        }
+	//if ( ldbSteps == 1 ) CkPrintf("step %d, before rebalanceLoad(), Controller PE %d/%d, thread %p\n", step, CkMyPe(), CkNumPes(), CthSelf());
         rebalanceLoad(step);
 
 #if  PME_BARRIER
@@ -501,6 +534,12 @@
 #endif
     }
     // signal(SIGINT, oldhandler);
+    
+    adaptTempDone(step);
+    rescaleVelocitiesSave(step);
+    if ( fsEnergyLog.is_open() ) fsEnergyLog.close();
+    tNHCDone(step);
+    keHistDone(step);
 }
 
 
@@ -1016,6 +1055,12 @@
   const int rescaleFreq = simParams->rescaleFreq;
   if ( rescaleFreq > 0 ) {
     rescaleVelocities_sumTemps += temperature;  ++rescaleVelocities_numTemps;
+    BigReal ek = BOLTZMANN * temperature * numDegFreedom;
+    BigReal beta = (numDegFreedom - 2.0) / ek;
+    rescaleVelocities_sum1     += 1;
+    rescaleVelocities_sumBeta  += beta;
+    rescaleVelocities_sumBeta2 += beta * beta;
+    rescaleVelocities_sumDbde  += -beta / ek;
     if ( rescaleVelocities_numTemps == rescaleFreq ) {
       BigReal avgTemp = rescaleVelocities_sumTemps / rescaleVelocities_numTemps;
       BigReal rescaleTemp = simParams->rescaleTemp;
@@ -1024,6 +1069,35 @@
         rescaleTemp = adaptTempT;
       }
       BigReal factor = sqrt(rescaleTemp/avgTemp);
+      if ( simParams->rescaleAdaptiveOn ) {
+        // recompute the velocity-rescaling factor
+        BigReal bref = 1.0 / (BOLTZMANN * rescaleTemp);
+        BigReal dbeta = bref - beta;
+        BigReal dbdk = rescaleVelocities_sumDbde / rescaleVelocities_sum1;
+        BigReal bet = rescaleVelocities_sumBeta / rescaleVelocities_sum1;
+        BigReal bet2 = rescaleVelocities_sumBeta2 / rescaleVelocities_sum1 - bet * bet;
+        BigReal dbde;
+        if ( simParams->rescaleAdaptiveDedk > 0 ) { // heuristic method
+          dbde = dbdk / simParams->rescaleAdaptiveDedk;
+        } else { // exact method
+          if ( rescaleVelocities_numTemps < 10 ) {
+            dbde = dbdk;
+          } else {
+            dbde = dbdk + bet2;
+            if ( dbde > 0.01 * dbdk ) dbde = 0.01 * dbdk;
+          }
+        }
+        BigReal de = dbeta/dbde;
+        BigReal s = (de / ek) * simParams->rescaleFreq / rescaleVelocities_sum1;
+        if ( s > 0.5 ) s = 0.5;
+        else if ( s < -0.5 ) s = -0.5;
+        factor = sqrt(1 + s);
+        if ( fmod(rescaleVelocities_sum1, simParams->rescaleAdaptiveFileFreq) < 0.5 ) {
+          CkPrintf("step %d, factor %g, s %g, bet %g/%g, dbde %g/%g, bet2 %g, delE/K %g, tp %g\n",
+              step, factor, s, bet, bref, dbde, dbdk, bet2, de/ek, temperature); // getchar();
+          rescaleVelocitiesSave(step);
+        }
+      }
       broadcast->velocityRescaleFactor.publish(step,factor);
       //iout << "RESCALING VELOCITIES AT STEP " << step
       //     << " FROM AVERAGE TEMPERATURE OF " << avgTemp
@@ -1033,6 +1107,56 @@
   }
 }
 
+void Controller::rescaleVelocitiesInit(void)
+{
+  if ( numDegFreedom <= 0 )
+    numDegFreedom = Node::Object()->molecule->num_deg_freedom();
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  rescaleVelocitiesLoad();
+}
+
+void Controller::rescaleVelocitiesLoad(void)
+{
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  std::ifstream fs(simParams->rescaleAdaptiveFile);
+  if ( !fs ) return;
+  double cnt, beta, beta2, dbde;
+  fs >> cnt >> beta >> beta2 >> dbde;
+  fs.close();
+  iout << "LOADED ADAPTIVE VELOCITY-RESCALING DATA FROM "
+       << simParams->rescaleAdaptiveFile << ": STEP " << cnt
+       << ", BETA " << beta << ", VAR(BETA) " << beta2
+       << ", BETA'(E) " << dbde << "\n" << endi;
+  beta2 += beta * beta;
+  if ( fmod(cnt, simParams->rescaleFreq) > 0.5 ) {
+    cnt = cnt / simParams->rescaleFreq * simParams->rescaleFreq;
+  }
+  rescaleVelocities_sum1 = cnt;
+  rescaleVelocities_sumBeta = cnt * beta;
+  rescaleVelocities_sumBeta2 = cnt * beta2;
+  rescaleVelocities_sumDbde = cnt * dbde;
+}
+
+void Controller::rescaleVelocitiesSave(int step)
+{
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  if ( rescaleVelocities_sum1 <= 0 )
+    return;
+  NAMD_backup_file(simParams->rescaleAdaptiveFile);
+  ofstream_namd fs(simParams->rescaleAdaptiveFile);
+  if ( !fs ) return;
+  BigReal beta = rescaleVelocities_sumBeta / rescaleVelocities_sum1;
+  BigReal beta2 = rescaleVelocities_sumBeta2 / rescaleVelocities_sum1
+                - beta * beta;
+  BigReal dbde = rescaleVelocities_sumDbde / rescaleVelocities_sum1;
+  char buf[200];
+  sprintf(buf, "%.0f %.10f %.10f %.10f\n", rescaleVelocities_sum1, beta, beta2, dbde);
+  fs << buf;
+}
+
 void Controller::correctMomentum(int step) {
 
     Vector momentum;
@@ -1110,6 +1234,279 @@
   }
 }
 
+// Ref.: Canonical sampling through velocity rescaling
+// Bussi, Donadio, and Parrinello, JCP 126, 014101 (2007)
+void Controller::langRescaleVelocities(int step, Bool isPrev)
+{
+  if ( simParams->langRescaleOn ) {
+    BigReal tp = simParams->langRescaleTemp;
+    // use the temperature from adaptive tempering, if any
+    if ( simParams->adaptTempOn && simParams->adaptTempRescale
+     && (step > simParams->adaptTempFirstStep )
+     && (!(simParams->adaptTempLastStep > 0) || step < simParams->adaptTempLastStep )) {
+      tp = adaptTempT;
+    }
+    tp *= BOLTZMANN;
+
+    BigReal dt = simParams->dt / simParams->langRescaleDt;
+    dt *= 0.5; // doing a half time step, called twice in an MD step
+    BigReal c = exp(-dt);
+
+    // integrate two half steps
+    int dof = numDegFreedom;
+    if ( dof <= 0 ) dof = Node::Object()->molecule->num_deg_freedom();
+    BigReal r = random->gaussian();
+    BigReal r2 = random->chisqr(dof - 1);
+    BigReal ek1 = BOLTZMANN * temperature * dof * 0.5;
+    BigReal ek2 = ek1 + (1 - c) * ((r2 + r * r) * 0.5 * tp - ek1)
+                + 2 * r * sqrt(c * (1 - c) * ek1 * 0.5 * tp);
+    if ( ek2 < 0 ) ek2 = 0;
+    BigReal fac2 = ek2 / ek1;
+    BigReal factor = sqrt( fac2 );
+    if ( !isPrev ) {
+      // combine with the rescaling factor carried from
+      // the second half-step from the previous MD step
+      broadcast->langRescaleFactor.publish(step, factor * langRescaleFactorPrev);
+    } else {
+      // save it for the rescaling in the next step
+      langRescaleFactorPrev = factor;
+    }
+    temperature *= fac2;
+    totalEnergy += kineticEnergy * (fac2 - 1);
+    kineticEnergy *= fac2;
+    kineticEnergyCentered *= fac2;
+  }
+}
+
+void Controller::tNHCInit(void)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int nnhc = simParams->tNHCLen, i;
+  tNHCzeta = new BigReal [nnhc];
+  tNHCmass = new BigReal [nnhc];
+
+  // Note: numDegFreedom has not been set yet
+  int dof = Node::Object()->molecule->num_deg_freedom();
+  BigReal per = simParams->tNHCPeriod / (2 * M_PI);
+  BigReal kT = BOLTZMANN * simParams->tNHCTemp;
+  // reference mass choices, see Appendix B of JCP 97 (4) 2635
+  BigReal mass2 = per * per * kT;
+  BigReal mass1 = mass2 * dof;
+
+  for ( i = 0; i < nnhc; i++ ) {
+    tNHCzeta[i] = 0;
+    tNHCmass[i] = ( i == 0 ) ? mass1 : mass2;
+  }
+
+  // try to load the chain variables, ok if it fails
+  tNHCLoad();
+  CkPrintf("NHC %d, mass1 %g, mass2 %g\n", dof, mass1, mass2);
+  for ( i = 0; i < nnhc; i++ )
+    CkPrintf("NHC %d: zeta %g, mass %g\n", i+1, tNHCzeta[i], tNHCmass[i]);
+  tNHCRescaleFactorPrev = 1.0;
+}
+
+void Controller::tNHCDone(int step)
+{
+  if ( simParams->tNHCOn ) {
+    tNHCSave(step);
+    delete[] tNHCzeta;
+    delete[] tNHCmass;
+  }
+}
+
+// Nose-Hoover chain thermostat
+// Ref.: Nose-Hoover chains: The canonical ensemble via continuous dynamics 
+// Glenn J. Martyna, Michael L. Klein, and Mark Tuckerman, JCP 97 (4) 2635
+void Controller::tNHCRescaleVelocities(int step, Bool isPrev)
+{
+  if ( simParams->tNHCOn ) {
+    BigReal tp = simParams->tNHCTemp;
+    // use the temperature from adaptive tempering, if any
+    if ( simParams->adaptTempOn && simParams->adaptTempRescale
+     && (step > simParams->adaptTempFirstStep )
+     && (!(simParams->adaptTempLastStep > 0) || step < simParams->adaptTempLastStep )) {
+      tp = adaptTempT;
+    }
+    tp *= BOLTZMANN;
+
+    Real dt = simParams->dt * 0.5; // only for half step
+    int dof = numDegFreedom;
+    if ( dof <= 0 ) dof = Node::Object()->molecule->num_deg_freedom();
+    int nnhc = simParams->tNHCLen, i, j, k;
+    BigReal s, GQ, mvv, factor;
+
+    mvv = BOLTZMANN * temperature * dof;
+    for ( j = nnhc - 1; j >= 0; j-- ) {
+      s = ( j == nnhc - 1 ) ? 1 : exp(-tNHCzeta[j+1]*dt*0.25);
+      if ( j == 0 ) {
+        GQ = mvv - dof * tp;
+      } else {
+        GQ = tNHCmass[j-1] * tNHCzeta[j-1] * tNHCzeta[j-1] - tp;
+      }
+      tNHCzeta[j] = (tNHCzeta[j] * s + GQ /tNHCmass[j] * dt*0.5) * s;
+    }
+
+    // velocity rescaling factor
+    factor = exp( -tNHCzeta[0] * dt );
+    if ( !isPrev ) {
+      // combine with the rescaling factor carried from
+      // the second half-step from the previous MD step
+      broadcast->tNHCRescaleFactor.publish(step, factor * tNHCRescaleFactorPrev);
+    } else {
+      tNHCRescaleFactorPrev = factor;
+    }
+
+    BigReal fac2 = factor * factor;
+    temperature *= fac2;
+    totalEnergy += kineticEnergy * (fac2 - 1);
+    kineticEnergy *= fac2;
+    kineticEnergyCentered *= fac2;
+    mvv *= fac2;
+
+    for ( j = 0; j < nnhc; j++ ) {
+      s = ( j == nnhc - 1 ) ? 1 : exp(-tNHCzeta[j+1]*dt*0.25);
+      if ( j == 0 ) {
+        GQ = mvv - dof * tp;
+      } else {
+        GQ = tNHCmass[j-1] * tNHCzeta[j-1] * tNHCzeta[j-1] - tp;
+      }
+      tNHCzeta[j] = (tNHCzeta[j] * s + GQ /tNHCmass[j] * dt*0.5) * s;
+    }
+
+    if ( simParams->tNHCFileFreq > 0 && step % simParams->tNHCFileFreq == 0 )
+      tNHCSave(step);
+  }
+}
+
+void Controller::tNHCSave(int step)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int i, nnhc = simParams->tNHCLen;
+  NAMD_backup_file(simParams->tNHCFile);
+  ofstream_namd fs(simParams->tNHCFile);
+  if ( !fs ) {
+    iout << "Error: cannot write " << simParams->tNHCFile << "\n" << endi;
+    return;
+  }
+  fs << nnhc << " " << step << "\n";
+  for ( i = 0; i < nnhc; i++ )
+    fs << tNHCzeta[i] << " ";
+  fs << "\n";
+  for ( i = 0; i < nnhc; i++ )
+    fs << tNHCmass[i] << " ";
+  fs << "\n";
+}
+
+void Controller::tNHCLoad(void)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int i, nnhc, step;
+  std::ifstream fs(simParams->tNHCFile);
+  if ( !fs ) {
+    iout << "Cannot read " << simParams->tNHCFile << "\n" << endi;
+    return;
+  }
+  fs >> nnhc >> step;
+  if ( nnhc != simParams->tNHCLen ) {
+    iout << "Error: NH-chain length mismatch " << nnhc
+         << " vs. " << simParams->tNHCLen << "\n" << endi;
+    return;
+  }
+  for ( i = 0; i < nnhc; i++ )
+    fs >> tNHCzeta[i];
+
+  if ( simParams->tNHCFileReadMass ) {
+    for ( i = 0; i < nnhc; i++ )
+      fs >> tNHCmass[i];
+  }
+  fs.close();
+}
+
+void Controller::keHistInit(void)
+{
+  if ( !simParams->keHistOn ) return;
+  BigReal keHistTemp = simParams->thermostatTemp();
+  BigReal ke = BOLTZMANN * keHistTemp * numDegFreedom / 2;
+  keHistBinMax = (int) (5.0 * ke / simParams->keHistBin);
+  CkPrintf("keHistInit: temperature %g, dof %d, keHistBinMax %d\n", keHistTemp, numDegFreedom, keHistBinMax);
+  keHist = new BigReal [keHistBinMax];
+  int i;
+  for ( i = 0; i < keHistBinMax; i++ ) keHist[i] = 0;
+  keHistLoad(); // try to load the previous histogram
+}
+
+void Controller::keHistUpdate(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  BigReal ke = BOLTZMANN * temperature * numDegFreedom / 2;
+  if ( simParams->adaptTempOn ) {
+    ke *= simParams->thermostatTemp() / adaptTempT;
+  }
+  int i = (int) ( ke / simParams->keHistBin );
+  if ( i < keHistBinMax ) keHist[i] += 1;
+  if ( step > 0 && step % simParams->keHistFileFreq == 0 ) {
+    keHistSave(step);
+  }
+}
+
+void Controller::keHistSave(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  NAMD_backup_file(simParams->keHistFile);
+  ofstream_namd fs(simParams->keHistFile);
+  if ( !fs ) return;
+  fs << "# " << numDegFreedom << " " << step << "\n";
+  int i;
+  BigReal tot = 0;
+  for ( i = 0; i < keHistBinMax; i++ )
+    tot += keHist[i];
+
+  // normalization of the reference curve
+  BigReal norm = (numDegFreedom % 2) ? 0.5 * log(M_PI) : 0;
+  for ( i = 2 - numDegFreedom % 2; i < numDegFreedom; i += 2 )
+    norm += log(i*0.5);
+  BigReal tp = simParams->thermostatTemp() * BOLTZMANN;
+  BigReal dk = simParams->keHistBin;
+  for ( i = 0; i < keHistBinMax; i++ ) {
+    if ( keHist[i] <= 0 ) continue;
+    double hist = keHist[i] / ( dk * tot );
+    double ke = (i + 0.5) * dk;
+    double histref = exp(log(ke/tp) * (numDegFreedom*0.5-1) -ke/tp - norm) / tp;
+    fs << (i + 0.5) * dk << "\t" << hist << "\t" << histref << "\t" << keHist[i] << "\n";
+  }
+}
+
+void Controller::keHistLoad(void)
+{
+  if ( !simParams->keHistOn ) return;
+  std::ifstream fs(simParams->keHistFile);
+  if ( !fs ) return;
+  std::string buf;
+
+  std::getline(fs, buf);
+  while ( fs.good() ) {
+    double ke, hist1, hist2, hist;
+    std::getline(fs, buf);
+    sscanf(buf.c_str(), "%lf%lf%lf%lf", &ke, &hist1, &hist2, &hist);
+    int i = (int) (ke / simParams->keHistBin);
+    keHist[i] = hist;
+  }
+  fs.close();
+  iout << "Loaded previous histogram from "
+       << simParams->keHistFile << ".\n" << endi;
+}
+
+void Controller::keHistDone(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  keHistSave(step);
+  delete[] keHist;
+}
+
 static char *FORMAT(BigReal X)
 {
   static char tmp_string[25];
@@ -1574,49 +1971,133 @@
 void Controller::adaptTempInit(int step) {
     if (!simParams->adaptTempOn) return;
     iout << iINFO << "INITIALISING ADAPTIVE TEMPERING\n" << endi;
-    adaptTempDtMin = 0;
-    adaptTempDtMax = 0;
-    adaptTempAutoDt = false;
-    if (simParams->adaptTempBins == 0) {
+    adaptTempMCSize = simParams->adaptTempMCSize;
+    adaptTempMCTot = adaptTempMCAcc = 0;
+    adaptTempMCDAcc = adaptTempMCFail = 0;
+    adaptTempDt = simParams->adaptTempDt;
+    adaptTempLangTot = adaptTempLangAcc = 0;
+    adaptTempLangDAcc = adaptTempLangFail = 0;
+    if (simParams->adaptTempInFile[0] != '\0') {
       iout << iINFO << "READING ADAPTIVE TEMPERING RESTART FILE\n" << endi;
       std::ifstream adaptTempRead(simParams->adaptTempInFile);
       if (adaptTempRead) {
+        adaptTempRead.exceptions( std::ios::failbit | std::ios::badbit );
+        try {
+          std::string buf(""); // now read by lines to make extension easier
+          std::stringstream ss;
+          ss.exceptions( std::ios::failbit | std::ios::badbit );
         int readInt;
         BigReal readReal;
-        bool readBool;
-        // step
-        adaptTempRead >> readInt;
-        // Start with min and max temperatures
-        adaptTempRead >> adaptTempT;     // KELVIN
-        adaptTempRead >> adaptTempBetaMin;  // KELVIN
-        adaptTempRead >> adaptTempBetaMax;  // KELVIN
+          std::getline(adaptTempRead, buf);
+          ss.str(buf);
+          ss >> readInt; // step
+          ss >> adaptTempT;     // KELVIN
+          ss >> adaptTempBetaMin;  // KELVIN
+          ss >> adaptTempBetaMax;  // KELVIN
         adaptTempBetaMin = 1./adaptTempBetaMin; // KELVIN^-1
         adaptTempBetaMax = 1./adaptTempBetaMax; // KELVIN^-1
         // In case file is manually edited
-        if (adaptTempBetaMin > adaptTempBetaMax){
-            readReal = adaptTempBetaMax;
-            adaptTempBetaMax = adaptTempBetaMin;
-            adaptTempBetaMin = adaptTempBetaMax;
-        }
-        adaptTempRead >> adaptTempBins;     
-        adaptTempRead >> adaptTempCg;
-        adaptTempRead >> adaptTempDt;
-        adaptTempPotEnergyAveNum = new BigReal[adaptTempBins];
-        adaptTempPotEnergyAveDen = new BigReal[adaptTempBins];
-        adaptTempPotEnergySamples = new int[adaptTempBins];
-        adaptTempPotEnergyVarNum = new BigReal[adaptTempBins];
-        adaptTempPotEnergyVar    = new BigReal[adaptTempBins];
-        adaptTempPotEnergyAve    = new BigReal[adaptTempBins];
-        adaptTempBetaN           = new BigReal[adaptTempBins];
+          if (adaptTempBetaMin > adaptTempBetaMax)
+            std::swap(adaptTempBetaMin, adaptTempBetaMax);
+          ss >> adaptTempBins;     
+          ss >> adaptTempCg;
+          ss >> adaptTempDt;
+          ss.clear(); // clear eof
+          adaptTempPotEnergyAveNum  = new double[adaptTempBins];
+          adaptTempPotEnergyAveDen  = new double[adaptTempBins];
+          adaptTempPotEnergySamples = new long[adaptTempBins];
+          adaptTempPotEnergyVarNum  = new double[adaptTempBins];
+          adaptTempPotEnergyVar     = new double[adaptTempBins];
+          adaptTempPotEnergyAve     = new double[adaptTempBins];
+          adaptTempBetaN            = new BigReal[adaptTempBins + 1];
         adaptTempDBeta = (adaptTempBetaMax - adaptTempBetaMin)/(adaptTempBins);
         for(int j = 0; j < adaptTempBins; ++j) {
-          adaptTempRead >> adaptTempPotEnergyAve[j];
-          adaptTempRead >> adaptTempPotEnergyVar[j];
-          adaptTempRead >> adaptTempPotEnergySamples[j];
-          adaptTempRead >> adaptTempPotEnergyAveNum[j];
-          adaptTempRead >> adaptTempPotEnergyVarNum[j];
-          adaptTempRead >> adaptTempPotEnergyAveDen[j];
+            std::getline(adaptTempRead, buf);
+            ss.str(buf);
+            ss >> readReal; // 1 / T
+            ss >> adaptTempPotEnergyAve[j];
+            ss >> adaptTempPotEnergyVar[j];
+            ss >> adaptTempPotEnergySamples[j];
+            ss >> adaptTempPotEnergyAveNum[j];
+            ss >> adaptTempPotEnergyVarNum[j];
+            ss >> adaptTempPotEnergyAveDen[j];
+            // ss >> readReal; // InvW
+            ss.clear(); // clear eof
+            if ( simParams->adaptTempEmptyData ) {
+              adaptTempPotEnergyVar[j] = 0;
+              adaptTempPotEnergySamples[j] = 0;
+              adaptTempPotEnergyAveNum[j] = 0;
+              adaptTempPotEnergyVarNum[j] = 0;
+              adaptTempPotEnergyAveDen[j] = 0;
+            }
+          }
+          for ( int j = 0; j <= adaptTempBins; j++ )
           adaptTempBetaN[j] = adaptTempBetaMin + j * adaptTempDBeta;
+          adaptTempBinMinus = new int[adaptTempBins];
+          adaptTempBinPlus  = new int[adaptTempBins];
+          // read in data for separate accumulators
+          if ( simParams->adaptTempSepOn ) {
+            char info[256];
+            try {
+              std::getline(adaptTempRead, buf);
+              if ( strncasecmp(buf.c_str(), "SEP BEGIN", 9) != 0 )
+                throw std::ios::failure("");
+            } catch ( const std::ios::failure& e ) {
+              sprintf(info, "No beginning for separator accumulators, file %s\n",
+                  simParams->adaptTempInFile);
+              NAMD_die(info);
+            }
+            adaptTempSepAcc = new AdaptTempSepAcc[adaptTempBins];
+            // loop over each accumulator
+            int i, j, i1, j1;
+            double total;
+            for ( i = 0; i < adaptTempBins; i++ ) {
+              AdaptTempSepAcc *acc = adaptTempSepAcc + i;
+              std::getline(adaptTempRead, buf);
+              if ( 4 != sscanf(buf.c_str(), "%d%d%d%lf", &i1, &adaptTempBinMinus[i], &adaptTempBinPlus[i], &total) ) {
+                sprintf(info, "Broken info for estimator %d, file %s\n%s",
+                    i, simParams->adaptTempInFile, buf.c_str());
+                NAMD_die(info);
+              }
+              acc->init(adaptTempBinMinus[i], adaptTempBinPlus[i]);
+              acc->total = total;
+              for ( j = 0; j < acc->winSize; j++ ) {
+                std::getline(adaptTempRead, buf);
+                if ( 5 != sscanf(buf.c_str(), "%d%lf%lf%lf%lf\n", &j1,
+                      &acc->sumw[j], &acc->ave[j], &acc->var[j], &acc->cnt[j]) ) {
+                  sprintf(info, "Broken member %d/%d for estimator %d, file %s\n%s",
+                      j, acc->winSize, i, simParams->adaptTempInFile, buf.c_str());
+                  NAMD_die(info);
+                }
+                acc->sumE[j] = acc->sumw[j] * acc->ave[j];
+                acc->sumE2[j] = acc->sumw[j] * (acc->var[j] + acc->ave[j] * acc->ave[j]);
+              }
+              std::getline(adaptTempRead, buf); // blank line
+              if ( simParams->adaptTempEmptyData ) acc->empty();
+            }
+            std::getline(adaptTempRead, buf);
+            if ( strncasecmp(buf.c_str(), "SEP END", 7) != 0 ) {
+              sprintf(info, "No ending for separator accumulators, file %s\n",
+                  simParams->adaptTempInFile);
+              NAMD_die(info);
+            }
+          }
+          try { // to read MC or Langevin data
+            std::getline(adaptTempRead, buf);
+            const char *p = buf.c_str();
+            if ( strncasecmp(p, "MC ", 3) == 0 ) {
+              sscanf(p + 3, "%lf%lf%lf%lf%lf", &adaptTempMCSize,
+                  &adaptTempMCTot, &adaptTempMCAcc, &adaptTempMCDAcc, &adaptTempMCFail);
+            } else if ( strncasecmp(p, "LANGEVIN ", 9) == 0 ) {
+              sscanf(p + 9, "%lf%lf%lf%lf", &adaptTempLangTot, &adaptTempLangAcc,
+                  &adaptTempLangDAcc, &adaptTempLangFail);
+            }
+            //CkPrintf("%s\n%g %g %g\n", p, adaptTempMCSize, adaptTempMCTot, adaptTempMCAcc); getchar();
+          } catch ( const std::ios::failure& e ) {
+            iout << "Failed to read MC/Langevin data from " <<  simParams->adaptTempInFile << "\n" << endi;
+          }
+        } catch ( const std::ios::failure& e ) {
+          NAMD_die("Failed to read the ADAPTIVE TEMPERING restart file.\n");
         } 
         adaptTempRead.close();
       }
@@ -1624,23 +2105,18 @@
     } 
     else {
       adaptTempBins = simParams->adaptTempBins;
-      adaptTempPotEnergyAveNum = new BigReal[adaptTempBins];
-      adaptTempPotEnergyAveDen = new BigReal[adaptTempBins];
-      adaptTempPotEnergySamples = new int[adaptTempBins];
-      adaptTempPotEnergyVarNum = new BigReal[adaptTempBins];
-      adaptTempPotEnergyVar    = new BigReal[adaptTempBins];
-      adaptTempPotEnergyAve    = new BigReal[adaptTempBins];
-      adaptTempBetaN           = new BigReal[adaptTempBins];
+      adaptTempPotEnergyAveNum  = new double[adaptTempBins];
+      adaptTempPotEnergyAveDen  = new double[adaptTempBins];
+      adaptTempPotEnergySamples = new long[adaptTempBins];
+      adaptTempPotEnergyVarNum  = new double[adaptTempBins];
+      adaptTempPotEnergyVar     = new double[adaptTempBins];
+      adaptTempPotEnergyAve     = new double[adaptTempBins];
+      adaptTempBetaN            = new BigReal[adaptTempBins + 1];
       adaptTempBetaMax = 1./simParams->adaptTempTmin;
       adaptTempBetaMin = 1./simParams->adaptTempTmax;
       adaptTempCg = simParams->adaptTempCgamma;   
-      adaptTempDt  = simParams->adaptTempDt;
       adaptTempDBeta = (adaptTempBetaMax - adaptTempBetaMin)/(adaptTempBins);
-      adaptTempT = simParams->initialTemp; 
-      if (simParams->langevinOn)
-        adaptTempT = simParams->langevinTemp;
-      else if (simParams->rescaleFreq > 0)
-        adaptTempT = simParams->rescaleTemp;
+      adaptTempT = simParams->thermostatTemp();
       for(int j = 0; j < adaptTempBins; ++j){
           adaptTempPotEnergyAveNum[j] = 0.;
           adaptTempPotEnergyAveDen[j] = 0.;
@@ -1648,16 +2124,38 @@
           adaptTempPotEnergyVarNum[j] = 0.;
           adaptTempPotEnergyVar[j] = 0.;
           adaptTempPotEnergyAve[j] = 0.;
+      }
+      for ( int j = 0; j <= adaptTempBins; j++ )
           adaptTempBetaN[j] = adaptTempBetaMin + j * adaptTempDBeta;
+      // compute the window boundaries
+      adaptTempBinMinus = new int[adaptTempBins];
+      adaptTempBinPlus  = new int[adaptTempBins];
+      for ( int j = 0; j < adaptTempBins; j++ ) {
+        BigReal betaMid = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+        BigReal deltaBeta = betaMid * simParams->adaptTempWindowSize;
+        int deltaBins = (int) (deltaBeta / adaptTempDBeta + 0.5);
+        // adjust the window size such that the window does not exceed the boundaries
+        if ( j - deltaBins < 0 )
+          deltaBins = j;
+        if ( j + deltaBins + 1 > adaptTempBins )
+          deltaBins = adaptTempBins - j - 1;
+        adaptTempBinMinus[j] = j - deltaBins;
+        adaptTempBinPlus[j] = j + deltaBins + 1;
       }
+      // initialize the separate accumulators
+      if ( simParams->adaptTempSepOn ) {
+        adaptTempSepAcc = new AdaptTempSepAcc[adaptTempBins];
+        for ( int i = 0; i < adaptTempBins; ++i )
+          adaptTempSepAcc[i].init(adaptTempBinMinus[i], adaptTempBinPlus[i]);
     }
-    if (simParams->adaptTempAutoDt > 0.0) {
-       adaptTempAutoDt = true;
-       adaptTempDtMin =  simParams->adaptTempAutoDt - 0.01;
-       adaptTempDtMax =  simParams->adaptTempAutoDt + 0.01;
     }
-    adaptTempDTave = 0;
-    adaptTempDTavenum = 0;
+    // wrap adaptTempT within the range
+    BigReal beta = 1.0 / adaptTempT;
+    if ( beta <  adaptTempBetaMin )
+      beta = adaptTempBetaMin * 0.99 + adaptTempBetaMax * 0.01;
+    if ( beta >= adaptTempBetaMax )
+      beta = adaptTempBetaMin * 0.01 + adaptTempBetaMax * 0.99;
+    adaptTempT = 1.0 / beta;
     iout << iINFO << "ADAPTIVE TEMPERING: TEMPERATURE RANGE: [" << 1./adaptTempBetaMax << "," << 1./adaptTempBetaMin << "] KELVIN\n";
     iout << iINFO << "ADAPTIVE TEMPERING: NUMBER OF BINS TO STORE POT. ENERGY: " << adaptTempBins << "\n";
     iout << iINFO << "ADAPTIVE TEMPERING: ADAPTIVE BIN AVERAGING PARAMETER: " << adaptTempCg << "\n";
@@ -1671,12 +2169,35 @@
     }
 }
 
+void Controller::adaptTempDone(int step) {
+    if (!simParams->adaptTempOn) return;
+    adaptTempWriteRestart(step);
+    delete [] adaptTempPotEnergyAveNum;
+    delete [] adaptTempPotEnergyAveDen;
+    delete [] adaptTempPotEnergySamples;
+    delete [] adaptTempPotEnergyVarNum;
+    delete [] adaptTempPotEnergyVar;
+    delete [] adaptTempPotEnergyAve;
+    delete [] adaptTempBetaN;
+    delete [] adaptTempBinMinus;
+    delete [] adaptTempBinPlus;
+    if ( simParams->adaptTempSepOn )
+      delete [] adaptTempSepAcc;
+}
+
 void Controller::adaptTempWriteRestart(int step) {
-    if (simParams->adaptTempOn && !(step%simParams->adaptTempRestartFreq)) {
-        adaptTempRestartFile.seekp(std::ios::beg);        
+    if ( simParams->adaptTempOn ) {
+        char s[1024];
+        if ( !simParams->adaptTempFixedAve ) {
+          // compute the average values
+          for ( int i = 0; i < adaptTempBins; i++ )
+            adaptTempPotEnergyAve[i] = adaptTempGetPEAve(i);
+        }
+        if ( !simParams->adaptTempRestartAppend ) {
+          adaptTempRestartFile.seekbegin();
+        }
         iout << "ADAPTEMP: WRITING RESTART FILE AT STEP " << step << "\n" << endi;
         adaptTempRestartFile << step << " ";
-        // Start with min and max temperatures
         adaptTempRestartFile << adaptTempT<< " ";     // KELVIN
         adaptTempRestartFile << 1./adaptTempBetaMin << " ";  // KELVIN
         adaptTempRestartFile << 1./adaptTempBetaMax << " ";  // KELVIN
@@ -1685,165 +2206,134 @@
         adaptTempRestartFile << adaptTempDt ;
         adaptTempRestartFile << "\n" ;
         for(int j = 0; j < adaptTempBins; ++j) {
-          adaptTempRestartFile << adaptTempPotEnergyAve[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyVar[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergySamples[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyAveNum[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyVarNum[j] << " ";
-          adaptTempRestartFile << adaptTempPotEnergyAveDen[j] << " ";
+          BigReal bet = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+          // use printf for better precision control
+          sprintf(s, "%.12f\t%14.6f\t%14.6f\t%ld\t%22.14e\t%22.14e\t%22.14e\t%10.6f\n",
+              bet, adaptTempPotEnergyAve[j], adaptTempPotEnergyVar[j],
+              adaptTempPotEnergySamples[j], adaptTempPotEnergyAveNum[j],
+              adaptTempPotEnergyVarNum[j], adaptTempPotEnergyAveDen[j],
+              adaptTempGetInvW(1.0 / bet));
+          adaptTempRestartFile << s;
+        }
+        // data for separate accumulators
+        if ( simParams->adaptTempSepOn ) {
+          adaptTempRestartFile << "SEP BEGIN\n";
+          // loop over each accumulator
+          for ( int i = 0; i < adaptTempBins; i++ ) {
+            AdaptTempSepAcc *acc = adaptTempSepAcc + i;
+            acc->trim();
+            sprintf(s, "%d %d %d %.0f\n", i,
+                adaptTempBinMinus[i], adaptTempBinPlus[i], acc->total);
+            adaptTempRestartFile << s;
+            for ( int j = 0; j < acc->winSize; j++ ) {
+              sprintf(s, "%d\t%22.14e\t%22.14e\t%22.14e\t%.0f\n", j,
+                  acc->sumw[j], acc->ave[j], acc->var[j], acc->cnt[j]);
+              adaptTempRestartFile << s;
+            }
           adaptTempRestartFile << "\n";          
         }
+          adaptTempRestartFile << "SEP END\n";
+        }
+        if ( simParams->adaptTempMCMove ) {
+          sprintf(s, "MC %g %.0f %.0f %22.14e %.0f\n", adaptTempMCSize,
+              adaptTempMCTot, adaptTempMCAcc, adaptTempMCDAcc, adaptTempMCFail);
+        } else {
+          sprintf(s, "LANGEVIN %.0f %.0f %22.14e %.0f\n", adaptTempLangTot,
+              adaptTempLangAcc, adaptTempLangDAcc, adaptTempLangFail);
+        }
+        adaptTempRestartFile << s;
         adaptTempRestartFile.flush(); 
     }
 }    
 
-void Controller::adaptTempUpdate(int step, int minimize)
+BigReal Controller::adaptTempGetInvW(BigReal tp)
 {
-    //Beta = 1./T
-    if ( !simParams->adaptTempOn ) return;
-    int j = 0;
-    if (step == simParams->firstTimestep) {
-        adaptTempInit(step);
-        return;
+    return pow(BOLTZMANN * tp, -simParams->adaptTempWeightExp);
     }
-    if ( minimize || (step < simParams->adaptTempFirstStep ) || 
-        ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) return;
-    const int adaptTempOutFreq  = simParams->adaptTempOutFreq;
-    const bool adaptTempDebug  = simParams->adaptTempDebug;
-    //Calculate Current inverse temperature and bin 
-    BigReal adaptTempBeta = 1./adaptTempT;
-    adaptTempBin   = (int)floor((adaptTempBeta - adaptTempBetaMin)/adaptTempDBeta);
 
-    if (adaptTempBin < 0 || adaptTempBin > adaptTempBins)
-        iout << iWARN << " adaptTempBin out of range: adaptTempBin: " << adaptTempBin  
-                               << " adaptTempBeta: " << adaptTempBeta 
-                              << " adaptTempDBeta: " << adaptTempDBeta 
-                               << " betaMin:" << adaptTempBetaMin 
-                               << " betaMax: " << adaptTempBetaMax << "\n";
-    adaptTempPotEnergySamples[adaptTempBin] += 1;
-    BigReal gammaAve = 1.-adaptTempCg/adaptTempPotEnergySamples[adaptTempBin];
-
-    BigReal potentialEnergy;
+BigReal Controller::adaptTempGetPEAve(int i, BigReal def)
+{
+    const BigReal varCntMin = simParams->adaptTempFreq * 10;
     BigReal potEnergyAverage;
-    BigReal potEnergyVariance;
-    potentialEnergy = totalEnergy-kineticEnergy;
-
-    //calculate new bin average and variance using adaptive averaging
-    adaptTempPotEnergyAveNum[adaptTempBin] = adaptTempPotEnergyAveNum[adaptTempBin]*gammaAve + potentialEnergy;
-    adaptTempPotEnergyAveDen[adaptTempBin] = adaptTempPotEnergyAveDen[adaptTempBin]*gammaAve + 1;
-    adaptTempPotEnergyVarNum[adaptTempBin] = adaptTempPotEnergyVarNum[adaptTempBin]*gammaAve + potentialEnergy*potentialEnergy;
-    
-    potEnergyAverage = adaptTempPotEnergyAveNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
-    potEnergyVariance = adaptTempPotEnergyVarNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
-    potEnergyVariance -= potEnergyAverage*potEnergyAverage;
-
-    adaptTempPotEnergyAve[adaptTempBin] = potEnergyAverage;
-    adaptTempPotEnergyVar[adaptTempBin] = potEnergyVariance;
     
-    // Weighted integral of <Delta E^2>_beta dbeta <= Eq 4 of JCP 132 244101
-    // Integrals of Eqs 5 and 6 is done as piecewise assuming <Delta E^2>_beta
-    // is constant for each bin. This is to estimate <E(beta)> where beta \in
-    // (beta_i,beta_{i+1}) using Eq 2 of JCP 132 244101
-    if ( ! ( step % simParams->adaptTempFreq ) ) {
-      // If adaptTempBin not at the edge, calculate improved average:
-      if (adaptTempBin > 0 && adaptTempBin < adaptTempBins-1) {
+    if ( simParams->adaptTempSepOn ) {
+      potEnergyAverage = adaptTempSepAcc[i].iiave(varCntMin, def);
+    } else {
+      int j, w0, w1;
           // Get Averaging Limits:
-          BigReal deltaBeta = 0.04*adaptTempBeta; //0.08 used in paper - make variable
-          BigReal betaPlus;
-          BigReal betaMinus;
-          int     nMinus =0;
-          int     nPlus = 0;
-          if ( adaptTempBeta-adaptTempBetaMin < deltaBeta ) deltaBeta = adaptTempBeta-adaptTempBetaMin;
-          if ( adaptTempBetaMax-adaptTempBeta < deltaBeta ) deltaBeta = adaptTempBetaMax-adaptTempBeta;
-          betaMinus = adaptTempBeta - deltaBeta;
-          betaPlus =  adaptTempBeta + deltaBeta;
-          BigReal betaMinus2 = betaMinus*betaMinus;
-          BigReal betaPlus2  = betaPlus*betaPlus;
-          nMinus = (int)floor((betaMinus-adaptTempBetaMin)/adaptTempDBeta);
-          nPlus  = (int)floor((betaPlus-adaptTempBetaMin)/adaptTempDBeta);
+      int nMinus = adaptTempBinMinus[i];
+      int nPlus  = adaptTempBinPlus[i];
           // Variables for <E(beta)> estimate:
-          BigReal potEnergyAve0 = 0.0;
-          BigReal potEnergyAve1 = 0.0;
+      BigReal den0 = 0.0, den1 = 0.0, ene0 = 0.0, ene1 = 0.0;
           // Integral terms
-          BigReal A0 = 0;
-          BigReal A1 = 0;
-          BigReal A2 = 0;
+      BigReal A0 = 0; // Sum_{from beta_minus to beta_{i+1} }
+                      //   (beta - beta_minus)/(beta_{i+1} - beta_minus) var(E)
+      BigReal A1 = 0; // Sum_{from beta_{i+1} to beta_plus }
+                      //   (beta - beta_plus) /(beta_plus  - beta_{i+1}) var(E)
+      BigReal A2 = 0; // 0.5 * DBeta * var(E) at bin i
           //A0 phi_s integral for beta_minus < beta < beta_{i+1}
-          BigReal betaNp1 = adaptTempBetaN[adaptTempBin+1]; 
-          BigReal DeltaE2Ave;
-          BigReal DeltaE2AveSum = 0;
-          BigReal betaj;
-          for (j = nMinus+1; j <= adaptTempBin; ++j) {
-              potEnergyAve0 += adaptTempPotEnergyAve[j]; 
-              DeltaE2Ave = adaptTempPotEnergyVar[j];
-              DeltaE2AveSum += DeltaE2Ave;
-              A0 += j*DeltaE2Ave;
-          }
-          A0 *= adaptTempDBeta;
-          A0 += (adaptTempBetaMin+0.5*adaptTempDBeta-betaMinus)*DeltaE2AveSum;
-          A0 *= adaptTempDBeta;
-          betaj = adaptTempBetaN[nMinus+1]-betaMinus; 
-          betaj *= betaj;
-          A0 += 0.5*betaj*adaptTempPotEnergyVar[nMinus];
-          A0 /= (betaNp1-betaMinus);
 
-          //A1 phi_s integral for beta_{i+1} < beta < beta_plus
-          DeltaE2AveSum = 0;
-          for (j = adaptTempBin+1; j < nPlus; j++) {
-              potEnergyAve1 += adaptTempPotEnergyAve[j];
-              DeltaE2Ave = adaptTempPotEnergyVar[j];
-              DeltaE2AveSum += DeltaE2Ave;
-              A1 += j*DeltaE2Ave;
+      // compute the default variance for lack of data
+      BigReal denMax = 0, defVar = 0;
+      for ( j = nMinus; j < nPlus; j++ ) {
+        if ( adaptTempPotEnergyAveDen[j] > denMax ) {
+          denMax = adaptTempPotEnergyAveDen[j];
+          defVar = adaptTempPotEnergyVar[j];
           }
-          A1 *= adaptTempDBeta;   
-          A1 += (adaptTempBetaMin+0.5*adaptTempDBeta-betaPlus)*DeltaE2AveSum;
-          A1 *= adaptTempDBeta;
-          if ( nPlus < adaptTempBins ) {
-            betaj = betaPlus-adaptTempBetaN[nPlus];
-            betaj *= betaj;
-            A1 -= 0.5*betaj*adaptTempPotEnergyVar[nPlus];
           }
-          A1 /= (betaPlus-betaNp1);
+      if ( defVar <= 0 ) defVar = 1.0;
+
+      BigReal var;
+      for ( j = nMinus; j <= i; j++ ) {
+        den0 += adaptTempPotEnergyAveDen[j];
+        ene0 += adaptTempPotEnergyAveNum[j];
+        var = (adaptTempPotEnergySamples[j] > varCntMin) ? adaptTempPotEnergyVar[j] : defVar;
+        A0 += var * (j - nMinus + 0.5);
+      }
+      w0 = i + 1 - nMinus;
+      den0 /= w0;
+      ene0 /= w0;
+      A0 /= w0;
 
           //A2 phi_t integral for beta_i
-          A2 = 0.5*adaptTempDBeta*potEnergyVariance;
+      var = (adaptTempPotEnergySamples[i] > varCntMin) ? adaptTempPotEnergyVar[i] : defVar;
+      A2 = 0.5 * var;
 
-          // Now calculate a+ and a-
-          DeltaE2Ave = A0-A1;
-          BigReal aplus = 0;
-          BigReal aminus = 0;
-          if (DeltaE2Ave != 0) {
-            aplus = (A0-A2)/(A0-A1);
-            if (aplus < 0) {
-                    aplus = 0;
-            }
-            if (aplus > 1)  {
-                    aplus = 1;
-            }
-            aminus = 1-aplus;
-            potEnergyAve0 *= adaptTempDBeta;
-            potEnergyAve0 += adaptTempPotEnergyAve[nMinus]*(adaptTempBetaN[nMinus+1]-betaMinus);
-            potEnergyAve0 /= (betaNp1-betaMinus);
-            potEnergyAve1 *= adaptTempDBeta;
-            if ( nPlus < adaptTempBins ) {
-                potEnergyAve1 += adaptTempPotEnergyAve[nPlus]*(betaPlus-adaptTempBetaN[nPlus]);
+      //A1 phi_s integral for beta_{i+1} < beta < beta_plus
+      for ( j = i + 1; j < nPlus; j++ ) {
+        den1 += adaptTempPotEnergyAveDen[j];
+        ene1 += adaptTempPotEnergyAveNum[j];
+        var = (adaptTempPotEnergySamples[j] > varCntMin) ? adaptTempPotEnergyVar[j] : defVar;
+        A1 += var * (j - nPlus + 0.5);
             }
-            potEnergyAve1 /= (betaPlus-betaNp1);
-            potEnergyAverage = aminus*potEnergyAve0;
-            potEnergyAverage += aplus*potEnergyAve1;
+      w1 = nPlus - i - 1;
+      if ( w1 > 0 ) {
+        den1 /= w1;
+        ene1 /= w1;
+        A1 /= w1;
           }
+
+      if ( den0 + den1 <= 0 ) {
+        potEnergyAverage = def;
+      } else {
+        // Now calculate a+ and a-
+        BigReal aplus = ( den0 + den1 > 0 ) ? (A0 - A2) / (A0 - A1) : 0;
+        if ( aplus < 0 ) aplus = 0;
+        if ( aplus > 1 ) aplus = 1;
+        BigReal aminus = 1 - aplus;
+        potEnergyAverage = ( aminus * ene0 + aplus * ene1 )
+                         / ( aminus * den0 + aplus * den1 );
           if (simParams->adaptTempDebug) {
        iout << "ADAPTEMP DEBUG:"  << "\n"
-            << "     adaptTempBin:    " << adaptTempBin << "\n"
-            << "     Samples:   " << adaptTempPotEnergySamples[adaptTempBin] << "\n"
-            << "     adaptTempBeta:   " << adaptTempBeta << "\n" 
+               << "     adaptTempBin:    " << i << "\n"
+               << "     Samples:   " << adaptTempPotEnergySamples[i] << "\n"
+               << "     potentialEnergeAverage:  " << potEnergyAverage << "\n"
             << "     adaptTemp:   " << adaptTempT<< "\n"
             << "     betaMin:   " << adaptTempBetaMin << "\n"
             << "     betaMax:   " << adaptTempBetaMax << "\n"
-            << "     gammaAve:  " << gammaAve << "\n"
-            << "     deltaBeta: " << deltaBeta << "\n"
-            << "     betaMinus: " << betaMinus << "\n"
-            << "     betaPlus:  " << betaPlus << "\n"
+               << "     deltaBeta: " << (i - nMinus) * adaptTempDBeta << "\n"
+               << "     betaMinus: " << adaptTempBetaN[nMinus] << "\n"
+               << "     betaPlus:  " << adaptTempBetaN[nPlus] << "\n"
             << "     nMinus:    " << nMinus << "\n"
             << "     nPlus:     " << nPlus << "\n"
             << "     A0:        " << A0 << "\n"
@@ -1851,147 +2341,301 @@
             << "     A2:        " << A2 << "\n"
             << "     a+:        " << aplus << "\n"
             << "     a-:        " << aminus << "\n"
+               << "     aveEner:   " << potEnergyAverage << "\n"
+               << "     aveEne0:   " << ene0 / (den0 + 1e-16) << "\n"
+               << "     aveEne1:   " << ene1 / (den1 + 1e-16) << "\n"
+               << "     den0:      " << den0 << "\n"
+               << "     den1:      " << den1 << "\n"
             << endi;
           }
       }
-      else {
-          if (simParams->adaptTempDebug) {
-       iout << "ADAPTEMP DEBUG:"  << "\n"
-            << "     adaptTempBin:    " << adaptTempBin << "\n"
-            << "     Samples:   " << adaptTempPotEnergySamples[adaptTempBin] << "\n"
-            << "     adaptTempBeta:   " << adaptTempBeta << "\n" 
-            << "     adaptTemp:   " << adaptTempT<< "\n"
-            << "     betaMin:   " << adaptTempBetaMin << "\n"
-            << "     betaMax:   " << adaptTempBetaMax << "\n"
-            << "     gammaAve:  " << gammaAve << "\n"
-            << "     deltaBeta:  N/A\n"
-            << "     betaMinus:  N/A\n"
-            << "     betaPlus:   N/A\n"
-            << "     nMinus:     N/A\n"
-            << "     nPlus:      N/A\n"
-            << "     A0:         N/A\n"
-            << "     A1:         N/A\n"
-            << "     A2:         N/A\n"
-            << "     a+:         N/A\n"
-            << "     a-:         N/A\n"
-            << endi;
           }
+    return potEnergyAverage;
       }
       
-      //dT is new temperature
-      BigReal dT = ((potentialEnergy-potEnergyAverage)/BOLTZMANN+adaptTempT)*adaptTempDt;
-      dT += random->gaussian()*sqrt(2.*adaptTempDt)*adaptTempT;
-      dT += adaptTempT;
+// return Integral { beta to nbeta } E(beta) d beta = Z(beta) - Z(nbeta)
+BigReal Controller::adaptTempGetIntE(BigReal beta, int i, BigReal nbeta, int ni)
+{
+    double delta = 0, epave = 0, beta_n;
+    int j, sgn = ( i <= ni ) ? 1 : -1;
+    for ( j = i; ; j += sgn ) {
+      if ( !simParams->adaptTempFixedAve ) // recompute the average energy
+        adaptTempPotEnergyAve[j] = epave = adaptTempGetPEAve(j, epave);
+      beta_n = ( j == ni ) ? nbeta : adaptTempBetaN[j + (sgn > 0)];
+      delta += adaptTempPotEnergyAve[j] * (beta_n - beta);
+      beta = beta_n;
+      if ( j == ni ) break;
+    }
+    return delta / BOLTZMANN;
+}
       
-     // Check if dT in [adaptTempTmin,adaptTempTmax]. If not try simpler estimate of mean
-     // This helps sampling with poor statistics in the bins surrounding adaptTempBin.
-      if ( dT > 1./adaptTempBetaMin || dT  < 1./adaptTempBetaMax ) {
-        dT = ((potentialEnergy-adaptTempPotEnergyAve[adaptTempBin])/BOLTZMANN+adaptTempT)*adaptTempDt;
-        dT += random->gaussian()*sqrt(2.*adaptTempDt)*adaptTempT;
-        dT += adaptTempT;
-        // Check again, if not then keep original adaptTempTor assign random.
-        if ( dT > 1./adaptTempBetaMin ) {
-          if (!simParams->adaptTempRandom) {             
-             //iout << iWARN << "ADAPTEMP: " << step << " T= " << dT 
-             //     << " K higher than adaptTempTmax."
-             //     << " Keeping temperature at " 
-             //     << adaptTempT<< "\n"<< endi;             
-             dT = adaptTempT;
+BigReal Controller::adaptTempMCMove(BigReal tp, BigReal ep)
+{
+    double kB = BOLTZMANN, x = simParams->adaptTempWeightExp;
+    double beta = 1./tp, nbeta, r, delta, nepave;
+    int i, ni, acc = 0;
+    r = random->gaussian();
+    nbeta = beta * exp(adaptTempMCSize * r); // evenly change ln(beta)
+    i  = (int) ( (beta  - adaptTempBetaMin) / adaptTempDBeta );
+    ni = (int) ( (nbeta - adaptTempBetaMin) / adaptTempDBeta );
+    if ( nbeta >= adaptTempBetaMin && ni < adaptTempBins ) {
+      delta = adaptTempGetIntE(beta, i, nbeta, ni);
+      nepave = adaptTempPotEnergyAve[ni];
+      delta = delta - ep * (nbeta - beta)/kB + (x - 1) * log(beta/nbeta);
+      //CkPrintf("delta %g cf %g, beta %g, %g, ep %g, %g, bin %d, %d\n", delta,
+      //    ((adaptTempPotEnergyAve[i]+adaptTempPotEnergyAve[ni])/2 - ep) * (nbeta - beta) / kB,
+      //    beta, nbeta, ep, nepave, i, ni); // getchar();
+      acc = ( delta > 0 || random->uniform() < exp(delta) );
+      if ( acc ) { // for d(acc. ratio)/d(ln beta)
+        if ( delta < 0 )
+          adaptTempMCDAcc += -r * ((ep - nepave)*(nbeta/kB) + x - 1);
+        double mbeta = beta * exp((adaptTempMCSize + simParams->adaptTempMCSizeInc) * r);
+        if ( mbeta < adaptTempBetaMin || mbeta >= adaptTempBetaMax )
+          adaptTempMCFail += 1;
           }
-          else {             
-             //iout << iWARN << "ADAPTEMP: " << step << " T= " << dT 
-             //     << " K higher than adaptTempTmax."
-             //     << " Assigning random temperature in range\n" << endi;
-             dT = adaptTempBetaMin +  random->uniform()*(adaptTempBetaMax-adaptTempBetaMin);             
-             dT = 1./dT;
           }
+    adaptTempMCTot += 1;
+    adaptTempMCAcc += acc;
+    // adjust the MC move size automatically
+    if ( simParams->adaptTempMCAutoAR > 0 && adaptTempMCTot > 100 ) {
+      double dacc = adaptTempMCDAcc;
+      if ( dacc > 0 ) dacc = 0;
+      if ( adaptTempMCFail > 5 ) { // out-of-boundary rejections
+        dacc -= adaptTempMCFail / simParams->adaptTempMCSizeInc;
+      } else { // approximation
+        dacc -= 2 * adaptTempMCAcc;
         } 
-        else if ( dT  < 1./adaptTempBetaMax ) {
-          if (!simParams->adaptTempRandom) {            
-            //iout << iWARN << "ADAPTEMP: " << step << " T= "<< dT 
-            //     << " K lower than adaptTempTmin."
-            //     << " Keeping temperature at " << adaptTempT<< "\n" << endi; 
-            dT = adaptTempT;
+      double del = ( simParams->adaptTempMCAutoAR - acc ) / dacc;
+      if ( del >  0.5 * adaptTempMCSize ) del =  0.5 * adaptTempMCSize;
+      if ( del < -0.5 * adaptTempMCSize ) del = -0.5 * adaptTempMCSize;
+      adaptTempMCSize += del;
           }
-          else {
-            //iout << iWARN << "ADAPTEMP: " << step << " T= "<< dT 
-            //     << " K lower than adaptTempTmin."
-            //     << " Assigning random temperature in range\n" << endi;
-            dT = adaptTempBetaMin +  random->uniform()*(adaptTempBetaMax-adaptTempBetaMin);
-            dT = 1./dT;
+    return acc ? 1.0/nbeta : tp;
           }
+
+BigReal Controller::adaptTempLangevin(BigReal tp, BigReal ep)
+{
+    double kB = BOLTZMANN, x = simParams->adaptTempWeightExp;
+    double beta = 1./tp, Beta = beta/kB;
+    int i = (int) ( (beta - adaptTempBetaMin) / adaptTempDBeta );
+    double epave = adaptTempGetPEAve(i, 0);
+    double r = random->gaussian();
+    double dt = adaptTempDt, a = sqrt(2. * dt);
+    double de = ep - epave + x / Beta;
+    double dtp = dt * de / kB + r * a * tp;
+    double ntp = tp + dtp;
+    double nbeta = 1./ntp, nBeta = nbeta/kB;
+    int ni = (int) ( (nbeta - adaptTempBetaMin) / adaptTempDBeta );
+    // use Monte Carlo to accept the new temperature
+    int acc = 0;
+    if ( nbeta >= adaptTempBetaMin && ni < adaptTempBins ) {
+      double delta = adaptTempGetIntE(beta, i, nbeta, ni);
+      double nepave = adaptTempPotEnergyAve[ni];
+      double nde = ep - nepave + x / nBeta;
+      double nr = (-dtp/ntp - dt*nde*nBeta) / a;
+      delta = (Beta - nBeta) * ep + delta
+            + (x - 3) * log(Beta/nBeta) + (r*r - nr*nr)/2;
+      acc = ( delta > 0 || random->uniform() < exp(delta) );
+      //CkPrintf("acc %d, delta %g, beta %g, %g, ep %g, i %d, %d\n", acc, delta, beta, nbeta, ep, i, ni);
+      if ( acc ) { // for d(acc. ratio)/da
+        if ( delta < 0 ) {
+          BigReal dnB = -nBeta*nBeta/Beta * (r + Beta*de*a); // d(nBeta)/da
+          BigReal nvar = adaptTempPotEnergyVar[ adaptTempPotEnergySamples[ni] > 0 ? ni : i ]; // -E'(Beta)
+          BigReal dnr = -(nBeta*nde + nr/a) + (1./Beta/a - (ep - nepave + nBeta*nvar)*a/2) * dnB; // d(nr)/da
+          adaptTempLangDAcc += -((nde - 3./nBeta) * dnB + nr * dnr); // d(delta)/da
         }
-        else if (adaptTempAutoDt) {
-          //update temperature step size counter
-          //FOR "TRUE" ADAPTIVE TEMPERING 
-          BigReal adaptTempTdiff = fabs(dT-adaptTempT);
-          if (adaptTempTdiff > 0) {
-            adaptTempDTave += adaptTempTdiff; 
-            adaptTempDTavenum++;
-//            iout << "ADAPTEMP: adapTempTdiff = " << adaptTempTdiff << "\n";
+        double ma = a + simParams->adaptTempMCSizeInc;
+        double mbeta = 1./(tp + (ma*ma/2) * de/kB + r * ma * tp);
+        if ( mbeta < adaptTempBetaMin || mbeta >= adaptTempBetaMax )
+          adaptTempLangFail += 1;
           }
-          if(adaptTempDTavenum == 100){
-                BigReal Frac;
-                adaptTempDTave /= adaptTempDTavenum;
-                Frac = 1./adaptTempBetaMin-1./adaptTempBetaMax;
-                Frac = adaptTempDTave/Frac;
-                //if average temperature jump is > 3% of temperature range,
-                //modify jump size to match 3%
-                iout << "ADAPTEMP: " << step << " FRAC " << Frac << "\n"; 
-                if (Frac > adaptTempDtMax || Frac < adaptTempDtMin) {
-                    Frac = adaptTempDtMax/Frac;
-                    iout << "ADAPTEMP: Updating adaptTempDt to ";
-                    adaptTempDt *= Frac;
-                    iout << adaptTempDt << "\n" << endi;
                 }
-                adaptTempDTave = 0;
-                adaptTempDTavenum = 0;
+    adaptTempLangTot += 1;
+    adaptTempLangAcc += acc;
+    // adjust the Langevin integration time automatically
+    if ( simParams->adaptTempDtAutoAR > 0 && adaptTempLangTot > 100 ) {
+      double dacc = adaptTempLangDAcc;
+      if ( dacc > 0 ) dacc = 0;
+      if ( adaptTempLangFail > 5 ) { // out-of-boundary rejections
+        dacc -= adaptTempLangFail / simParams->adaptTempMCSizeInc;
+      } else { // approximation
+        dacc -= 2 * adaptTempLangAcc;
           }
+      double del = ( simParams->adaptTempDtAutoAR - acc ) / dacc;
+      if ( del >  0.5 * a ) del =  0.5 * a;
+      if ( del < -0.5 * a ) del = -0.5 * a;
+      adaptTempDt = (a + del) * (a + del) / 2;
         }
+    return acc ? ntp : tp;
       }
-      else if (adaptTempAutoDt) {
-          //update temperature step size counter
-          // FOR "TRUE" ADAPTIVE TEMPERING
-          BigReal adaptTempTdiff = fabs(dT-adaptTempT);
-          if (adaptTempTdiff > 0) {
-            adaptTempDTave += adaptTempTdiff; 
-            adaptTempDTavenum++;
-//            iout << "ADAPTEMP: adapTempTdiff = " << adaptTempTdiff << "\n";
+
+Bool Controller::adaptTempUpdate(int step, int minimize)
+{
+    Bool scaled = FALSE;
+    //Beta = 1./T
+    if ( !simParams->adaptTempOn ) return scaled;
+    int j = 0;
+    if (step == simParams->firstTimestep) {
+        adaptTempInit(step);
+        return scaled;
           }
-          if(adaptTempDTavenum == 100){
-                BigReal Frac;
-                adaptTempDTave /= adaptTempDTavenum;
-                Frac = 1./adaptTempBetaMin-1./adaptTempBetaMax;
-                Frac = adaptTempDTave/Frac;
-                //if average temperature jump is > 3% of temperature range,
-                //modify jump size to match 3%
-                iout << "ADAPTEMP: " << step << " FRAC " << Frac << "\n"; 
-                if (Frac > adaptTempDtMax || Frac < adaptTempDtMin) {
-                    Frac = adaptTempDtMax/Frac;
-                    iout << "ADAPTEMP: Updating adaptTempDt to ";
-                    adaptTempDt *= Frac;
-                    iout << adaptTempDt << "\n" << endi;
+    if ( minimize || (step < simParams->adaptTempFirstStep ) || 
+        ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) return scaled;
+    //Calculate Current inverse temperature and bin 
+    BigReal adaptTempBeta = 1./adaptTempT;
+    adaptTempBin = (int) ( (adaptTempBeta - adaptTempBetaMin) / adaptTempDBeta );
+
+    if ( adaptTempBeta < adaptTempBetaMin || adaptTempBin >= adaptTempBins )
+        iout << iWARN << " adaptTempBin out of range: adaptTempBin: " << adaptTempBin  
+                      << " adaptTempBeta: " << adaptTempBeta 
+                      << " adaptTempDBeta: " << adaptTempDBeta 
+                      << " betaMin:" << adaptTempBetaMin 
+                      << " betaMax: " << adaptTempBetaMax << "\n";
+    if ( adaptTempBin < 0 ) {
+      adaptTempBin = 0;
+    } else if ( adaptTempBin >= adaptTempBins ) {
+      adaptTempBin = adaptTempBins - 1;
                 }
-                adaptTempDTave = 0;
-                adaptTempDTavenum = 0;
+    adaptTempPotEnergySamples[adaptTempBin] += 1;
+    BigReal gammaAve = 1.-adaptTempCg/adaptTempPotEnergySamples[adaptTempBin];
+    if ( gammaAve < 0 ) gammaAve = 0;
+
+    BigReal potentialEnergy;
+    BigReal potEnergyAverage;
+    BigReal potEnergyVariance;
 
+    // recompute the potential energy
+    BigReal bondEnergy = reduction->item(REDUCTION_BOND_ENERGY);
+    BigReal angleEnergy = reduction->item(REDUCTION_ANGLE_ENERGY);
+    BigReal dihedralEnergy = reduction->item(REDUCTION_DIHEDRAL_ENERGY);
+    BigReal improperEnergy = reduction->item(REDUCTION_IMPROPER_ENERGY);
+    BigReal crosstermEnergy = reduction->item(REDUCTION_CROSSTERM_ENERGY);
+    BigReal boundaryEnergy = reduction->item(REDUCTION_BC_ENERGY);
+    BigReal miscEnergy = reduction->item(REDUCTION_MISC_ENERGY);
+    if ( step % nbondFreq == 0 ) {
+      electEnergy = reduction->item(REDUCTION_ELECT_ENERGY);
+      ljEnergy = reduction->item(REDUCTION_LJ_ENERGY);
+      BigReal volume = state->lattice.volume();
+      if (simParams->LJcorrection && volume) {
+        // Apply tail correction to energy
+        ljEnergy += Node::Object()->molecule->tail_corr_ener / volume;
+      }
+      groLJEnergy = reduction->item(REDUCTION_GRO_LJ_ENERGY);
+      groGaussEnergy = reduction->item(REDUCTION_GRO_GAUSS_ENERGY);
+      goNativeEnergy = reduction->item(REDUCTION_GO_NATIVE_ENERGY);
+      goNonnativeEnergy = reduction->item(REDUCTION_GO_NONNATIVE_ENERGY);
+      goTotalEnergy = goNativeEnergy + goNonnativeEnergy;
+    }
+    if ( step % slowFreq == 0 ) {
+      electEnergySlow = reduction->item(REDUCTION_ELECT_ENERGY_SLOW);
           }
+    potentialEnergy = bondEnergy + angleEnergy + dihedralEnergy
+	+ improperEnergy + electEnergy + electEnergySlow + ljEnergy
+        + crosstermEnergy + boundaryEnergy + miscEnergy
+        + goTotalEnergy + groLJEnergy + groGaussEnergy;
+    totalEnergy = potentialEnergy + kineticEnergy;
           
+    BigReal invw = adaptTempGetInvW(adaptTempT);
+    //calculate new bin average and variance using adaptive averaging
+    adaptTempPotEnergyAveNum[adaptTempBin] = adaptTempPotEnergyAveNum[adaptTempBin]*gammaAve + potentialEnergy * invw;
+    adaptTempPotEnergyAveDen[adaptTempBin] = adaptTempPotEnergyAveDen[adaptTempBin]*gammaAve + invw;
+    adaptTempPotEnergyVarNum[adaptTempBin] = adaptTempPotEnergyVarNum[adaptTempBin]*gammaAve + potentialEnergy*potentialEnergy * invw;
+    
+    potEnergyAverage = adaptTempPotEnergyAveNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
+    potEnergyVariance = adaptTempPotEnergyVarNum[adaptTempBin]/adaptTempPotEnergyAveDen[adaptTempBin];
+    potEnergyVariance -= potEnergyAverage*potEnergyAverage;
+
+    if ( !simParams->adaptTempFixedAve )
+      adaptTempPotEnergyAve[adaptTempBin] = potEnergyAverage;
+    adaptTempPotEnergyVar[adaptTempBin] = potEnergyVariance;
+
+    if ( simParams->adaptTempSepOn ) { // update separate accumulators
+      for ( j = adaptTempBin; j >= 0; j-- ) { // search downward
+        if ( adaptTempBinPlus[j] <= adaptTempBin ) break;
+        adaptTempSepAcc[j].add(adaptTempBin, potentialEnergy, invw, adaptTempCg);
+      }
+      for ( j = adaptTempBin + 1; j < adaptTempBins; j++ ) { // search upward
+        if ( adaptTempBinMinus[j] > adaptTempBin ) break;
+        adaptTempSepAcc[j].add(adaptTempBin, potentialEnergy, invw, adaptTempCg);
+      }
       }
       
+    // Weighted integral of <Delta E^2>_beta dbeta <= Eq 4 of JCP 132 244101
+    // Integrals of Eqs 5 and 6 is done as piecewise assuming <Delta E^2>_beta
+    // is constant for each bin. This is to estimate <E(beta)> where beta \in
+    // (beta_i,beta_{i+1}) using Eq 2 of JCP 132 244101
+    if ( ! ( step % simParams->adaptTempFreq ) ) {
+      BigReal dT; // dT is the new temperature
+      if ( adaptTempPotEnergySamples[adaptTempBin] <= simParams->adaptTempSamplesMin ) {
+        // avoid making temperature transitions without enough samples
+        dT = adaptTempT;
+      } else if ( simParams->adaptTempMCMove ) { // Monte Carlo temperature update
+        dT = adaptTempMCMove(adaptTempT, potentialEnergy);
+      } else { // Langevin equation temperature update
+        dT = adaptTempLangevin(adaptTempT, potentialEnergy);
+      }
+
+      BigReal tScale = dT / adaptTempT;
+      BigReal vScale = sqrt(tScale);
+      // for velocity-rescaling-based thermostats,
+      // carry the velocity-rescaling factor to the next step
+      if ( simParams->langRescaleOn ) {
+        langRescaleFactorPrev *= vScale;
+      } else if ( simParams->tNHCOn ) {
+        tNHCRescaleFactorPrev *= vScale;
+      }
       adaptTempT = dT; 
       broadcast->adaptTemperature.publish(step,adaptTempT);
+      scaled = TRUE;
+      // temperature is to be used for the Langevin velocity-rescaling
+      // and NH-chain thermostats, so it needs to be updated.
+      temperature *= tScale;
+      totalEnergy += kineticEnergy * (tScale - 1);
+      kineticEnergy *= tScale;
+      kineticEnergyCentered *= tScale;
     }
+    if ( step % simParams->adaptTempRestartFreq == 0 )
     adaptTempWriteRestart(step);
-    if ( ! (step % adaptTempOutFreq) ) {
-        iout << "ADAPTEMP: STEP " << step
-             << " TEMP "   << adaptTempT
-             << " ENERGY " << std::setprecision(10) << potentialEnergy   
-             << " ENERGYAVG " << std::setprecision(10) << potEnergyAverage
-             << " ENERGYVAR " << std::setprecision(10) << potEnergyVariance;
+    if ( ! (step % simParams->adaptTempOutFreq) ) {
+      char info[256];
+      sprintf(info, "ADAPTEMP: STEP %d TEMP %g BIN %d ENERGY %.5f AVG %g VAR %g",
+          step, adaptTempT, adaptTempBin, potentialEnergy,
+          adaptTempPotEnergyAve[adaptTempBin], adaptTempPotEnergyVar[adaptTempBin]);
+      iout << info;
+      if ( simParams->adaptTempMCMove ) { // Monte Carlo
+        if ( adaptTempMCTot > 0 ) {
+          BigReal acc = adaptTempMCAcc / adaptTempMCTot;
+          BigReal dacc = adaptTempMCDAcc / adaptTempMCTot;
+          if ( dacc > 0 ) dacc = 0;
+          dacc -= adaptTempMCFail / simParams->adaptTempMCSizeInc / adaptTempMCTot;
+          BigReal ar = simParams->adaptTempMCAutoAR;
+          if ( ar <= 0 ) ar = 0.5;
+          BigReal newsize = adaptTempMCSize + (ar - acc) / dacc;
+          if ( newsize < 0 ) newsize = 0;
+          sprintf(info, " MC %.0f(%.0f) ACC. RATIO %.3f%% DAR %g SIZE %g -> %g",
+              adaptTempMCTot, adaptTempMCFail, 100*acc, dacc, adaptTempMCSize, newsize);
+          iout << info;
+        }
+      } else { // Langevin equation
+        if ( adaptTempLangTot > 0 ) {
+          BigReal acc = adaptTempLangAcc / adaptTempLangTot;
+          BigReal dacc = adaptTempLangDAcc / adaptTempLangTot;
+          if ( dacc > 0 ) dacc = 0;
+          dacc -= adaptTempLangFail / simParams->adaptTempMCSizeInc / adaptTempLangTot;
+          BigReal oldsize = sqrt(2*adaptTempDt);
+          BigReal ar = simParams->adaptTempDtAutoAR;
+          if ( ar <= 0 ) ar = 0.5;
+          BigReal newsize = oldsize + (ar - acc) / dacc;
+          if ( newsize < 0 ) newsize = 0;
+          BigReal newdt = newsize * newsize / 2;
+          sprintf(info, " LANGEVIN %.0f(%.0f) ACC. RATIO %.3f%% DAR %g SIZE %g -> %g, DT %g -> %g",
+              adaptTempLangTot, adaptTempLangFail, 100*acc, dacc, oldsize, newsize, adaptTempDt, newdt);
+          iout << info;
+        }
+      }
         iout << "\n" << endi;
    }
-   
+   return scaled;
 }
 
 
@@ -2277,6 +2921,15 @@
       electEnergy = reduction->item(REDUCTION_ELECT_ENERGY);
       ljEnergy = reduction->item(REDUCTION_LJ_ENERGY);
 
+      if (simParameters->LJcorrection && volume) {
+        // Apply tail correction to energy
+        //printf("Volume is %f\n", volume);
+        //printf("Applying tail correction of %f to energy\n", molecule->tail_corr_ener / volume);
+        ljEnergy += molecule->tail_corr_ener / volume;
+        ljEnergy_f += molecule->tail_corr_ener / volume;
+        ljEnergy_f_left += molecule->tail_corr_ener / volume;
+      }
+
       // JLai
       groLJEnergy = reduction->item(REDUCTION_GRO_LJ_ENERGY);
       groGaussEnergy = reduction->item(REDUCTION_GRO_GAUSS_ENERGY);
@@ -2310,16 +2963,6 @@
 //fepe
     }
 
-    if (simParameters->LJcorrection && volume) {
-      // Apply tail correction to energy
-      //printf("Volume is %f\n", volume);
-      //printf("Applying tail correction of %f to energy\n", molecule->tail_corr_ener / volume);
-      ljEnergy += molecule->tail_corr_ener / volume;
-      ljEnergy_f += molecule->tail_corr_ener / volume;
-      ljEnergy_f_left += molecule->tail_corr_ener / volume;
-    }
-
-
     momentum.x = reduction->item(REDUCTION_MOMENTUM_X);
     momentum.y = reduction->item(REDUCTION_MOMENTUM_Y);
     momentum.z = reduction->item(REDUCTION_MOMENTUM_Z);
@@ -3147,6 +3790,7 @@
     ldbSteps = LdbCoordinator::Object()->getNumStepsToRun();
   }
   if ( ! --ldbSteps ) {
+    //CkPrintf("Controller: rebalancing %d, thread %p\n", step, CthSelf());
     startBenchTime -= CmiWallTimer();
 	Node::Object()->outputPatchComputeMaps("before_ldb", step);
     LdbCoordinator::Object()->rebalance(this);	
diff -u -wdB thstat_old/Controller.h thstat_new/Controller.h
--- thstat_old/Controller.h	2015-10-12 10:48:41.000000000 -0500
+++ thstat_new/Controller.h	2016-09-02 12:50:27.350117390 -0500
@@ -151,10 +151,38 @@
     void enqueueCollections(int);
     void correctMomentum(int step);
     void rescaleVelocities(int);
+    void rescaleVelocitiesInit(void);
+    void rescaleVelocitiesLoad(void);
+    void rescaleVelocitiesSave(int);
       BigReal rescaleVelocities_sumTemps;
       int rescaleVelocities_numTemps;
+      BigReal rescaleVelocities_sum1;
+      BigReal rescaleVelocities_sumBeta;
+      BigReal rescaleVelocities_sumBeta2;
+      BigReal rescaleVelocities_sumDbde;
     void reassignVelocities(int);
     void tcoupleVelocities(int);
+    void langRescaleVelocities(int, Bool);
+    BigReal langRescaleFactorPrev;
+    void tNHCInit(void);
+    void tNHCDone(int);
+    void tNHCRescaleVelocities(int, Bool);
+    void tNHCSave(int);
+    void tNHCLoad(void);
+    BigReal tNHCRescaleFactorPrev;
+    BigReal *tNHCzeta;
+    BigReal *tNHCmass;
+    void keHistInit(void);
+    void keHistDone(int);
+    void keHistUpdate(int);
+    // save the kinetic energy to file
+    // the first column is the kinetic energy
+    // the second and third columns are the
+    // normalized histogram and the reference value
+    void keHistSave(int);
+    void keHistLoad(void);
+    BigReal *keHist;
+    int keHistBinMax;
     void berendsenPressure(int);
       // Tensor berendsenPressure_avg;
       // int berendsenPressure_count;
@@ -232,18 +260,181 @@
 
 //JS for adaptive temperature sampling
    void adaptTempInit(int step);
-   void adaptTempUpdate(int step, int minimize = 0);
+   void adaptTempDone(int step);
+   BigReal adaptTempGetInvW(BigReal tp);
+   BigReal adaptTempGetPEAve(int i, BigReal def = 0);
+   BigReal adaptTempGetIntE(BigReal beta, int i, BigReal nbeta, int ni);
+   BigReal adaptTempMCMove(BigReal tp, BigReal ep);
+   BigReal adaptTempLangevin(BigReal tp, BigReal ep);
+   Bool adaptTempUpdate(int step, int minimize = 0);
    void adaptTempWriteRestart(int step);
-   BigReal *adaptTempPotEnergyAveNum;
-   BigReal *adaptTempPotEnergyAveDen;
-   BigReal *adaptTempPotEnergyVarNum;
-   BigReal *adaptTempPotEnergyAve;
-   BigReal *adaptTempPotEnergyVar;
-   int     *adaptTempPotEnergySamples;
+   int *adaptTempBinMinus;
+   int *adaptTempBinPlus;
+   // separator accumulator
+   struct AdaptTempSepAcc {
+     int bin0; // first bin
+     int winSize;
+     double *sumw;
+     double *sumE;
+     double *sumE2;
+     double *ave;
+     double *var;
+     double *cnt;
+     double total;
+     double invGamma;
+
+     AdaptTempSepAcc(void) {
+       winSize = 0;
+     }
+
+     ~AdaptTempSepAcc(void) {
+       if ( winSize > 0 ) {
+         delete [] sumw;
+         delete [] sumE;
+         delete [] sumE2;
+         delete [] ave;
+         delete [] var;
+         delete [] cnt;
+       }
+     }
+
+     void empty(void) {
+       for ( int j = 0; j < winSize; j++ ) {
+         sumw[j]  = 0;
+         sumE[j]  = 0;
+         sumE2[j] = 0;
+         ave[j]   = 0;
+         var[j]   = 0;
+         cnt[j]   = 0;
+       }
+     }
+
+     // initialize the window
+     void init(int minus, int plus) {
+       bin0 = minus;
+       winSize = plus - minus;
+       if ( winSize % 2 == 0 ) NAMD_die("Window size should be odd");
+       total = 0;
+       invGamma = 1;
+       sumw  = new double[winSize];
+       sumE  = new double[winSize];
+       sumE2 = new double[winSize];
+       ave   = new double[winSize];
+       var   = new double[winSize];
+       cnt   = new double[winSize];
+       empty();
+     }
+
+     // compute the average and variance of each bin
+     void trim(void) {
+       if ( invGamma > 1.0 ) { // renormalize the running weight
+         double gam = 1.0/invGamma;
+         for ( int j = 0; j < winSize; j++ ) {
+           sumw[j]  *= gam;
+           sumE[j]  *= gam;
+           sumE2[j] *= gam;
+         }
+         invGamma = 1;
+       }
+       
+       for ( int j = 0; j < winSize; j++ ) {
+         if ( sumw[j] > 0 ) {
+           ave[j] = sumE[j] / sumw[j];
+           var[j] = sumE2[j] / sumw[j] - ave[j] * ave[j];
+         } else {
+           ave[j] = 0;
+           var[j] = 0;
+         }
+         //CkPrintf("j %d, %g %g %g %g %g\n", j, sumw[j], sumE[j], sumE2[j], ave[j], var[j]);
+       }
+     }
+
+     // add a data point from bin i to this accumulator
+     void add(int i, BigReal potEne, BigReal invw, BigReal cg) {
+       i -= bin0; // convert to the local index
+       if ( i < 0 || i >= winSize ) {
+         CkPrintf("Bad local index for bin0 %d: i %d, winSize %d\n", bin0, i + bin0, winSize);
+         NAMD_die("Adaptive tempering: bad local index.");
+       }
+       total += 1;
+       double gamma = 1 - cg / total;
+       if ( gamma < 1e-8 ) gamma = 1e-8;
+       invGamma /= gamma;
+       invw *= invGamma;
+       sumw[i]  += invw;
+       sumE[i]  += invw * potEne;
+       sumE2[i] += invw * potEne * potEne;
+       cnt[i]   += 1;
+       //CkPrintf("adding to bin %d with potEne %g\n", i, potEne);
+     }
+
+     // compute the average energy from the integral identity
+     BigReal iiave(BigReal varCntMin, BigReal def = 0) {
+       int j, mid = winSize / 2;
+       double den0 = 0.0, den1 = 0.0, ene0 = 0.0, ene1 = 0.0;
+       double A0 = 0, A1 = 0, A2 = 0, cntMax = 0, defVar = 0, varj;
+       if ( total <= 0 ) return def;
+       trim();
+       // compute the default variance from the most populated bin
+       for ( j = 0; j < winSize; j++ ) {
+         if ( sumw[j] > cntMax ) {
+           cntMax = sumw[j];
+           defVar = var[j];
+         }
+       }
+       if ( defVar <= 0 ) defVar = 1.0;
+       // left side
+       for ( j = 0; j <= mid; j++ ) {
+         den0 += sumw[j];
+         ene0 += sumE[j];
+         varj = (cnt[j] > varCntMin) ? var[j] : defVar;
+         A0 += varj * (j + 0.5);
+         //CkPrintf("+ %d %g %g %g\n", j, sumw[j], sumE[j], invw[j]);
+       }
+       den0 /= mid + 1;
+       ene0 /= mid + 1;
+       A0 /= mid + 1;
+       // middle bin correction
+       varj = (cnt[mid] > varCntMin) ? var[mid] : defVar;
+       A2 = 0.5 * varj;
+       // right side
+       for ( j = mid + 1; j < winSize; j++ ) {
+         den1 += sumw[j];
+         ene1 += sumE[j];
+         varj = (cnt[j] > varCntMin) ? var[j] : defVar;
+         A1 += varj * (j - winSize + 0.5);
+         //CkPrintf("+ %d %g %g %g\n", j, sumw[j], sumE[j], invw[j]);
+       }
+       if ( mid > 0 ) {
+         den1 /= mid;
+         ene1 /= mid;
+         A1 /= mid;
+       }
+       if ( den0 + den1 <= 0 ) return def;
+       // compute a+ and a-
+       double aplus = ( den0 + den1 > 0 ) ? (A0 - A2) / (A0 - A1) : 0;
+       if ( aplus < 0 ) aplus = 0;
+       if ( aplus > 1 ) aplus = 1;
+       double aminus = 1 - aplus;
+       //CkPrintf("A0 %g, A1 %g, A2 %g, a- %g, a+ %g, ave %g, %g, %g\n", A0, A1, A2, aminus, aplus, sum0/(den0 + 1e-16), sum1/(den1 + 1e-16), (aminus * sum0 + aplus * sum1)/(aminus * den0 + aplus * den1)); getchar();
+       return ( aminus * ene0 + aplus * ene1 )
+            / ( aminus * den0 + aplus * den1 );
+     }
+   };
+   AdaptTempSepAcc *adaptTempSepAcc;
+   double  adaptTempMCSize;
+   double  adaptTempMCTot, adaptTempMCAcc;
+   double  adaptTempMCDAcc, adaptTempMCFail; // accumulators for adjusting the MC size
+   double  adaptTempLangTot, adaptTempLangAcc;
+   double  adaptTempLangDAcc, adaptTempLangFail; // accumulators for adjusting Dt
+   double  *adaptTempPotEnergyAveNum;
+   double  *adaptTempPotEnergyAveDen;
+   double  *adaptTempPotEnergyVarNum;
+   double  *adaptTempPotEnergyAve;
+   double  *adaptTempPotEnergyVar;
+   long    *adaptTempPotEnergySamples;
    BigReal *adaptTempBetaN;
    BigReal adaptTempT;
-   BigReal adaptTempDTave;
-   BigReal adaptTempDTavenum;
    BigReal adaptTempBetaMin;
    BigReal adaptTempBetaMax;
    int     adaptTempBin;
@@ -251,9 +442,6 @@
    BigReal adaptTempDBeta;
    BigReal adaptTempCg;
    BigReal adaptTempDt;
-   Bool    adaptTempAutoDt;
-   BigReal adaptTempDtMin;
-   BigReal adaptTempDtMax;
    ofstream_namd adaptTempRestartFile;
   
 private:
diff -u -wdB thstat_old/fstream_namd.h thstat_new/fstream_namd.h
--- thstat_old/fstream_namd.h	2015-01-31 00:39:07.000000000 -0600
+++ thstat_new/fstream_namd.h	2016-07-22 16:47:10.931646492 -0500
@@ -4,6 +4,11 @@
 
 #include <iostream>
 #include <sstream>
+#if !defined(WIN32) || defined(__CYGWIN__)
+#include <unistd.h>
+#else
+#include <io.h>
+#endif
 
 class ofstream_namd : public std::ostringstream {
 
@@ -31,6 +36,17 @@
     if ( fd ) close();
   }
 
+  void seekbegin() {
+    str("");
+#if !defined(WIN32) || defined(__CYGWIN__)
+    ftruncate(fd, 0);
+    lseek(fd, 0, SEEK_SET);
+#else
+    _chsize(fd, 0);
+    _lseek(fd, 0, SEEK_SET);
+#endif
+  }
+
   bool good() const { return true; }
   bool fail() const { return false; }
   bool bad() const { return false; }
diff -u -wdB thstat_old/Random.h thstat_new/Random.h
--- thstat_old/Random.h	2003-02-10 16:41:19.000000000 -0600
+++ thstat_new/Random.h	2016-07-08 20:14:02.403812877 -0500
@@ -140,6 +140,43 @@
     return Vector( gaussian(), gaussian(), gaussian() );
   }
 
+  // return a number from a gamma distribution of k degrees
+  BigReal gamma(BigReal k)
+  {
+    Bool lt1 = FALSE;
+    BigReal a, b, x, v, u;
+
+    if ( k <= 0 ) return 0;
+    if ( k < 1 ) {
+      lt1 = TRUE;
+      k += 1;
+    }
+    a = k - 1./3;
+    b = 1./3/sqrt(a);
+
+    for ( ; ; ) {
+      do {
+        x = gaussian();
+        v = 1 + b * x;
+      } while ( v <= 0 );
+      v *= v * v;
+      x *= x;
+      u = uniform();
+      if ( u <= 1 - 0.331 * x * x ) break;
+      u = log(u);
+      if ( u <= 0.5 * x + a * (1 - v + log(v)) ) break;
+    }
+
+    x = a * v;
+    if ( lt1 ) x *= pow(1. - uniform(), 1./(k - 1));
+    return x;
+  }
+
+  BigReal chisqr(BigReal k)
+  {
+    return gamma( k * 0.5 ) * 2;
+  }
+
   // return a random long
   long integer(void) {
     skip();
diff -u -wdB thstat_old/Sequencer.C thstat_new/Sequencer.C
--- thstat_old/Sequencer.C	2016-06-01 17:24:35.531579311 -0500
+++ thstat_new/Sequencer.C	2016-08-02 19:41:34.948814711 -0500
@@ -223,12 +223,7 @@
 
     // Is adaptive tempering on?
     const Bool adaptTempOn = simParams->adaptTempOn;
-    adaptTempT = simParams->initialTemp;
-    if (simParams->langevinOn)
-        adaptTempT = simParams->langevinTemp;
-    else if (simParams->rescaleFreq > 0)
-        adaptTempT = simParams->rescaleTemp;
-        
+    adaptTempT = simParams->thermostatTemp();
 
     int &doMolly = patch->flags.doMolly;
     doMolly = simParams->mollyOn && doFullElectrostatics;
@@ -274,6 +269,8 @@
     if ( accelMDOn && !accelMDdihe ) doEnergy=1;
     //Update energy every timestep for adaptive tempering
     if ( adaptTempOn ) doEnergy=1;
+    if ( simParams->energyLogFreq > 0 && step % simParams->energyLogFreq == 0 )
+      doEnergy = 1;
     runComputeObjects(1,step<numberOfSteps); // must migrate here!
     rescaleaccelMD(step, doNonbonded, doFullElectrostatics); // for accelMD 
     adaptTempUpdate(step); // update adaptive tempering temperature
@@ -325,6 +322,8 @@
     {
       rescaleVelocities(step);
       tcoupleVelocities(timestep,step);
+      langRescaleVelocities(step);
+      tNHCRescaleVelocities(step);
       berendsenPressure(step);
 
       if ( ! commOnly ) {
@@ -382,6 +381,8 @@
       doEnergy = ! ( step % energyFrequency );
       if ( accelMDOn && !accelMDdihe ) doEnergy=1;
       if ( adaptTempOn ) doEnergy=1; 
+      if ( simParams->energyLogFreq > 0 && step % simParams->energyLogFreq == 0 )
+        doEnergy = 1;
       runComputeObjects(!(step%stepsPerCycle),step<numberOfSteps);
  
       rescaleaccelMD(step, doNonbonded, doFullElectrostatics); // for accelMD
@@ -438,7 +439,12 @@
 	submitReductions(step);
 	submitCollections(step);
        //Update adaptive tempering temperature
-        adaptTempUpdate(step);
+        Bool scaled = adaptTempUpdate(step);
+        if ( scaled && (ldbSteps == 1 || LdbCoordinator::Object()->getNumStepsToRun() == 1) ) {
+          // submit Hi's if we're about to rebalance load
+          collection->submitHi(step);
+          //CkPrintf("Sequencer step %d, thread %p\n", step, CthSelf());
+        }
 
 #if CYCLE_BARRIER
         cycleBarrier(!((step+1) % stepsPerCycle), step);
@@ -471,6 +477,7 @@
             sprintf(traceNote, "%s%d",tracePrefix,step); 
             traceUserSuppliedNote(traceNote);
         }
+        //if ( ldbSteps == 1 ) CkPrintf("step %d, before rebalanceLoad(), Sequencer PE %d/%d, thread %p\n", step, CkMyPe(), CkNumPes(), CthSelf());
 	rebalanceLoad(step);
 
 #if PME_BARRIER
@@ -1182,19 +1189,28 @@
 
 }
 
-void Sequencer::adaptTempUpdate(int step)
+Bool Sequencer::adaptTempUpdate(int step)
 {
+   Bool scaled = FALSE;
+
    //check if adaptive tempering is enabled and in the right timestep range
-   if (!simParams->adaptTempOn) return;
+   if (!simParams->adaptTempOn) return scaled;
    if ( (step < simParams->adaptTempFirstStep ) || 
      ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) {
-        if (simParams->langevinOn) // restore langevin temperature
-            adaptTempT = simParams->langevinTemp;
-        return;
+        // restore the temperature of the active thermostat
+        adaptTempT = simParams->thermostatTemp();
+        return scaled;
    }
    // Get Updated Temperature
    if ( !(step % simParams->adaptTempFreq ) && (step > simParams->firstTimestep ))
+   {
+    BigReal adaptTempTOld = adaptTempT;
     adaptTempT = broadcast->adaptTemperature.get(step);
+    scaled = TRUE;
+    if ( !simParams->langRescaleOn && !simParams->tNHCOn )
+      rescaleVelocitiesByFactor( sqrt(adaptTempT / adaptTempTOld) );
+   }
+   return scaled;
 }
 
 void Sequencer::reassignVelocities(BigReal timestep, int step)
@@ -1289,6 +1305,26 @@
   }
 }
 
+void Sequencer::langRescaleVelocities(int step)
+{
+  if ( simParams->langRescaleOn ) {
+    FullAtom *a = patch->atom.begin();
+    BigReal factor = broadcast->langRescaleFactor.get(step);
+    for ( int i = 0; i < patch->numAtoms; ++i )
+      a[i].velocity *= factor;
+  }
+}
+
+void Sequencer::tNHCRescaleVelocities(int step)
+{
+  if ( simParams->tNHCOn ) {
+    FullAtom *a = patch->atom.begin();
+    BigReal factor = broadcast->tNHCRescaleFactor.get(step);
+    for ( int i = 0; i < patch->numAtoms; ++i )
+      a[i].velocity *= factor;
+  }
+}
+
 void Sequencer::saveForce(const int ftag)
 {
   patch->saveForce(ftag);
@@ -2127,6 +2163,7 @@
     ldbSteps = LdbCoordinator::Object()->getNumStepsToRun();
   }
   if ( ! --ldbSteps ) {
+    //CkPrintf("Sequencer : rebalancing %d, thread %p\n", timestep, CthSelf());
     patch->submitLoadStats(timestep);
     ldbCoordinator->rebalance(this,patch->getPatchID());
     pairlistsAreValid = 0;
diff -u -wdB thstat_old/Sequencer.h thstat_new/Sequencer.h
--- thstat_old/Sequencer.h	2013-10-30 13:26:16.000000000 -0500
+++ thstat_new/Sequencer.h	2016-08-09 16:39:50.316991167 -0500
@@ -74,7 +74,7 @@
     void reloadCharges();
 
     BigReal adaptTempT;         // adaptive tempering temperature
-    void adaptTempUpdate(int); // adaptive tempering temperature update
+    Bool adaptTempUpdate(int); // adaptive tempering temperature update
 
     void rescaleVelocities(int);
     void rescaleaccelMD(int, int, int); // for accelMD
@@ -83,6 +83,8 @@
     void reinitVelocities(void);
     void rescaleVelocitiesByFactor(BigReal);
     void tcoupleVelocities(BigReal,int);
+    void langRescaleVelocities(int);
+    void tNHCRescaleVelocities(int);
     void berendsenPressure(int);
       int berendsenPressure_count;
       int checkpoint_berendsenPressure_count;
diff -u -wdB thstat_old/SimParameters.C thstat_new/SimParameters.C
--- thstat_old/SimParameters.C	2015-12-08 09:41:37.000000000 -0600
+++ thstat_new/SimParameters.C	2016-08-29 20:09:29.468685094 -0500
@@ -187,6 +187,12 @@
   }
   SCRIPT_PARSE_FLOAT("reassignTemp",reassignTemp)
   SCRIPT_PARSE_FLOAT("rescaleTemp",rescaleTemp)
+  SCRIPT_PARSE_BOOL("rescaleAdaptive",rescaleAdaptiveOn)
+  SCRIPT_PARSE_FLOAT("rescaleAdaptiveDedk",rescaleAdaptiveDedk)
+  SCRIPT_PARSE_FLOAT("langRescaleTemp",langRescaleTemp)
+  SCRIPT_PARSE_FLOAT("langRescaleDt",langRescaleDt)
+  SCRIPT_PARSE_FLOAT("tNHCTemp",langRescaleTemp)
+  SCRIPT_PARSE_FLOAT("tNHCPeriod",langRescaleDt)
   SCRIPT_PARSE_BOOL("velocityQuenching",minimizeOn)
   SCRIPT_PARSE_BOOL("maximumMove",maximumMove)
   // SCRIPT_PARSE_BOOL("Langevin",langevinOn)
@@ -1178,6 +1184,58 @@
      "containing the temperature coupling term B(i);\n"
      "default is 'O'", PARSE_STRING);
 
+   //  Get parameters for the Langevin velocity-rescaling thermostat
+   opts.optionalB("main", "langrescale", 
+      "Should Langevin velocity-rescaling thermostat be turned on?",
+      &langRescaleOn, FALSE);
+   opts.require("langrescale", "langRescaleTemp",
+    "Temperature for Langevin velocity-rescaling thermostat",
+    &langRescaleTemp);
+   opts.range("langRescaleTemp", NOT_NEGATIVE);
+   opts.units("langRescaleTemp", N_KELVIN);
+   opts.optional("langrescale", "langRescaleDt",
+    "Inverse viscosity in femtoseconds for Langevin velocity-rescaling thermostat",
+    &langRescaleDt, 20.0);
+
+   //  Get parameters for the Nose-Hoover chain thermostat
+   //  Nose-Hoover chains: The canonical ensemble via continuous dynamics 
+   //  Glenn J. Martyna, Michael L. Klein, and Mark Tuckerman, JCP 97 (4) 2635
+   opts.optionalB("main", "tNHC", "Should Nose-Hoover chain thermostat be turned on?",
+      &tNHCOn, FALSE);
+   opts.require("tNHC", "tNHCTemp", "Temperature for Nose-Hoover chain thermostat",
+    &tNHCTemp);
+   opts.range("tNHCTemp", NOT_NEGATIVE);
+   opts.units("tNHCTemp", N_KELVIN);
+   opts.require("tNHC", "tNHCLen", "Length of Nose-Hoover chain",
+    &tNHCLen, 1);
+   opts.range("tNHCLen", POSITIVE);
+   opts.optional("tNHC", "tNHCPeriod", "Oscillation period in femtoseconds of the Nose-Hoover chain",
+    &tNHCPeriod, 100.0);
+   opts.range("tNHCPeriod", POSITIVE);
+   opts.optional("tNHC", "tNHCFile", "Restart file for the NH-chain",
+       tNHCFile);
+   opts.optional("tNHC", "tNHCFileFreq", "Frequency of writing restart file for the NH-chain",
+       &tNHCFileFreq, 10000);
+   opts.range("tNHCFileFreq", POSITIVE);
+   opts.optionalB("tNHC", "tNHCFileReadMass", "Read mass from the restart file, if any",
+       &tNHCFileReadMass, FALSE);
+
+   opts.optionalB("main", "keHist", "Should kinetic energy histogram be turned on?",
+       &keHistOn, FALSE);
+   opts.optional("keHist", "keHistBin", "Bin size of the histogram of the kinetic energy",
+       &keHistBin, 1.0);
+   opts.optional("keHist", "keHistFile", "Histogram file for the kinetic energy",
+       keHistFile);
+   opts.optional("keHist", "keHistFileFreq", "Frequency of writing the histogram file for the kinetic energy",
+       &keHistFileFreq, 10000);
+   opts.range("keHistFileFreq", POSITIVE);
+
+   opts.optional("main", "energyLogFile", "Energy log file",
+       energyLogFile);
+   opts.optional("energyLogFile", "energyLogFreq", "Frequency of writing the energy log file",
+       &energyLogFreq, 1);
+   opts.range("energyLogFreq", POSITIVE);
+
    opts.optional("main", "rescaleFreq", "Number of steps between "
     "velocity rescaling", &rescaleFreq);
    opts.range("rescaleFreq", POSITIVE);
@@ -1185,6 +1243,17 @@
     &rescaleTemp);
    opts.range("rescaleTemp", NOT_NEGATIVE);
    opts.units("rescaleTemp", N_KELVIN);
+   opts.optionalB("main", "rescaleAdaptive", "Adaptively reduce the magnitude "
+    "of the velocity rescaling", &rescaleAdaptiveOn, FALSE);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveDedk", "Heuristic multiple of the reduction factor ",
+    &rescaleAdaptiveDedk, 0.0);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveFile",
+       "File for writing the adaptive velocity-rescaling restart information",
+       rescaleAdaptiveFile);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveFileFreq",
+       "Frequency of writing the adaptive velocity-rescaling restart information",
+       &rescaleAdaptiveFileFreq, 10000);
+   opts.range("rescaleAdaptiveFileFreq", POSITIVE);
 
    opts.optional("main", "reassignFreq", "Number of steps between "
     "velocity reassignment", &reassignFreq);
@@ -1374,19 +1443,37 @@
    opts.range("adaptTempTmax", POSITIVE);
    opts.optional("adaptTempMD", "adaptTempBins","Number of bins to store average energies", &adaptTempBins,0);
    opts.range("adaptTempBins", NOT_NEGATIVE);
+   opts.optional("adaptTempMD", "adaptTempWindowSize", "Window size as a fraction of the inverse temperature range", &adaptTempWindowSize, 0.02);
+   opts.range("adaptTempWindowSize", NOT_NEGATIVE);
+   opts.optional("adaptTempMD", "adaptTempWeightExp", "Exponent x as in the inverse-temperature density, w(beta) ~ beta^(-x), 0: flat-beta, 1: flat-lnT, 2: flat-T distribution", &adaptTempWeightExp, 1.0);
+   opts.optionalB("adaptTempMD", "adaptTempMCMove", "Use Monte Carlo to update the temperature", &adaptTempMCMove, FALSE);
+   opts.optional("adaptTempMCMove", "adaptTempMCSize", "Size of Monte Carlo temperature moves as a fraction of the current temperature", &adaptTempMCSize, 0.01);
+   opts.optional("adaptTempMCMove", "adaptTempMCAutoAR", "Target acceptance ratio for automatic adjustment of the size of MC temperature moves", &adaptTempMCAutoAR, 0.0);
+   opts.range("adaptTempMCAutoAR", NOT_NEGATIVE);
+   opts.optional("adaptTempMD", "adaptTempMCSizeInc", "Virtual (equivalent) size increment for MC or Langevin temperature moves", &adaptTempMCSizeInc, 0.0005);
+   opts.range("adaptTempMCSizeInc", POSITIVE);
    opts.optional("adaptTempMD", "adaptTempDt", "Integration timestep for Temp. updates", &adaptTempDt, 0.0001);
-   opts.units("adaptTempDt", N_FSEC);
    opts.range("adaptTempDt", NOT_NEGATIVE);
+   opts.optional("adaptTempDt", "adaptTempDtAutoAR", "Target acceptance ratio for automatic adjustment of the size of Langevin temperature moves", &adaptTempDtAutoAR, 0.0);
+   opts.range("adaptTempDtAutoAR", NOT_NEGATIVE);
    opts.optional("adaptTempMD", "adaptTempAutoDt", "Average temperature update in percent of temperature range", &adaptTempAutoDt, 0.0);
    opts.range("adaptTempAutoDt", NOT_NEGATIVE);
    opts.optional("adaptTempMD", "adaptTempCgamma", "Adaptive bin averaging constant", &adaptTempCgamma, 0.1);
    opts.range("adaptTempCgamma", NOT_NEGATIVE);
    opts.optionalB("adaptTempMD","adaptTempLangevin","Send adaptTemp temperature to langevin thermostat",&adaptTempLangevin,TRUE);
    opts.optionalB("adaptTempMD","adaptTempRescaling","Send adaptTemp temperature to velocity rescaling thermostat", &adaptTempRescale,TRUE);
+   opts.optionalB("adaptTempMD","adaptTempLangRescale","Send adaptTemp temperature to Langevin-style velocity rescaling thermostat", &adaptTempLangRescale,TRUE);
+   opts.optionalB("adaptTempMD","adaptTempTNHC","Send adaptTemp temperature to Nose-Hoover chain thermostat",&adaptTempTNHC,TRUE);
    opts.optional("adaptTempMD", "adaptTempInFile", "File containing restart information for adaptTemp", adaptTempInFile);
+   opts.optionalB("adaptTempInFile", "adaptTempFixedAve", "Fixing the average values from the input restart file", &adaptTempFixedAve, FALSE);
+   opts.optionalB("adaptTempInFile", "adaptTempEmptyData", "Emptying data (except the average energy) after reading the input restart file", &adaptTempEmptyData, FALSE);
    opts.optional("adaptTempMD", "adaptTempRestartFile", "File for writing adaptTemp restart information", adaptTempRestartFile);
    opts.require("adaptTempRestartFile","adaptTempRestartFreq", "Frequency of writing restart file", &adaptTempRestartFreq,0);
    opts.range("adaptTempRestartFreq",NOT_NEGATIVE);
+   opts.optionalB("adaptTempRestartFile", "adaptTempRestartAppend", "Appending instead of overwriting the restart file", &adaptTempRestartAppend, FALSE);
+   opts.optionalB("adaptTempMD", "adaptTempSep", "Using a separate multiple-bin estimator for each bin", &adaptTempSepOn, FALSE);
+   opts.optional("adaptTempMD", "adaptTempSamplesMin", "Minimal number of samples in a bin to start temperature transitions", &adaptTempSamplesMin, 1000);
+   opts.range("adaptTempSamplesMin", NOT_NEGATIVE);
    opts.optionalB("adaptTempMD", "adaptTempRandom", "Randomly assign a temperature if we step out of range", &adaptTempRandom, FALSE);
 }
 
@@ -2174,6 +2261,22 @@
 
 }
 
+// return the temperature of the active thermostat
+BigReal SimParameters::thermostatTemp(void)
+{
+  if ( langRescaleOn ) {
+    return langRescaleTemp;
+  } else if ( tNHCOn ) {
+    return tNHCTemp;
+  } else if ( langevinOn ) {
+    return langevinTemp;
+  } else if ( rescaleFreq > 0 ) {
+    return rescaleTemp;
+  } else {
+    return initialTemp;
+  }
+}
+
 #ifdef MEM_OPT_VERSION
 //This global var is defined in mainfunc.C
 extern char *gWorkDir;
@@ -2989,9 +3092,15 @@
    }
    // END LA
 
-   if (tCoupleOn && opts.defined("rescaleFreq") )
+   int thstat_cnt = 0;
+   if ( tCoupleOn ) thstat_cnt++;
+   if ( opts.defined("rescaleFreq") ) thstat_cnt++;
+   if ( langRescaleOn ) thstat_cnt++;
+   if ( tNHCOn ) thstat_cnt++;
+
+   if ( thstat_cnt > 1 )
    {
-      NAMD_die("Temperature coupling and temperature rescaling are mutually exclusive");
+      NAMD_die("Temperature coupling, temperature rescaling, Langevin-style velocity rescaling thermostat, and Nose-Hoover chain thermostat are mutually exclusive");
    }
 
    if (globalOn && CkNumPes() > 1)
@@ -3033,16 +3142,29 @@
       maximumMove = 0.75 * pairlistDist/stepsPerCycle;
    }
    if (adaptTempOn) {
-     if (!adaptTempRescale && !adaptTempLangevin) 
-        NAMD_die("Adaptive tempering needs to be coupled to either the Langevin thermostat or velocity rescaling.");
-     if (opts.defined("adaptTempInFile") && (opts.defined("adaptTempTmin") ||
-                                             opts.defined("adaptTempTmax") ||
-                                             adaptTempBins != 0)) 
-        NAMD_die("cannot simultaneously specify adaptTempInFile and any of {adaptTempTmin, adaptTempTmax,adaptTempBins} as these are read from the input file");
+     if (!adaptTempRescale && !adaptTempLangevin && !adaptTempLangRescale && !adaptTempTNHC) 
+        NAMD_die("Adaptive tempering needs to be coupled to one of following: Langevin thermostat, velocity rescaling, Langevin velocity rescaling thermostat, and Nose-Hoover chain thermostat.");
+     if ( !opts.defined("adaptTempInFile") ) {
+       adaptTempInFile[0] = '\0';
+       adaptTempFixedAve = FALSE;
+     }
+     if ( opts.defined("adaptTempAutoDt") )
+       iout << iWARN << "adaptTempAutoDt is deprecated.\n" << endi;
+     if ( adaptTempRandom )
+       iout << iWARN << "adaptTempRandom is deprecated.\n" << endi;
+     if ( opts.defined("adaptTempCgamma") && !adaptTempSepOn )
+       iout << iWARN << "adaptTempCgamma is better used with adaptTempSep.\n" << endi;
+     //if (opts.defined("adaptTempInFile") && (opts.defined("adaptTempTmin") ||
+     //                                        opts.defined("adaptTempTmax") ||
+     //                                        adaptTempBins != 0)) 
+     //   NAMD_die("cannot simultaneously specify adaptTempInFile and any of {adaptTempTmin, adaptTempTmax,adaptTempBins} as these are read from the input file");
      if (!opts.defined("adaptTempInFile") && !(opts.defined("adaptTempTmin") &&
                                              opts.defined("adaptTempTmax") &&
                                              adaptTempBins != 0 ))  
         NAMD_die("Need to specify either adaptTempInFile or all of {adaptTempTmin, adaptTempTmax,adaptTempBins} if adaptTempMD is on.");
+     if ( rescaleFreq > 0 )
+       iout << iWARN << "Velocity rescaling does not sample the exact Boltzmann distribution "
+	 "and adaptive tempering will not work properly\n" << endi;
    }
    if (langevinOn) {
      if ( ! opts.defined("langevinDamping") ) langevinDamping = 0.0;
@@ -3089,6 +3211,16 @@
   }
    }
 
+    if ( rescaleAdaptiveOn ) {
+      if ( !opts.defined("rescaleAdaptiveFile") ) {
+        strcpy(rescaleAdaptiveFile, "adaptvrescale.dat");
+      }
+    }
+
+   if ( !opts.defined("energyLogFile") ) { // disable energy logging
+     energyLogFreq = 0;
+   }
+
    if (opts.defined("reassignFreq"))
    {
   if (!opts.defined("reassignTemp"))
@@ -3188,6 +3320,8 @@
      else if (reassignFreq > 0)	alchTemp = reassignTemp;
      else if (langevinOn) 	alchTemp = langevinTemp;
      else if (tCoupleOn) 	alchTemp = tCoupleTemp;
+     else if (langRescaleOn)    alchTemp = tNHCTemp;
+     else if (tNHCOn)           alchTemp = tNHCTemp;
      else NAMD_die("Alchemical FEP can be performed only in constant temperature simulations\n");
 
      if (reassignFreq > 0 && reassignIncr != 0)
@@ -3820,6 +3954,16 @@
   tCoupleTemp = 0.0;
    }
 
+   if (!opts.defined("langRescale"))
+   {
+     langRescaleTemp = 0.0;
+   }
+
+   if (!opts.defined("tNHC"))
+   {
+     tNHCTemp = 0.0;
+   }
+
    if (HydrogenBonds)
    {
      if (daCutoffDist > pairlistDist)
@@ -4890,6 +5034,26 @@
       iout << endi;
    }
 
+   if (langRescaleOn)
+   {
+      iout << iINFO << "LANGEVIN-STYLE VELOCITY RESCALING THERMOSTAT ACTIVE\n";
+      iout << iINFO << "    TARGET TEMPERATURE " << langRescaleTemp << " K\n";
+      iout << iINFO << "    INVERSE VISCOSITY  " << langRescaleDt << " fs\n";
+      iout << endi;
+   }
+
+   if (tNHCOn)
+   {
+      iout << iINFO << "NOSE-HOOVER CHAIN THERMOSTAT ACTIVE\n";
+      iout << iINFO << "    TARGET TEMPERATURE " << tNHCTemp << " K\n";
+      iout << iINFO << "    CHAIN LENGTH       " << tNHCLen << "\n";
+      iout << iINFO << "    OSCILLATION PERIOD " << tNHCPeriod << " fs\n";
+      if ( tNHCFileReadMass ) {
+        iout << iINFO << "    READ MASS FROM     " << tNHCFile << "\n";
+      }
+      iout << endi;
+   }
+
    if (minimizeOn)
    {
       iout << iINFO << "OLD STYLE MINIMIZATION ACTIVE\n";
@@ -5088,6 +5252,7 @@
      iout << iINFO << "ADAPTIVE TEMPERING ACTIVE:\n";
      iout << iINFO << "      OUTPUT FREQUENCY: " << adaptTempOutFreq << "\n";
      iout << iINFO << "      TEMPERATURE UPDATE FREQUENCY: " << adaptTempFreq << "\n";
+     iout << iINFO << "      OVERALL INVERSE-TEMPERATURE DISTRIBUTION: W(BETA) ~ BETA^(" << (-adaptTempWeightExp) << ")\n";
      if ( adaptTempLastStep > 0 )
         iout << iINFO << "      ADAPTIVE TEMPERING WILL BE DONE FROM STEP " << adaptTempFirstStep  << " TO " << adaptTempLastStep << "\n";
      else
@@ -5096,6 +5261,10 @@
         iout << iINFO << "      ADAPTIVE TEMPERING COUPLED TO LANGEVIN THERMOSTAT\n";
      if ( adaptTempRescale )
         iout << iINFO << "      ADAPTIVE TEMPERING COUPLED TO VELOCITY RESCALING\n";
+     if (adaptTempInFile[0] != '\0') {
+        iout << iINFO << "      READING RESTART INFORMATION FROM " << adaptTempInFile << " "
+             << (adaptTempFixedAve ? "(FIXED)" : "") << "\n";
+     }
      if (adaptTempRestartFreq > 0) {
         iout << iINFO << "      WRITING RESTART INFORMATION TO " << adaptTempRestartFile << " EVERY " << adaptTempRestartFreq << " STEPS\n";
      }
diff -u -wdB thstat_old/SimParameters.h thstat_new/SimParameters.h
--- thstat_old/SimParameters.h	2015-09-04 17:20:03.000000000 -0500
+++ thstat_new/SimParameters.h	2016-08-29 20:09:22.673732144 -0500
@@ -497,8 +497,35 @@
 					//  active
 	BigReal tCoupleTemp;		//  Temperature for temp coupling
 
+	Bool langRescaleOn;		//  Flag TRUE-> Langevin velocity-rescaling thermostat active
+	                   		//  Bussi, Donadio, and Parrinello, JCP 126, 014101 (2007)
+	BigReal langRescaleTemp;	//  Temperature for Langevin velocity-rescaling thermostat
+	BigReal langRescaleDt;	        //  Inverse viscosity in femtoseconds for Langevin velocity-rescaling thermostat
+	int langRescaleFreq;	        //  number of MD steps between two Langevin velocity-rescaling steps
+
+	Bool tNHCOn;			// Flag TRUE-> Nose-Hoover chain thermostat
+	            			// Martyna, Klein, and Tuckerman, JCP 97, 2635 (1992)
+	BigReal tNHCTemp;		// Temperature of the Nose-Hoover chain
+	int tNHCLen;			// Length of the Nose-Hoover chain
+	BigReal tNHCPeriod;		// Oscillation period in femtoseconds of the Nose-Hoover chain
+	char tNHCFile[128];		// Restart file for the NH-chain
+	int tNHCFileFreq;		// Frequency of writing the NH-chain restart file
+	Bool tNHCFileReadMass;		// Read mass from the restart file
+
+	Bool keHistOn;			// Flag TRUE-> Kinetic energy histogram
+	BigReal keHistBin;		// Bin size of the histogram of the kinetic energy
+	char keHistFile[128];		// Histogram file for the kinetic energy 
+	int keHistFileFreq;		// Frequency of writing the kinetic energy histogram file
+
+        char energyLogFile[128];        // Energy log file
+        int energyLogFreq;              // Frequency of writing the energy log file
+
 	int rescaleFreq;		//  Velocity rescale frequency
 	BigReal rescaleTemp;		//  Temperature to rescale to
+	Bool rescaleAdaptiveOn;		//  Adaptively reduce the velocity-rescaling factor
+	BigReal rescaleAdaptiveDedk;	//  Heuristic multiple of the reduction factor
+	char rescaleAdaptiveFile[128];	//  File to save the adaptive veloctiy-rescaling data
+	int rescaleAdaptiveFileFreq;	//  Frequency to save the adaptive veloctiy-rescaling restart file
 
         Bool accelMDOn;                 //  Perform accelerated MD
         Bool accelMDdihe;               //  Apply boost to the dihedral potential
@@ -523,13 +550,27 @@
         BigReal adaptTempTmax;                 //  Upper temperature bound
         BigReal adaptTempAutoDt;               //  Auto jump size. Value determines upper bound, adaotTempDt determines lower bound 
         int adaptTempBins;                     //  Number of bins to store average energy values
-        BigReal adaptTempDt;                   //  timestep for adaptTemp updates - only affects Temperature random walk
+        BigReal adaptTempWindowSize;           //  Window size as a fraction of the inverse temperature range
+        BigReal adaptTempWeightExp;            //  Exponent x as in the inverse-temperature density w(beta) ~ beta^(-x), 0: flat-beta, 1: flat-lnT, 2: flat-T distribution
+        Bool adaptTempMCMove;                  //  Use Monte Carlo to update the temperature
+        BigReal adaptTempMCSize;               //  Size of Monte Carlo temperature moves a faction of the current temperture
+        BigReal adaptTempMCSizeInc;            //  Virtual (equivalent) size increment for MC or Langevin temperature moves
+        BigReal adaptTempMCAutoAR;             //  Target acceptance ratio for automatic adjustment of the size of MC temperature moves
+        BigReal adaptTempDt;                   //  Timestep for adaptTemp updates - only affects Temperature random walk
+        BigReal adaptTempDtAutoAR;             //  Target acceptance ratio for automatic adjustment of the size of Langevin temperature moves
         BigReal adaptTempCgamma;               //  Cgamma variable for adaptive bin averaging Cgamma = 0 is normal Averaging. 1 > Cgamma >= 0
         Bool adaptTempLangevin;                //  Couple to Langevin Thermostat
         Bool adaptTempRescale;                 //  Couple to Vel. Rescaling
+        Bool adaptTempLangRescale;             //  Couple to Langevin-style velocity rescaling thermostat
+        Bool adaptTempTNHC;                    //  Couple to Nose-Hoover chain thermostat
         char adaptTempInFile[128];             //  Restart information for adaptTemp to read
+        Bool adaptTempFixedAve;                //  Fixing the average values from the input restart file
+        Bool adaptTempEmptyData;               //  Emptying data (except the average energy) after reading the input restart file
         char adaptTempRestartFile[128];        //  File to write restart information
         int  adaptTempRestartFreq;             //  Frequency of writing restart output
+        Bool adaptTempRestartAppend;           //  Appending instead of overwriting the restart file
+        Bool adaptTempSepOn;                   //  Using a separate multiple-bin estimator for each bin
+        BigReal adaptTempSamplesMin;           //  Minimal number of samples in a bin to start temperature transitions
         Bool adaptTempRandom;                  //  Do we assign random temperatures when we step out of [Tmin,Tmax]?
         /* End Adaptive Temperature Sampling */
 
@@ -921,6 +962,7 @@
         int issetinparseopts(const char* name);
 
        	void readExtendedSystem(const char *filename, Lattice *latptr=0);
+        BigReal thermostatTemp(void);
 private:
         ParseOptions *parseopts;
 
