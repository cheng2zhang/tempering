diff -u -wdB thstat_old/Broadcasts.h thstat_new/Broadcasts.h
--- thstat_old/Broadcasts.h	2015-03-03 11:54:14.000000000 -0600
+++ thstat_new/Broadcasts.h	2016-07-08 20:14:02.400812886 -0500
@@ -39,6 +39,8 @@
   velocityRescaleFactorTag,
   positionRescaleFactorTag,
   tcoupleCoefficientTag,
+  langRescaleFactorTag,
+  tNHCRescaleFactorTag,
   minimizeCoefficientTag,
   momentumCorrectionTag,
 #if USE_BARRIER
@@ -60,6 +62,8 @@
   SimpleBroadcastObject<BigReal> velocityRescaleFactor;
   SimpleBroadcastObject<Tensor> positionRescaleFactor;
   SimpleBroadcastObject<BigReal> tcoupleCoefficient;
+  SimpleBroadcastObject<BigReal> langRescaleFactor;
+  SimpleBroadcastObject<BigReal> tNHCRescaleFactor;
   SimpleBroadcastObject<BigReal> minimizeCoefficient;
   SimpleBroadcastObject<Vector> momentumCorrection;
 #if USE_BARRIER
@@ -77,6 +81,8 @@
     velocityRescaleFactor(velocityRescaleFactorTag, ldObjPtr),
     positionRescaleFactor(positionRescaleFactorTag, ldObjPtr),
     tcoupleCoefficient(tcoupleCoefficientTag, ldObjPtr),
+    langRescaleFactor(langRescaleFactorTag, ldObjPtr),
+    tNHCRescaleFactor(tNHCRescaleFactorTag, ldObjPtr),
     minimizeCoefficient(minimizeCoefficientTag, ldObjPtr),
     momentumCorrection(momentumCorrectionTag, ldObjPtr),
 #if USE_BARRIER
diff -u -wdB thstat_old/CollectionMaster.C thstat_new/CollectionMaster.C
--- thstat_old/CollectionMaster.C	2012-01-28 16:04:27.000000000 -0600
+++ thstat_new/CollectionMaster.C	2016-07-08 20:14:02.400812886 -0500
@@ -43,6 +43,27 @@
 {
 }
 
+void CollectionMaster::receiveHi(int seq)
+{
+  hi.submitData(seq);
+  CollectHiInstance *c = hi.removeReady(seq);
+  if ( c != 0 ) { // collected Hi's from all nodes
+    CthAwaken(hiThread);
+    hiThread = 0;
+  }
+}
+
+void CollectionMaster::enqueueHi(int seq)
+{
+  CollectHiInstance *c = hi.removeReady(seq);
+  if ( c == 0 ) { // lock the thread
+    hiThread = CthSelf();
+    CthSuspend();
+  } else { // already collected Hi's from all nodes
+    c->free(); // empty the spot, but don't actually free the memory
+  }
+}
+
 void CollectionMaster::receivePositions(CollectVectorMsg *msg)
 {
 #ifndef MEM_OPT_VERSION
diff -u -wdB thstat_old/CollectionMaster.ci thstat_new/CollectionMaster.ci
--- thstat_old/CollectionMaster.ci	2011-05-20 15:17:45.000000000 -0500
+++ thstat_new/CollectionMaster.ci	2016-07-08 20:14:02.401812883 -0500
@@ -35,6 +35,7 @@
     entry void startNextRoundOutputForce(double totalT);
     entry void wrapCoorFinished();
     
+    entry void receiveHi(int seq);
   };
 }
 
diff -u -wdB thstat_old/CollectionMaster.h thstat_new/CollectionMaster.h
--- thstat_old/CollectionMaster.h	2015-11-04 11:20:25.000000000 -0600
+++ thstat_new/CollectionMaster.h	2016-07-08 20:14:02.401812883 -0500
@@ -297,6 +297,61 @@
 
   };
 #endif
+
+  class CollectHiInstance
+  {
+  public:
+    CollectHiInstance(void) : seq(-10) { ; }
+    void free() { seq = -10; }
+    int notfree() { return seq != -10; }
+    void reset(int s) {
+      seq = s;
+      remaining = PatchMap::Object()->numNodesWithPatches(); 
+    }
+    int seq;
+    int remaining;
+  };
+
+  class CollectHiSequence
+  {
+  public:
+    ResizeArray<CollectHiInstance *> data;
+
+    void submitData(int seq) {
+      CollectHiInstance **c, **c_e = data.end();
+      for( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      if ( c == c_e ) { // the sequence does not exist
+        // try to find an empty spot in the array
+        for( c = data.begin(); c != c_e && (*c)->notfree(); ++c )
+          ;
+        if ( c == c_e ) { // no empty spot exists, append one
+          data.add(new CollectHiInstance);
+          c = data.end() - 1;
+        }
+        (*c)->reset(seq);
+      }
+      (*c)->remaining--;
+    }
+
+    // return nonzero if all nodes have submitted data for step `seq'
+    CollectHiInstance* removeReady(int seq) {
+      CollectHiInstance *o = 0, **c, **c_e = data.end();
+      for( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      int remaining = 0;
+      if ( c != c_e && (remaining = (*c)->remaining) == 0 )
+        o = *c;
+      return o;
+    }
+
+    CollectHiSequence() { ; }
+  };
+
+public:
+  void receiveHi(int seq);
+  void enqueueHi(int seq);
+
 private:
 
   CollectVectorSequence positions;
@@ -304,6 +359,8 @@
   CollectVectorSequence forces;
   int posTimings, velTimings, forceTimings;
   FILE *dataStreamFile;
+  CollectHiSequence hi;
+  CthThread hiThread;
 
 #ifdef MEM_OPT_VERSION
   int wrapCoorDoneCnt;
diff -u -wdB thstat_old/CollectionMgr.C thstat_new/CollectionMgr.C
--- thstat_old/CollectionMgr.C	2015-09-04 17:20:02.000000000 -0500
+++ thstat_new/CollectionMgr.C	2016-07-08 20:14:02.401812883 -0500
@@ -305,6 +305,16 @@
 }
 #endif
 
+void CollectionMgr::submitHi(int seq) {  
+  CollectHiInstance *c = hi.submitData(seq);
+  if ( c != 0 ) {
+    // all HomePatches on the Node have submitted data
+    CProxy_CollectionMaster cm(master);
+    cm.receiveHi(c->seq);
+    c->free();
+  }
+}
+
 void CollectionMgr::sendDataStream(const char *data) {
   DataStreamMsg *msg = new DataStreamMsg;
   msg->data.resize(strlen(data)+1);
diff -u -wdB thstat_old/CollectionMgr.h thstat_new/CollectionMgr.h
--- thstat_old/CollectionMgr.h	2013-09-06 14:11:36.000000000 -0500
+++ thstat_new/CollectionMgr.h	2016-07-08 20:14:02.401812883 -0500
@@ -138,6 +138,50 @@
     ResizeArray<CollectVectorInstance*> data;
 
   };
+
+
+
+  class CollectHiInstance
+  {
+  public:
+    CollectHiInstance(void) : seq(-10) { ; }
+    void free() { seq = -10; }
+    int notfree() { return ( seq != -10 ); }
+    void reset(int s) {
+      seq = s;
+      remaining = PatchMap::Object()->numHomePatches();
+    }
+    int seq;
+    int remaining;
+  };
+
+  class CollectHiSequence
+  {
+  public:
+    ResizeArray<CollectHiInstance*> data;
+
+    CollectHiInstance* submitData(int seq) {
+      CollectHiInstance **c, **c_e = data.end();
+      for ( c = data.begin(); c != c_e && (*c)->seq != seq; ++c )
+        ;
+      if ( c == c_e ) { // CollectHiInstance for the sequence `seq' does not exist
+        // try to find an empty spot in the array
+        for ( c = data.begin(); c != c_e && (*c)->notfree(); ++c )
+          ;
+        if ( c == c_e ) { // no empty spot exists, append one
+         data.add(new CollectHiInstance);
+         c = data.end() - 1;
+        }
+        (*c)->reset(seq);
+      }
+      if ( --(*c)->remaining == 0 ) {
+        return *c;
+      } else {
+        return 0;
+      }
+    }
+  };
+
 private:
 
   CkChareID master;
@@ -146,6 +190,9 @@
   CollectVectorSequence velocities;
   CollectVectorSequence forces;
 
+  CollectHiSequence hi;
+public:
+  void submitHi(int);
 };
 
 #endif
diff -u -wdB thstat_old/common.C thstat_new/common.C
--- thstat_old/common.C	2015-02-02 10:14:20.000000000 -0600
+++ thstat_new/common.C	2016-07-22 16:23:22.575103687 -0500
@@ -181,7 +181,7 @@
   int fd;
 
   //  open the file and die if the open fails
-#ifdef WIN32
+#if defined(WIN32) && !defined(__CYGWIN__)
   while ( (fd = _open(fname, O_WRONLY|(append?O_APPEND:O_EXCL)|O_CREAT|O_TEXT,_S_IREAD|_S_IWRITE)) < 0) {
 #else
 #ifdef NAMD_NO_O_EXCL
@@ -223,7 +223,7 @@
 
 // same as close, only does error checking internally
 void NAMD_close(int fd, const char *fname) {
-#ifdef WIN32
+#if defined(WIN32) && !defined(__CYGWIN__)
   while ( _close(fd) ) {
 #else
   while ( close(fd) ) {
diff -u -wdB thstat_old/Controller.C thstat_new/Controller.C
--- thstat_old/Controller.C	2015-12-17 15:22:03.000000000 -0600
+++ thstat_new/Controller.C	2016-08-03 20:10:41.245074371 -0500
@@ -184,6 +184,10 @@
     random->split(0,PatchMap::Object()->numPatches()+1);
 
     rescaleVelocities_sumTemps = 0;  rescaleVelocities_numTemps = 0;
+    rescaleVelocities_sum1     = 0;
+    rescaleVelocities_sumBeta  = 0;
+    rescaleVelocities_sumBeta2 = 0;
+    rescaleVelocities_sumDbde  = 0;
     berendsenPressure_avg = 0; berendsenPressure_count = 0;
     // strainRate tensor is symmetric to avoid rotation
     langevinPiston_strainRate =
@@ -406,15 +410,23 @@
       slowFreq = simParams->nonbondedFrequency;
     if ( step >= numberOfSteps ) slowFreq = nbondFreq = 1;
 
+    langRescaleFactorPrev = 1;
+    tNHCInit();
+    rescaleVelocitiesInit();
+
   if ( scriptTask == SCRIPT_RUN ) {
 
     reassignVelocities(step);  // only for full-step velecities
     rescaleaccelMD(step);
-    adaptTempUpdate(step); // Init adaptive tempering;
 
     receivePressure(step);
     if ( zeroMomentum && dofull && ! (step % slowFreq) )
 						correctMomentum(step);
+    // they shouldn't be called
+    //langRescaleVelocities(step, TRUE);
+    //tNHCRescaleVelocities(step, TRUE);
+    adaptTempUpdate(step); // Init adaptive tempering;
+
     printFepMessage(step);
     printTiMessage(step);
     printDynamicsEnergies(step);
@@ -429,6 +441,11 @@
     rebalanceLoad(step);
 
   }
+    keHistInit();
+    FILE *fpEnergyLog = NULL;
+    if ( simParams->energyLogFreq > 0 ) {
+      fpEnergyLog = fopen(simParams->energyLogFile, "a");
+    }
 
     // Handling SIGINT doesn't seem to be working on Lemieux, and it
     // sometimes causes the net-xxx versions of NAMD to segfault on exit, 
@@ -437,9 +454,10 @@
     //  (namd_sighandler_t)my_sigint_handler);
     for ( ++step ; step <= numberOfSteps; ++step )
     {
-        adaptTempUpdate(step);
         rescaleVelocities(step);
 	tcoupleVelocities(step);
+	langRescaleVelocities(step, FALSE);
+	tNHCRescaleVelocities(step, FALSE);
 	berendsenPressure(step);
 	langevinPiston1(step);
         rescaleaccelMD(step);
@@ -449,7 +467,18 @@
 						correctMomentum(step);
 	langevinPiston2(step);
         reassignVelocities(step);
+	
+        langRescaleVelocities(step, TRUE);
+        tNHCRescaleVelocities(step, TRUE);
+        Bool scaled = adaptTempUpdate(step);
+        keHistUpdate(step);
         printDynamicsEnergies(step);
+        if ( fpEnergyLog && step % simParams->energyLogFreq == 0 ) {
+          fprintf(fpEnergyLog, "%d %g", step, totalEnergy - kineticEnergy);
+          if ( simParams->adaptTempOn )
+            fprintf(fpEnergyLog, " %g", adaptTempT);
+          fprintf(fpEnergyLog, "\n");
+        }
         outputFepEnergy(step);
         outputTiEnergy(step);
         if(traceIsOn()){
@@ -493,7 +522,11 @@
 		}
 	}
 #endif
-	 
+        if ( scaled && (ldbSteps == 1 || LdbCoordinator::Object()->getNumStepsToRun() == 1) ) {
+          // collect Hi's if we're about to rebalance load
+          collection->enqueueHi(step);
+        }
+	//if ( ldbSteps == 1 ) CkPrintf("step %d, before rebalanceLoad(), Controller PE %d/%d, thread %p\n", step, CkMyPe(), CkNumPes(), CthSelf());
         rebalanceLoad(step);
 
 #if  PME_BARRIER
@@ -501,6 +534,11 @@
 #endif
     }
     // signal(SIGINT, oldhandler);
+    
+    rescaleVelocitiesSave(step);
+    if ( fpEnergyLog != NULL ) fclose(fpEnergyLog);
+    tNHCDone(step);
+    keHistDone(step);
 }
 
 
@@ -1016,6 +1054,12 @@
   const int rescaleFreq = simParams->rescaleFreq;
   if ( rescaleFreq > 0 ) {
     rescaleVelocities_sumTemps += temperature;  ++rescaleVelocities_numTemps;
+    BigReal ek = BOLTZMANN * temperature * numDegFreedom;
+    BigReal beta = (numDegFreedom - 2.0) / ek;
+    rescaleVelocities_sum1     += 1;
+    rescaleVelocities_sumBeta  += beta;
+    rescaleVelocities_sumBeta2 += beta * beta;
+    rescaleVelocities_sumDbde  += -beta / ek;
     if ( rescaleVelocities_numTemps == rescaleFreq ) {
       BigReal avgTemp = rescaleVelocities_sumTemps / rescaleVelocities_numTemps;
       BigReal rescaleTemp = simParams->rescaleTemp;
@@ -1024,6 +1068,35 @@
         rescaleTemp = adaptTempT;
       }
       BigReal factor = sqrt(rescaleTemp/avgTemp);
+      if ( simParams->rescaleAdaptiveOn ) {
+        // recompute the velocity-rescaling factor
+        BigReal bref = 1.0 / (BOLTZMANN * rescaleTemp);
+        BigReal dbeta = bref - beta;
+        BigReal dbdk = rescaleVelocities_sumDbde / rescaleVelocities_sum1;
+        BigReal bet = rescaleVelocities_sumBeta / rescaleVelocities_sum1;
+        BigReal bet2 = rescaleVelocities_sumBeta2 / rescaleVelocities_sum1 - bet * bet;
+        BigReal dbde;
+        if ( simParams->rescaleAdaptiveDedk > 0 ) { // heuristic method
+          dbde = dbdk / simParams->rescaleAdaptiveDedk;
+        } else { // exact method
+          if ( rescaleVelocities_numTemps < 10 ) {
+            dbde = dbdk;
+          } else {
+            dbde = dbdk + bet2;
+            if ( dbde > 0.01 * dbdk ) dbde = 0.01 * dbdk;
+          }
+        }
+        BigReal de = dbeta/dbde;
+        BigReal s = (de / ek) * simParams->rescaleFreq / rescaleVelocities_sum1;
+        if ( s > 0.5 ) s = 0.5;
+        else if ( s < -0.5 ) s = -0.5;
+        factor = sqrt(1 + s);
+        if ( fmod(rescaleVelocities_sum1, simParams->rescaleAdaptiveFileFreq) < 0.5 ) {
+          CkPrintf("step %d, factor %g, s %g, bet %g/%g, dbde %g/%g, bet2 %g, delE/K %g, tp %g\n",
+              step, factor, s, bet, bref, dbde, dbdk, bet2, de/ek, temperature); // getchar();
+          rescaleVelocitiesSave(step);
+        }
+      }
       broadcast->velocityRescaleFactor.publish(step,factor);
       //iout << "RESCALING VELOCITIES AT STEP " << step
       //     << " FROM AVERAGE TEMPERATURE OF " << avgTemp
@@ -1033,6 +1106,56 @@
   }
 }
 
+void Controller::rescaleVelocitiesInit(void)
+{
+  if ( numDegFreedom <= 0 )
+    numDegFreedom = Node::Object()->molecule->num_deg_freedom();
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  rescaleVelocitiesLoad();
+}
+
+void Controller::rescaleVelocitiesLoad(void)
+{
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  std::ifstream fs(simParams->rescaleAdaptiveFile);
+  if ( !fs ) return;
+  double cnt, beta, beta2, dbde;
+  fs >> cnt >> beta >> beta2 >> dbde;
+  fs.close();
+  iout << "LOADED ADAPTIVE VELOCITY-RESCALING DATA FROM "
+       << simParams->rescaleAdaptiveFile << ": STEP " << cnt
+       << ", BETA " << beta << ", VAR(BETA) " << beta2
+       << ", BETA'(E) " << dbde << "\n" << endi;
+  beta2 += beta * beta;
+  if ( fmod(cnt, simParams->rescaleFreq) > 0.5 ) {
+    cnt = cnt / simParams->rescaleFreq * simParams->rescaleFreq;
+  }
+  rescaleVelocities_sum1 = cnt;
+  rescaleVelocities_sumBeta = cnt * beta;
+  rescaleVelocities_sumBeta2 = cnt * beta2;
+  rescaleVelocities_sumDbde = cnt * dbde;
+}
+
+void Controller::rescaleVelocitiesSave(int step)
+{
+  if ( simParams->rescaleFreq <= 0 || !simParams->rescaleAdaptiveOn )
+    return;
+  if ( rescaleVelocities_sum1 <= 0 )
+    return;
+  NAMD_backup_file(simParams->rescaleAdaptiveFile);
+  ofstream_namd fs(simParams->rescaleAdaptiveFile);
+  if ( !fs ) return;
+  BigReal beta = rescaleVelocities_sumBeta / rescaleVelocities_sum1;
+  BigReal beta2 = rescaleVelocities_sumBeta2 / rescaleVelocities_sum1
+                - beta * beta;
+  BigReal dbde = rescaleVelocities_sumDbde / rescaleVelocities_sum1;
+  char buf[200];
+  sprintf(buf, "%.0f %.10f %.10f %.10f\n", rescaleVelocities_sum1, beta, beta2, dbde);
+  fs << buf;
+}
+
 void Controller::correctMomentum(int step) {
 
     Vector momentum;
@@ -1110,6 +1233,279 @@
   }
 }
 
+// Ref.: Canonical sampling through velocity rescaling
+// Bussi, Donadio, and Parrinello, JCP 126, 014101 (2007)
+void Controller::langRescaleVelocities(int step, Bool isPrev)
+{
+  if ( simParams->langRescaleOn ) {
+    BigReal tp = simParams->langRescaleTemp;
+    // use the temperature from adaptive tempering, if any
+    if ( simParams->adaptTempOn && simParams->adaptTempRescale
+     && (step > simParams->adaptTempFirstStep )
+     && (!(simParams->adaptTempLastStep > 0) || step < simParams->adaptTempLastStep )) {
+      tp = adaptTempT;
+    }
+    tp *= BOLTZMANN;
+
+    BigReal dt = simParams->dt / simParams->langRescaleDt;
+    dt *= 0.5; // doing a half time step, called twice in an MD step
+    BigReal c = exp(-dt);
+
+    // integrate two half steps
+    int dof = numDegFreedom;
+    if ( dof <= 0 ) dof = Node::Object()->molecule->num_deg_freedom();
+    BigReal r = random->gaussian();
+    BigReal r2 = random->chisqr(dof - 1);
+    BigReal ek1 = BOLTZMANN * temperature * dof * 0.5;
+    BigReal ek2 = ek1 + (1 - c) * ((r2 + r * r) * 0.5 * tp - ek1)
+                + 2 * r * sqrt(c * (1 - c) * ek1 * 0.5 * tp);
+    if ( ek2 < 0 ) ek2 = 0;
+    BigReal fac2 = ek2 / ek1;
+    BigReal factor = sqrt( fac2 );
+    if ( !isPrev ) {
+      // combine with the rescaling factor carried from
+      // the second half-step from the previous MD step
+      broadcast->langRescaleFactor.publish(step, factor * langRescaleFactorPrev);
+    } else {
+      // save it for the rescaling in the next step
+      langRescaleFactorPrev = factor;
+    }
+    temperature *= fac2;
+    totalEnergy += kineticEnergy * (fac2 - 1);
+    kineticEnergy *= fac2;
+    kineticEnergyCentered *= fac2;
+  }
+}
+
+void Controller::tNHCInit(void)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int nnhc = simParams->tNHCLen, i;
+  tNHCzeta = new BigReal [nnhc];
+  tNHCmass = new BigReal [nnhc];
+
+  // Note: numDegFreedom has not been set yet
+  int dof = Node::Object()->molecule->num_deg_freedom();
+  BigReal per = simParams->tNHCPeriod / (2 * M_PI);
+  BigReal kT = BOLTZMANN * simParams->tNHCTemp;
+  // reference mass choices, see Appendix B of JCP 97 (4) 2635
+  BigReal mass2 = per * per * kT;
+  BigReal mass1 = mass2 * dof;
+
+  for ( i = 0; i < nnhc; i++ ) {
+    tNHCzeta[i] = 0;
+    tNHCmass[i] = ( i == 0 ) ? mass1 : mass2;
+  }
+
+  // try to load the chain variables, ok if it fails
+  tNHCLoad();
+  CkPrintf("NHC %d, mass1 %g, mass2 %g\n", dof, mass1, mass2);
+  for ( i = 0; i < nnhc; i++ )
+    CkPrintf("NHC %d: zeta %g, mass %g\n", i+1, tNHCzeta[i], tNHCmass[i]);
+  tNHCRescaleFactorPrev = 1.0;
+}
+
+void Controller::tNHCDone(int step)
+{
+  if ( simParams->tNHCOn ) {
+    tNHCSave(step);
+    delete[] tNHCzeta;
+    delete[] tNHCmass;
+  }
+}
+
+// Nose-Hoover chain thermostat
+// Ref.: Nose-Hoover chains: The canonical ensemble via continuous dynamics 
+// Glenn J. Martyna, Michael L. Klein, and Mark Tuckerman, JCP 97 (4) 2635
+void Controller::tNHCRescaleVelocities(int step, Bool isPrev)
+{
+  if ( simParams->tNHCOn ) {
+    BigReal tp = simParams->tNHCTemp;
+    // use the temperature from adaptive tempering, if any
+    if ( simParams->adaptTempOn && simParams->adaptTempRescale
+     && (step > simParams->adaptTempFirstStep )
+     && (!(simParams->adaptTempLastStep > 0) || step < simParams->adaptTempLastStep )) {
+      tp = adaptTempT;
+    }
+    tp *= BOLTZMANN;
+
+    Real dt = simParams->dt * 0.5; // only for half step
+    int dof = numDegFreedom;
+    if ( dof <= 0 ) dof = Node::Object()->molecule->num_deg_freedom();
+    int nnhc = simParams->tNHCLen, i, j, k;
+    BigReal s, GQ, mvv, factor;
+
+    mvv = BOLTZMANN * temperature * dof;
+    for ( j = nnhc - 1; j >= 0; j-- ) {
+      s = ( j == nnhc - 1 ) ? 1 : exp(-tNHCzeta[j+1]*dt*0.25);
+      if ( j == 0 ) {
+        GQ = mvv - dof * tp;
+      } else {
+        GQ = tNHCmass[j-1] * tNHCzeta[j-1] * tNHCzeta[j-1] - tp;
+      }
+      tNHCzeta[j] = (tNHCzeta[j] * s + GQ /tNHCmass[j] * dt*0.5) * s;
+    }
+
+    // velocity rescaling factor
+    factor = exp( -tNHCzeta[0] * dt );
+    if ( !isPrev ) {
+      // combine with the rescaling factor carried from
+      // the second half-step from the previous MD step
+      broadcast->tNHCRescaleFactor.publish(step, factor * tNHCRescaleFactorPrev);
+    } else {
+      tNHCRescaleFactorPrev = factor;
+    }
+
+    BigReal fac2 = factor * factor;
+    temperature *= fac2;
+    totalEnergy += kineticEnergy * (fac2 - 1);
+    kineticEnergy *= fac2;
+    kineticEnergyCentered *= fac2;
+    mvv *= fac2;
+
+    for ( j = 0; j < nnhc; j++ ) {
+      s = ( j == nnhc - 1 ) ? 1 : exp(-tNHCzeta[j+1]*dt*0.25);
+      if ( j == 0 ) {
+        GQ = mvv - dof * tp;
+      } else {
+        GQ = tNHCmass[j-1] * tNHCzeta[j-1] * tNHCzeta[j-1] - tp;
+      }
+      tNHCzeta[j] = (tNHCzeta[j] * s + GQ /tNHCmass[j] * dt*0.5) * s;
+    }
+
+    if ( simParams->tNHCFileFreq > 0 && step % simParams->tNHCFileFreq == 0 )
+      tNHCSave(step);
+  }
+}
+
+void Controller::tNHCSave(int step)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int i, nnhc = simParams->tNHCLen;
+  NAMD_backup_file(simParams->tNHCFile);
+  ofstream_namd fs(simParams->tNHCFile);
+  if ( !fs ) {
+    iout << "Error: cannot write " << simParams->tNHCFile << "\n" << endi;
+    return;
+  }
+  fs << nnhc << " " << step << "\n";
+  for ( i = 0; i < nnhc; i++ )
+    fs << tNHCzeta[i] << " ";
+  fs << "\n";
+  for ( i = 0; i < nnhc; i++ )
+    fs << tNHCmass[i] << " ";
+  fs << "\n";
+}
+
+void Controller::tNHCLoad(void)
+{
+  if ( !simParams->tNHCOn ) return;
+
+  int i, nnhc, step;
+  std::ifstream fs(simParams->tNHCFile);
+  if ( !fs ) {
+    iout << "Cannot read " << simParams->tNHCFile << "\n" << endi;
+    return;
+  }
+  fs >> nnhc >> step;
+  if ( nnhc != simParams->tNHCLen ) {
+    iout << "Error: NH-chain length mismatch " << nnhc
+         << " vs. " << simParams->tNHCLen << "\n" << endi;
+    return;
+  }
+  for ( i = 0; i < nnhc; i++ )
+    fs >> tNHCzeta[i];
+
+  if ( simParams->tNHCFileReadMass ) {
+    for ( i = 0; i < nnhc; i++ )
+      fs >> tNHCmass[i];
+  }
+  fs.close();
+}
+
+void Controller::keHistInit(void)
+{
+  if ( !simParams->keHistOn ) return;
+  BigReal keHistTemp = simParams->thermostatTemp();
+  BigReal ke = BOLTZMANN * keHistTemp * numDegFreedom / 2;
+  keHistBinMax = (int) (5.0 * ke / simParams->keHistBin);
+  CkPrintf("keHistInit: temperature %g, dof %d, keHistBinMax %d\n", keHistTemp, numDegFreedom, keHistBinMax);
+  keHist = new BigReal [keHistBinMax];
+  int i;
+  for ( i = 0; i < keHistBinMax; i++ ) keHist[i] = 0;
+  keHistLoad(); // try to load the previous histogram
+}
+
+void Controller::keHistUpdate(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  BigReal ke = BOLTZMANN * temperature * numDegFreedom / 2;
+  if ( simParams->adaptTempOn ) {
+    ke *= simParams->thermostatTemp() / adaptTempT;
+  }
+  int i = (int) ( ke / simParams->keHistBin );
+  if ( i < keHistBinMax ) keHist[i] += 1;
+  if ( step > 0 && step % simParams->keHistFileFreq == 0 ) {
+    keHistSave(step);
+  }
+}
+
+void Controller::keHistSave(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  NAMD_backup_file(simParams->keHistFile);
+  ofstream_namd fs(simParams->keHistFile);
+  if ( !fs ) return;
+  fs << "# " << numDegFreedom << " " << step << "\n";
+  int i;
+  BigReal tot = 0;
+  for ( i = 0; i < keHistBinMax; i++ )
+    tot += keHist[i];
+
+  // normalization of the reference curve
+  BigReal norm = (numDegFreedom % 2) ? 0.5 * log(M_PI) : 0;
+  for ( i = 2 - numDegFreedom % 2; i < numDegFreedom; i += 2 )
+    norm += log(i*0.5);
+  BigReal tp = simParams->thermostatTemp() * BOLTZMANN;
+  BigReal dk = simParams->keHistBin;
+  for ( i = 0; i < keHistBinMax; i++ ) {
+    if ( keHist[i] <= 0 ) continue;
+    double hist = keHist[i] / ( dk * tot );
+    double ke = (i + 0.5) * dk;
+    double histref = exp(log(ke/tp) * (numDegFreedom*0.5-1) -ke/tp - norm) / tp;
+    fs << (i + 0.5) * dk << "\t" << hist << "\t" << histref << "\t" << keHist[i] << "\n";
+  }
+}
+
+void Controller::keHistLoad(void)
+{
+  if ( !simParams->keHistOn ) return;
+  std::ifstream fs(simParams->keHistFile);
+  if ( !fs ) return;
+  std::string buf;
+
+  std::getline(fs, buf);
+  while ( fs.good() ) {
+    double ke, hist1, hist2, hist;
+    std::getline(fs, buf);
+    sscanf(buf.c_str(), "%lf%lf%lf%lf", &ke, &hist1, &hist2, &hist);
+    int i = (int) (ke / simParams->keHistBin);
+    keHist[i] = hist;
+  }
+  fs.close();
+  iout << "Loaded previous histogram from "
+       << simParams->keHistFile << ".\n" << endi;
+}
+
+void Controller::keHistDone(int step)
+{
+  if ( !simParams->keHistOn ) return;
+  keHistSave(step);
+  delete[] keHist;
+}
+
 static char *FORMAT(BigReal X)
 {
   static char tmp_string[25];
@@ -1571,13 +1967,37 @@
    }
 }
 
+// compute window boundaries
+void Controller::adaptTempMakeWin(void)
+{
+    adaptTempBinMinus  = new int[adaptTempBins];
+    adaptTempBinPlus   = new int[adaptTempBins];
+    adaptTempInvW      = new BigReal[adaptTempBins];
+    for ( int j = 0; j < adaptTempBins; j++ ) {
+        // compute the window boundary
+        BigReal betaMid = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+        BigReal deltaBeta = betaMid * simParams->adaptTempWindowSize;
+        int deltaBins = (int) (deltaBeta / adaptTempDBeta + 0.5);
+        // adjust the window size such that it does not exceed the boundary
+        if ( j - deltaBins < 0 ) {
+          deltaBins = j;
+        }
+        if ( j + deltaBins + 1 > adaptTempBins ) {
+          deltaBins = adaptTempBins - j - 1;
+        }
+        adaptTempBinMinus[j] = j - deltaBins;
+        adaptTempBinPlus[j] = j + deltaBins + 1;
+        adaptTempInvW[j] = betaMid;
+    }
+}
+
 void Controller::adaptTempInit(int step) {
     if (!simParams->adaptTempOn) return;
     iout << iINFO << "INITIALISING ADAPTIVE TEMPERING\n" << endi;
     adaptTempDtMin = 0;
     adaptTempDtMax = 0;
     adaptTempAutoDt = false;
-    if (simParams->adaptTempBins == 0) {
+    if (simParams->adaptTempInFile[0] != '\0') {
       iout << iINFO << "READING ADAPTIVE TEMPERING RESTART FILE\n" << endi;
       std::ifstream adaptTempRead(simParams->adaptTempInFile);
       if (adaptTempRead) {
@@ -1607,17 +2027,59 @@
         adaptTempPotEnergyVarNum = new BigReal[adaptTempBins];
         adaptTempPotEnergyVar    = new BigReal[adaptTempBins];
         adaptTempPotEnergyAve    = new BigReal[adaptTempBins];
-        adaptTempBetaN           = new BigReal[adaptTempBins];
+        adaptTempBetaN           = new BigReal[adaptTempBins + 1];
         adaptTempDBeta = (adaptTempBetaMax - adaptTempBetaMin)/(adaptTempBins);
         for(int j = 0; j < adaptTempBins; ++j) {
+          adaptTempRead >> readReal;
           adaptTempRead >> adaptTempPotEnergyAve[j];
           adaptTempRead >> adaptTempPotEnergyVar[j];
           adaptTempRead >> adaptTempPotEnergySamples[j];
           adaptTempRead >> adaptTempPotEnergyAveNum[j];
           adaptTempRead >> adaptTempPotEnergyVarNum[j];
           adaptTempRead >> adaptTempPotEnergyAveDen[j];
+        }
+        for ( int j = 0; j <= adaptTempBins; ++j ) {
           adaptTempBetaN[j] = adaptTempBetaMin + j * adaptTempDBeta;
         } 
+        adaptTempMakeWin();
+        // read in data for separate accumulators
+        if ( simParams->adaptTempSepOn ) {
+          char buf[2048], info[256];
+          adaptTempRead.getline(buf, sizeof buf);
+          adaptTempRead.getline(buf, sizeof buf);
+          if ( strncmp(buf, "SEP BEGIN", 9) != 0 ) {
+            sprintf(info, "Broken input for separate accumulators beginning\n");
+            NAMD_die(info);
+          }
+          adaptTempSepAcc = new AdaptTempSepAcc[adaptTempBins];
+          // loop over each accumulator
+          int i, j, i1, j1;
+          BigReal total;
+          for ( i = 0; i < adaptTempBins; i++ ) {
+            AdaptTempSepAcc *acc = adaptTempSepAcc + i;
+            adaptTempRead.getline(buf, sizeof buf);
+            if ( 4 != sscanf(buf, "%d%d%d%g", &i1, &adaptTempBinMinus[i], &adaptTempBinPlus[i], &total) ) {
+              sprintf(info, "Broken info for estimator %d, file %s\n", i, simParams->adaptTempInFile);
+              NAMD_die(info);
+            }
+            acc->init(adaptTempBinMinus[i], adaptTempBinPlus[i]);
+            for ( j = 0; j < acc->winSize; j++ ) {
+              adaptTempRead.getline(buf, sizeof buf);
+              if ( 4 != sscanf(buf, "%d%g%g%g\n", &j1, &acc->count[j], &acc->ave[j], &acc->var[j]) ) {
+                sprintf(info, "Broken member %d/%d for estimator %d, file %s\n", j, acc->winSize, i, simParams->adaptTempInFile);
+                NAMD_die(info);
+              }
+              acc->sumE[j] = acc->count[j] * acc->ave[j];
+              acc->sumE2[j] = acc->count[j] * (acc->var[j] + acc->ave[j] * acc->ave[j]);
+            }
+            adaptTempRead.getline(buf, sizeof buf);
+          }
+          adaptTempRead.getline(buf, sizeof buf);
+          if ( strncmp(buf, "SEP END", 7) != 0 ) {
+            sprintf(buf, "Broken input for separator accumulators ending\n");
+            NAMD_die(buf);
+          }
+        }
         adaptTempRead.close();
       }
       else NAMD_die("Could not open ADAPTIVE TEMPERING restart file.\n");
@@ -1630,17 +2092,13 @@
       adaptTempPotEnergyVarNum = new BigReal[adaptTempBins];
       adaptTempPotEnergyVar    = new BigReal[adaptTempBins];
       adaptTempPotEnergyAve    = new BigReal[adaptTempBins];
-      adaptTempBetaN           = new BigReal[adaptTempBins];
+      adaptTempBetaN           = new BigReal[adaptTempBins + 1];
       adaptTempBetaMax = 1./simParams->adaptTempTmin;
       adaptTempBetaMin = 1./simParams->adaptTempTmax;
       adaptTempCg = simParams->adaptTempCgamma;   
       adaptTempDt  = simParams->adaptTempDt;
       adaptTempDBeta = (adaptTempBetaMax - adaptTempBetaMin)/(adaptTempBins);
-      adaptTempT = simParams->initialTemp; 
-      if (simParams->langevinOn)
-        adaptTempT = simParams->langevinTemp;
-      else if (simParams->rescaleFreq > 0)
-        adaptTempT = simParams->rescaleTemp;
+      adaptTempT = simParams->thermostatTemp();
       for(int j = 0; j < adaptTempBins; ++j){
           adaptTempPotEnergyAveNum[j] = 0.;
           adaptTempPotEnergyAveDen[j] = 0.;
@@ -1648,8 +2106,17 @@
           adaptTempPotEnergyVarNum[j] = 0.;
           adaptTempPotEnergyVar[j] = 0.;
           adaptTempPotEnergyAve[j] = 0.;
+      }
+      for ( int j = 0; j <= adaptTempBins; ++j ) {
           adaptTempBetaN[j] = adaptTempBetaMin + j * adaptTempDBeta;
       }
+      adaptTempMakeWin();
+      // initialize the separate accumulators
+      if ( simParams->adaptTempSepOn ) {
+        adaptTempSepAcc = new AdaptTempSepAcc[adaptTempBins];
+        for ( int i = 0; i < adaptTempBins; ++i )
+          adaptTempSepAcc[i].init(adaptTempBinMinus[i], adaptTempBinPlus[i]);
+      }
     }
     if (simParams->adaptTempAutoDt > 0.0) {
        adaptTempAutoDt = true;
@@ -1673,7 +2140,9 @@
 
 void Controller::adaptTempWriteRestart(int step) {
     if (simParams->adaptTempOn && !(step%simParams->adaptTempRestartFreq)) {
-        adaptTempRestartFile.seekp(std::ios::beg);        
+        if ( !simParams->adaptTempRestartAppend ) {
+          adaptTempRestartFile.seekbegin();
+        }
         iout << "ADAPTEMP: WRITING RESTART FILE AT STEP " << step << "\n" << endi;
         adaptTempRestartFile << step << " ";
         // Start with min and max temperatures
@@ -1685,6 +2154,7 @@
         adaptTempRestartFile << adaptTempDt ;
         adaptTempRestartFile << "\n" ;
         for(int j = 0; j < adaptTempBins; ++j) {
+          adaptTempRestartFile << adaptTempBetaN[j] << " ";
           adaptTempRestartFile << adaptTempPotEnergyAve[j] << " ";
           adaptTempRestartFile << adaptTempPotEnergyVar[j] << " ";
           adaptTempRestartFile << adaptTempPotEnergySamples[j] << " ";
@@ -1693,21 +2163,44 @@
           adaptTempRestartFile << adaptTempPotEnergyAveDen[j] << " ";
           adaptTempRestartFile << "\n";          
         }
+        // data for separator accumulators
+        if ( simParams->adaptTempSepOn ) {
+          char s[1024];
+          int i, j;
+
+          adaptTempRestartFile << "SEP BEGIN\n";
+          // loop over each accumulator
+          for ( i = 0; i < adaptTempBins; i++ ) {
+            AdaptTempSepAcc *acc = adaptTempSepAcc + i;
+            acc->trim();
+            sprintf(s, "%d %d %d %g\n", i,
+                adaptTempBinMinus[i], adaptTempBinPlus[i], acc->total);
+            adaptTempRestartFile << s;
+            for ( j = 0; j < acc->winSize; j++ ) {
+              sprintf(s, "%d %g %g %g\n", j, acc->count[j],
+                  acc->ave[j], acc->var[j]);
+              adaptTempRestartFile << s;
+            }
+            adaptTempRestartFile << "\n";
+          }
+          adaptTempRestartFile << "SEP END\n";
+        }
         adaptTempRestartFile.flush(); 
     }
 }    
 
-void Controller::adaptTempUpdate(int step, int minimize)
+Bool Controller::adaptTempUpdate(int step, int minimize)
 {
+    Bool scaled = FALSE;
     //Beta = 1./T
-    if ( !simParams->adaptTempOn ) return;
+    if ( !simParams->adaptTempOn ) return scaled;
     int j = 0;
     if (step == simParams->firstTimestep) {
         adaptTempInit(step);
-        return;
+        return scaled;
     }
     if ( minimize || (step < simParams->adaptTempFirstStep ) || 
-        ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) return;
+        ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) return scaled;
     const int adaptTempOutFreq  = simParams->adaptTempOutFreq;
     const bool adaptTempDebug  = simParams->adaptTempDebug;
     //Calculate Current inverse temperature and bin 
@@ -1720,13 +2213,49 @@
                               << " adaptTempDBeta: " << adaptTempDBeta 
                                << " betaMin:" << adaptTempBetaMin 
                                << " betaMax: " << adaptTempBetaMax << "\n";
+    if ( adaptTempBin < 0 ) {
+      adaptTempBin = 0;
+    } else if ( adaptTempBin >= adaptTempBins ) {
+      adaptTempBin = adaptTempBins - 1;
+    }
     adaptTempPotEnergySamples[adaptTempBin] += 1;
     BigReal gammaAve = 1.-adaptTempCg/adaptTempPotEnergySamples[adaptTempBin];
+    if ( gammaAve < 0 ) gammaAve = 0;
 
     BigReal potentialEnergy;
     BigReal potEnergyAverage;
     BigReal potEnergyVariance;
-    potentialEnergy = totalEnergy-kineticEnergy;
+
+    // recompute the potential energy
+    BigReal bondEnergy = reduction->item(REDUCTION_BOND_ENERGY);
+    BigReal angleEnergy = reduction->item(REDUCTION_ANGLE_ENERGY);
+    BigReal dihedralEnergy = reduction->item(REDUCTION_DIHEDRAL_ENERGY);
+    BigReal improperEnergy = reduction->item(REDUCTION_IMPROPER_ENERGY);
+    BigReal crosstermEnergy = reduction->item(REDUCTION_CROSSTERM_ENERGY);
+    BigReal boundaryEnergy = reduction->item(REDUCTION_BC_ENERGY);
+    BigReal miscEnergy = reduction->item(REDUCTION_MISC_ENERGY);
+    if ( step % nbondFreq == 0 ) {
+      electEnergy = reduction->item(REDUCTION_ELECT_ENERGY);
+      ljEnergy = reduction->item(REDUCTION_LJ_ENERGY);
+      BigReal volume = state->lattice.volume();
+      if (simParams->LJcorrection && volume) {
+        // Apply tail correction to energy
+        ljEnergy += Node::Object()->molecule->tail_corr_ener / volume;
+      }
+      groLJEnergy = reduction->item(REDUCTION_GRO_LJ_ENERGY);
+      groGaussEnergy = reduction->item(REDUCTION_GRO_GAUSS_ENERGY);
+      goNativeEnergy = reduction->item(REDUCTION_GO_NATIVE_ENERGY);
+      goNonnativeEnergy = reduction->item(REDUCTION_GO_NONNATIVE_ENERGY);
+      goTotalEnergy = goNativeEnergy + goNonnativeEnergy;
+    }
+    if ( step % slowFreq == 0 ) {
+      electEnergySlow = reduction->item(REDUCTION_ELECT_ENERGY_SLOW);
+    }
+    potentialEnergy = bondEnergy + angleEnergy + dihedralEnergy
+	+ improperEnergy + electEnergy + electEnergySlow + ljEnergy
+	+ crosstermEnergy + boundaryEnergy + miscEnergy
+        + goTotalEnergy + groLJEnergy + groGaussEnergy;
+    totalEnergy = potentialEnergy + kineticEnergy;
 
     //calculate new bin average and variance using adaptive averaging
     adaptTempPotEnergyAveNum[adaptTempBin] = adaptTempPotEnergyAveNum[adaptTempBin]*gammaAve + potentialEnergy;
@@ -1740,110 +2269,113 @@
     adaptTempPotEnergyAve[adaptTempBin] = potEnergyAverage;
     adaptTempPotEnergyVar[adaptTempBin] = potEnergyVariance;
     
+    if ( simParams->adaptTempSepOn ) {
+      for ( j = adaptTempBin; j >= 0; j-- ) { // search downward
+        if ( adaptTempBinPlus[j] <= adaptTempBin ) break;
+        adaptTempSepAcc[j].add(adaptTempBin, potentialEnergy, adaptTempCg);
+      }
+      for ( j = adaptTempBin + 1; j < adaptTempBins; j++ ) { // search upward
+        if ( adaptTempBinMinus[j] > adaptTempBin ) break;
+        adaptTempSepAcc[j].add(adaptTempBin, potentialEnergy, adaptTempCg);
+      }
+    }
+
     // Weighted integral of <Delta E^2>_beta dbeta <= Eq 4 of JCP 132 244101
     // Integrals of Eqs 5 and 6 is done as piecewise assuming <Delta E^2>_beta
     // is constant for each bin. This is to estimate <E(beta)> where beta \in
     // (beta_i,beta_{i+1}) using Eq 2 of JCP 132 244101
     if ( ! ( step % simParams->adaptTempFreq ) ) {
-      // If adaptTempBin not at the edge, calculate improved average:
-      if (adaptTempBin > 0 && adaptTempBin < adaptTempBins-1) {
+     const BigReal varDenMin = simParams->adaptTempFreq * 10;
+     if ( simParams->adaptTempSepOn ) {
+       potEnergyAverage = adaptTempSepAcc[adaptTempBin].iiave(adaptTempInvW, varDenMin);
+     } else {
+      int j;
           // Get Averaging Limits:
-          BigReal deltaBeta = 0.04*adaptTempBeta; //0.08 used in paper - make variable
-          BigReal betaPlus;
-          BigReal betaMinus;
-          int     nMinus =0;
-          int     nPlus = 0;
-          if ( adaptTempBeta-adaptTempBetaMin < deltaBeta ) deltaBeta = adaptTempBeta-adaptTempBetaMin;
-          if ( adaptTempBetaMax-adaptTempBeta < deltaBeta ) deltaBeta = adaptTempBetaMax-adaptTempBeta;
-          betaMinus = adaptTempBeta - deltaBeta;
-          betaPlus =  adaptTempBeta + deltaBeta;
-          BigReal betaMinus2 = betaMinus*betaMinus;
-          BigReal betaPlus2  = betaPlus*betaPlus;
-          nMinus = (int)floor((betaMinus-adaptTempBetaMin)/adaptTempDBeta);
-          nPlus  = (int)floor((betaPlus-adaptTempBetaMin)/adaptTempDBeta);
+      int nMinus = adaptTempBinMinus[adaptTempBin];
+      int nPlus  = adaptTempBinPlus[adaptTempBin];
           // Variables for <E(beta)> estimate:
           BigReal potEnergyAve0 = 0.0;
           BigReal potEnergyAve1 = 0.0;
+      BigReal potEnergyDen0 = 0.0;
+      BigReal potEnergyDen1 = 0.0;
           // Integral terms
-          BigReal A0 = 0;
-          BigReal A1 = 0;
-          BigReal A2 = 0;
+      BigReal A0 = 0; // Sum_{from beta_minus to beta_{i+1} }
+                      //   (beta - beta_minus)/(beta_{i+1} - beta_minus) var(E)
+      BigReal A1 = 0; // Sum_{from beta_{i+1} to beta_plus }
+                      //   (beta - beta_plus) /(beta_plus  - beta_{i+1}) var(E)
+      BigReal A2 = 0; // 0.5 * DBeta * var(E) at bin i
           //A0 phi_s integral for beta_minus < beta < beta_{i+1}
-          BigReal betaNp1 = adaptTempBetaN[adaptTempBin+1]; 
-          BigReal DeltaE2Ave;
-          BigReal DeltaE2AveSum = 0;
-          BigReal betaj;
-          for (j = nMinus+1; j <= adaptTempBin; ++j) {
-              potEnergyAve0 += adaptTempPotEnergyAve[j]; 
-              DeltaE2Ave = adaptTempPotEnergyVar[j];
-              DeltaE2AveSum += DeltaE2Ave;
-              A0 += j*DeltaE2Ave;
+
+      // compute the default variance for lack of data
+      BigReal denMax = 0, defVar = 0;
+      for ( j = nMinus; j < nPlus; j++ ) {
+        if ( adaptTempPotEnergyAveDen[j] > denMax ) {
+          denMax = adaptTempPotEnergyAveDen[j];
+          defVar = adaptTempPotEnergyVar[j];
           }
-          A0 *= adaptTempDBeta;
-          A0 += (adaptTempBetaMin+0.5*adaptTempDBeta-betaMinus)*DeltaE2AveSum;
-          A0 *= adaptTempDBeta;
-          betaj = adaptTempBetaN[nMinus+1]-betaMinus; 
-          betaj *= betaj;
-          A0 += 0.5*betaj*adaptTempPotEnergyVar[nMinus];
-          A0 /= (betaNp1-betaMinus);
+      }
+
+      BigReal invwj, var;
+      for ( j = nMinus; j <= adaptTempBin; j++ ) {
+        invwj = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+        potEnergyAve0 += adaptTempPotEnergyAveNum[j] * invwj;
+        potEnergyDen0 += adaptTempPotEnergyAveDen[j] * invwj;
+        if ( adaptTempPotEnergyAveDen[j] > varDenMin ) {
+          var = adaptTempPotEnergyVar[j];
+        } else {
+          var = defVar;
+        }
+        A0 += var * (j - nMinus + 0.5);
+      }
+      potEnergyAve0 /= potEnergyDen0;
+      A0 /= potEnergyDen0;
 
           //A1 phi_s integral for beta_{i+1} < beta < beta_plus
-          DeltaE2AveSum = 0;
           for (j = adaptTempBin+1; j < nPlus; j++) {
-              potEnergyAve1 += adaptTempPotEnergyAve[j];
-              DeltaE2Ave = adaptTempPotEnergyVar[j];
-              DeltaE2AveSum += DeltaE2Ave;
-              A1 += j*DeltaE2Ave;
+        invwj = adaptTempBetaMin + (j + 0.5) * adaptTempDBeta;
+        potEnergyAve1 += adaptTempPotEnergyAveNum[j] * invwj;
+        potEnergyDen1 += adaptTempPotEnergyAveDen[j] * invwj;
+        if ( adaptTempPotEnergyAveDen[j] > varDenMin ) {
+          var = adaptTempPotEnergyVar[j];
+        } else {
+          var = defVar;
           }
-          A1 *= adaptTempDBeta;   
-          A1 += (adaptTempBetaMin+0.5*adaptTempDBeta-betaPlus)*DeltaE2AveSum;
-          A1 *= adaptTempDBeta;
-          if ( nPlus < adaptTempBins ) {
-            betaj = betaPlus-adaptTempBetaN[nPlus];
-            betaj *= betaj;
-            A1 -= 0.5*betaj*adaptTempPotEnergyVar[nPlus];
+        A1 += var * (j - nPlus + 0.5);
+      }
+      if ( potEnergyDen1 > 0 ) {
+        potEnergyAve1 /= potEnergyDen1;
+        A1 /= potEnergyDen1;
           }
-          A1 /= (betaPlus-betaNp1);
 
           //A2 phi_t integral for beta_i
-          A2 = 0.5*adaptTempDBeta*potEnergyVariance;
+      A2 = 0.5 * adaptTempPotEnergyVar[adaptTempBin] * (adaptTempBin - nMinus + 1) / potEnergyDen0;
 
           // Now calculate a+ and a-
-          DeltaE2Ave = A0-A1;
           BigReal aplus = 0;
-          BigReal aminus = 0;
-          if (DeltaE2Ave != 0) {
+      if ( potEnergyDen1 > 0 ) {
             aplus = (A0-A2)/(A0-A1);
+      }
             if (aplus < 0) {
                     aplus = 0;
             }
             if (aplus > 1)  {
                     aplus = 1;
             }
-            aminus = 1-aplus;
-            potEnergyAve0 *= adaptTempDBeta;
-            potEnergyAve0 += adaptTempPotEnergyAve[nMinus]*(adaptTempBetaN[nMinus+1]-betaMinus);
-            potEnergyAve0 /= (betaNp1-betaMinus);
-            potEnergyAve1 *= adaptTempDBeta;
-            if ( nPlus < adaptTempBins ) {
-                potEnergyAve1 += adaptTempPotEnergyAve[nPlus]*(betaPlus-adaptTempBetaN[nPlus]);
-            }
-            potEnergyAve1 /= (betaPlus-betaNp1);
-            potEnergyAverage = aminus*potEnergyAve0;
-            potEnergyAverage += aplus*potEnergyAve1;
-          }
+      BigReal aminus = 1 - aplus;
+      BigReal potEnergyAverage = aminus*potEnergyAve0 + aplus*potEnergyAve1;
           if (simParams->adaptTempDebug) {
        iout << "ADAPTEMP DEBUG:"  << "\n"
             << "     adaptTempBin:    " << adaptTempBin << "\n"
             << "     Samples:   " << adaptTempPotEnergySamples[adaptTempBin] << "\n"
             << "     adaptTempBeta:   " << adaptTempBeta << "\n" 
+             << "     potentialEnergeAverage:  " << potEnergyAverage << "\n"
             << "     adaptTemp:   " << adaptTempT<< "\n"
             << "     betaMin:   " << adaptTempBetaMin << "\n"
             << "     betaMax:   " << adaptTempBetaMax << "\n"
             << "     gammaAve:  " << gammaAve << "\n"
-            << "     deltaBeta: " << deltaBeta << "\n"
-            << "     betaMinus: " << betaMinus << "\n"
-            << "     betaPlus:  " << betaPlus << "\n"
+             << "     deltaBeta: " << (adaptTempBin - nMinus) * adaptTempDBeta << "\n"
+             << "     betaMinus: " << adaptTempBetaN[nMinus] << "\n"
+             << "     betaPlus:  " << adaptTempBetaN[nPlus] << "\n"
             << "     nMinus:    " << nMinus << "\n"
             << "     nPlus:     " << nPlus << "\n"
             << "     A0:        " << A0 << "\n"
@@ -1851,29 +2383,12 @@
             << "     A2:        " << A2 << "\n"
             << "     a+:        " << aplus << "\n"
             << "     a-:        " << aminus << "\n"
-            << endi;
-          }
-      }
-      else {
-          if (simParams->adaptTempDebug) {
-       iout << "ADAPTEMP DEBUG:"  << "\n"
-            << "     adaptTempBin:    " << adaptTempBin << "\n"
-            << "     Samples:   " << adaptTempPotEnergySamples[adaptTempBin] << "\n"
-            << "     adaptTempBeta:   " << adaptTempBeta << "\n" 
-            << "     adaptTemp:   " << adaptTempT<< "\n"
-            << "     betaMin:   " << adaptTempBetaMin << "\n"
-            << "     betaMax:   " << adaptTempBetaMax << "\n"
-            << "     gammaAve:  " << gammaAve << "\n"
-            << "     deltaBeta:  N/A\n"
-            << "     betaMinus:  N/A\n"
-            << "     betaPlus:   N/A\n"
-            << "     nMinus:     N/A\n"
-            << "     nPlus:      N/A\n"
-            << "     A0:         N/A\n"
-            << "     A1:         N/A\n"
-            << "     A2:         N/A\n"
-            << "     a+:         N/A\n"
-            << "     a-:         N/A\n"
+             << "     potEner:   " << potentialEnergy << "\n"
+             << "     aveEner:   " << potEnergyAverage << "\n"
+             << "     aveEne0:   " << potEnergyAve0 << "\n"
+             << "     aveEne1:   " << potEnergyAve1 << "\n"
+             << "     aveDen0:   " << potEnergyDen0 << "\n"
+             << "     aveDen1:   " << potEnergyDen1 << "\n"
             << endi;
           }
       }
@@ -1886,70 +2401,8 @@
      // Check if dT in [adaptTempTmin,adaptTempTmax]. If not try simpler estimate of mean
      // This helps sampling with poor statistics in the bins surrounding adaptTempBin.
       if ( dT > 1./adaptTempBetaMin || dT  < 1./adaptTempBetaMax ) {
-        dT = ((potentialEnergy-adaptTempPotEnergyAve[adaptTempBin])/BOLTZMANN+adaptTempT)*adaptTempDt;
-        dT += random->gaussian()*sqrt(2.*adaptTempDt)*adaptTempT;
-        dT += adaptTempT;
-        // Check again, if not then keep original adaptTempTor assign random.
-        if ( dT > 1./adaptTempBetaMin ) {
-          if (!simParams->adaptTempRandom) {             
-             //iout << iWARN << "ADAPTEMP: " << step << " T= " << dT 
-             //     << " K higher than adaptTempTmax."
-             //     << " Keeping temperature at " 
-             //     << adaptTempT<< "\n"<< endi;             
-             dT = adaptTempT;
-          }
-          else {             
-             //iout << iWARN << "ADAPTEMP: " << step << " T= " << dT 
-             //     << " K higher than adaptTempTmax."
-             //     << " Assigning random temperature in range\n" << endi;
-             dT = adaptTempBetaMin +  random->uniform()*(adaptTempBetaMax-adaptTempBetaMin);             
-             dT = 1./dT;
-          }
-        } 
-        else if ( dT  < 1./adaptTempBetaMax ) {
-          if (!simParams->adaptTempRandom) {            
-            //iout << iWARN << "ADAPTEMP: " << step << " T= "<< dT 
-            //     << " K lower than adaptTempTmin."
-            //     << " Keeping temperature at " << adaptTempT<< "\n" << endi; 
             dT = adaptTempT;
-          }
-          else {
-            //iout << iWARN << "ADAPTEMP: " << step << " T= "<< dT 
-            //     << " K lower than adaptTempTmin."
-            //     << " Assigning random temperature in range\n" << endi;
-            dT = adaptTempBetaMin +  random->uniform()*(adaptTempBetaMax-adaptTempBetaMin);
-            dT = 1./dT;
-          }
-        }
-        else if (adaptTempAutoDt) {
-          //update temperature step size counter
-          //FOR "TRUE" ADAPTIVE TEMPERING 
-          BigReal adaptTempTdiff = fabs(dT-adaptTempT);
-          if (adaptTempTdiff > 0) {
-            adaptTempDTave += adaptTempTdiff; 
-            adaptTempDTavenum++;
-//            iout << "ADAPTEMP: adapTempTdiff = " << adaptTempTdiff << "\n";
-          }
-          if(adaptTempDTavenum == 100){
-                BigReal Frac;
-                adaptTempDTave /= adaptTempDTavenum;
-                Frac = 1./adaptTempBetaMin-1./adaptTempBetaMax;
-                Frac = adaptTempDTave/Frac;
-                //if average temperature jump is > 3% of temperature range,
-                //modify jump size to match 3%
-                iout << "ADAPTEMP: " << step << " FRAC " << Frac << "\n"; 
-                if (Frac > adaptTempDtMax || Frac < adaptTempDtMin) {
-                    Frac = adaptTempDtMax/Frac;
-                    iout << "ADAPTEMP: Updating adaptTempDt to ";
-                    adaptTempDt *= Frac;
-                    iout << adaptTempDt << "\n" << endi;
-                }
-                adaptTempDTave = 0;
-                adaptTempDTavenum = 0;
-          }
-        }
-      }
-      else if (adaptTempAutoDt) {
+      } else if (adaptTempAutoDt) {
           //update temperature step size counter
           // FOR "TRUE" ADAPTIVE TEMPERING
           BigReal adaptTempTdiff = fabs(dT-adaptTempT);
@@ -1979,8 +2432,24 @@
           
       }
       
+      BigReal tScale = dT / adaptTempT;
+      BigReal vScale = sqrt(tScale);
+      // for velocity-rescaling-based thermostats,
+      // carry the velocity-rescaling factor to the next step
+      if ( simParams->langRescaleOn ) {
+        langRescaleFactorPrev *= vScale;
+      } else if ( simParams->tNHCOn ) {
+        tNHCRescaleFactorPrev *= vScale;
+      }
       adaptTempT = dT; 
       broadcast->adaptTemperature.publish(step,adaptTempT);
+      scaled = TRUE;
+      // temperature is to be used for the Langevin velocity-rescaling
+      // and NH-chain thermostats, so it needs to be updated.
+      temperature *= tScale;
+      totalEnergy += kineticEnergy * (tScale - 1);
+      kineticEnergy *= tScale;
+      kineticEnergyCentered *= tScale;
     }
     adaptTempWriteRestart(step);
     if ( ! (step % adaptTempOutFreq) ) {
@@ -1991,7 +2460,7 @@
              << " ENERGYVAR " << std::setprecision(10) << potEnergyVariance;
         iout << "\n" << endi;
    }
-   
+   return scaled;
 }
 
 
@@ -2277,6 +2746,15 @@
       electEnergy = reduction->item(REDUCTION_ELECT_ENERGY);
       ljEnergy = reduction->item(REDUCTION_LJ_ENERGY);
 
+      if (simParameters->LJcorrection && volume) {
+        // Apply tail correction to energy
+        //printf("Volume is %f\n", volume);
+        //printf("Applying tail correction of %f to energy\n", molecule->tail_corr_ener / volume);
+        ljEnergy += molecule->tail_corr_ener / volume;
+        ljEnergy_f += molecule->tail_corr_ener / volume;
+        ljEnergy_f_left += molecule->tail_corr_ener / volume;
+      }
+
       // JLai
       groLJEnergy = reduction->item(REDUCTION_GRO_LJ_ENERGY);
       groGaussEnergy = reduction->item(REDUCTION_GRO_GAUSS_ENERGY);
@@ -2310,16 +2788,6 @@
 //fepe
     }
 
-    if (simParameters->LJcorrection && volume) {
-      // Apply tail correction to energy
-      //printf("Volume is %f\n", volume);
-      //printf("Applying tail correction of %f to energy\n", molecule->tail_corr_ener / volume);
-      ljEnergy += molecule->tail_corr_ener / volume;
-      ljEnergy_f += molecule->tail_corr_ener / volume;
-      ljEnergy_f_left += molecule->tail_corr_ener / volume;
-    }
-
-
     momentum.x = reduction->item(REDUCTION_MOMENTUM_X);
     momentum.y = reduction->item(REDUCTION_MOMENTUM_Y);
     momentum.z = reduction->item(REDUCTION_MOMENTUM_Z);
@@ -3147,6 +3615,7 @@
     ldbSteps = LdbCoordinator::Object()->getNumStepsToRun();
   }
   if ( ! --ldbSteps ) {
+    //CkPrintf("Controller: rebalancing %d, thread %p\n", step, CthSelf());
     startBenchTime -= CmiWallTimer();
 	Node::Object()->outputPatchComputeMaps("before_ldb", step);
     LdbCoordinator::Object()->rebalance(this);	
diff -u -wdB thstat_old/Controller.h thstat_new/Controller.h
--- thstat_old/Controller.h	2015-10-12 10:48:41.000000000 -0500
+++ thstat_new/Controller.h	2016-08-03 16:56:40.130928551 -0500
@@ -151,10 +151,38 @@
     void enqueueCollections(int);
     void correctMomentum(int step);
     void rescaleVelocities(int);
+    void rescaleVelocitiesInit(void);
+    void rescaleVelocitiesLoad(void);
+    void rescaleVelocitiesSave(int);
       BigReal rescaleVelocities_sumTemps;
       int rescaleVelocities_numTemps;
+      BigReal rescaleVelocities_sum1;
+      BigReal rescaleVelocities_sumBeta;
+      BigReal rescaleVelocities_sumBeta2;
+      BigReal rescaleVelocities_sumDbde;
     void reassignVelocities(int);
     void tcoupleVelocities(int);
+    void langRescaleVelocities(int, Bool);
+    BigReal langRescaleFactorPrev;
+    void tNHCInit(void);
+    void tNHCDone(int);
+    void tNHCRescaleVelocities(int, Bool);
+    void tNHCSave(int);
+    void tNHCLoad(void);
+    BigReal tNHCRescaleFactorPrev;
+    BigReal *tNHCzeta;
+    BigReal *tNHCmass;
+    void keHistInit(void);
+    void keHistDone(int);
+    void keHistUpdate(int);
+    // save the kinetic energy to file
+    // the first column is the kinetic energy
+    // the second and third columns are the
+    // normalized histogram and the reference value
+    void keHistSave(int);
+    void keHistLoad(void);
+    BigReal *keHist;
+    int keHistBinMax;
     void berendsenPressure(int);
       // Tensor berendsenPressure_avg;
       // int berendsenPressure_count;
@@ -231,9 +259,137 @@
    BigReal accelMDdVAverage;
 
 //JS for adaptive temperature sampling
+   void adaptTempMakeWin(void);
    void adaptTempInit(int step);
-   void adaptTempUpdate(int step, int minimize = 0);
+   Bool adaptTempUpdate(int step, int minimize = 0);
    void adaptTempWriteRestart(int step);
+   int *adaptTempBinMinus;
+   int *adaptTempBinPlus;
+   BigReal *adaptTempInvW;
+   // separator accumulator
+   struct AdaptTempSepAcc {
+     BigReal invGamma;
+     int bin0; // first bin
+     int winSize;
+     BigReal *count;
+     BigReal *sumE;
+     BigReal *sumE2;
+     BigReal *ave;
+     BigReal *var;
+     BigReal total;
+
+     // initialize the window
+     void init(int minus, int plus) {
+       invGamma = 1;
+       bin0 = minus;
+       winSize = plus - minus;
+       if ( winSize % 2 == 0 ) NAMD_die("Window size should be odd");
+       total = 0;
+       count = new BigReal[winSize];
+       sumE  = new BigReal[winSize];
+       sumE2 = new BigReal[winSize];
+       ave   = new BigReal[winSize];
+       var   = new BigReal[winSize];
+       for ( int j = 0; j < winSize; j++ ) {
+         count[j] = 0;
+         sumE[j]  = 0;
+         sumE2[j] = 0;
+         ave[j]   = 0;
+         var[j]   = 0;
+       }
+     }
+
+     // compute the average and variance of each bin
+     void trim(void) {
+       int j;
+       if ( invGamma > 1.0 ) { // renormalize the running weight
+         BigReal gam = 1.0/invGamma;
+         for ( j = 0; j < winSize; j++ ) {
+           count[j] *= gam;
+           sumE[j]  *= gam;
+           sumE2[j] *= gam;
+         }
+         invGamma = 1;
+       }
+       
+       for ( j = 0; j < winSize; j++ ) {
+         if ( count[j] > 0 ) {
+           ave[j] = sumE[j] / count[j];
+           var[j] = sumE2[j] / count[j] - ave[j] * ave[j];
+         } else {
+           ave[j] = 0;
+           var[j] = 0;
+         }
+         //CkPrintf("j %d, %g %g %g %g %g\n", j, count[j], sumE[j], sumE2[j], ave[j], var[j]);
+       }
+     }
+
+     // add a data point from bin i to this accumulator
+     void add(int i, BigReal potEne, BigReal cg) {
+       i -= bin0; // convert to the local index
+       if ( i < 0 || i >= winSize ) {
+         CkPrintf("Bad local index for bin0 %d: i %d, winSize %d\n", bin0, i + bin0, winSize);
+         NAMD_die("Adaptive tempering: bad local index.");
+       }
+       total += 1;
+       BigReal gamma = 1 - cg / total;
+       if ( gamma < 1e-8 ) gamma = 1e-8;
+       invGamma /= gamma;
+       count[i] += invGamma;
+       sumE[i]  += invGamma * potEne;
+       sumE2[i] += invGamma * potEne * potEne;
+       //CkPrintf("adding to bin %d with potEne %g\n", i, potEne);
+     }
+
+     // compute the average energy from the integral identity
+     BigReal iiave(BigReal *invw, BigReal varCntMin) {
+       int j, mid = winSize / 2;
+       BigReal ave0 = 0.0, ave1 = 0.0, cnt0 = 0.0, cnt1 = 0.0;
+       BigReal A0 = 0, A1 = 0, A2 = 0, cntMax = 0, defVar = 0, invwj, varj;
+       trim();
+       // compute the default variance from the most populated bin
+       for ( j = 0; j < winSize; j++ ) {
+         if ( count[j] > cntMax ) {
+           cntMax = count[j];
+           defVar = var[j];
+         }
+       }
+       // left side
+       for ( j = 0; j <= mid; j++ ) {
+         invwj = invw[j + bin0];
+         ave0 += sumE[j] * invwj;
+         cnt0 += count[j] * invwj;
+         varj = (count[j] > varCntMin) ? var[j] : defVar;
+         A0 += varj * (j + 0.5);
+         //CkPrintf("+ %d %g %g %g\n", j, count[j], sumE[j], invw[j]);
+       }
+       ave0 /= cnt0;
+       A0 /= cnt0;
+       // middle bin correction
+       A2 = 0.5 * var[mid] * (mid + 1) / cnt0;
+       // right side
+       for ( j = mid + 1; j < winSize; j++ ) {
+         invwj = invw[j + bin0];
+         ave1 += sumE[j] * invwj;
+         cnt1 += count[j] * invwj;
+         varj = (count[j] > varCntMin) ? var[j] : defVar;
+         A1 += varj * (j - winSize + 0.5);
+         //CkPrintf("+ %d %g %g %g\n", j, count[j], sumE[j], invw[j]);
+       }
+       if ( cnt1 > 0 ) {
+         ave1 /= cnt1;
+         A1 /= cnt1;
+       }
+       // compute a+ and a-
+       BigReal aplus = (cnt1 > 0) ? (A0 - A2) / (A0 - A1) : 0;
+       if ( aplus < 0 ) aplus = 0;
+       if ( aplus > 1 ) aplus = 1;
+       BigReal aminus = 1 - aplus;
+       //CkPrintf("A0 %g, A1 %g, A2 %g, a- %g, a+ %g, ave %g, %g, %g\n", A0, A1, A2, aminus, aplus, ave0, ave1, aminus * ave0 + aplus * ave1); getchar();
+       return aminus * ave0 + aplus * ave1;
+     }
+   };
+   AdaptTempSepAcc *adaptTempSepAcc;
    BigReal *adaptTempPotEnergyAveNum;
    BigReal *adaptTempPotEnergyAveDen;
    BigReal *adaptTempPotEnergyVarNum;
diff -u -wdB thstat_old/fstream_namd.h thstat_new/fstream_namd.h
--- thstat_old/fstream_namd.h	2015-01-31 00:39:07.000000000 -0600
+++ thstat_new/fstream_namd.h	2016-07-22 16:47:10.931646492 -0500
@@ -4,6 +4,11 @@
 
 #include <iostream>
 #include <sstream>
+#if !defined(WIN32) || defined(__CYGWIN__)
+#include <unistd.h>
+#else
+#include <io.h>
+#endif
 
 class ofstream_namd : public std::ostringstream {
 
@@ -31,6 +36,17 @@
     if ( fd ) close();
   }
 
+  void seekbegin() {
+    str("");
+#if !defined(WIN32) || defined(__CYGWIN__)
+    ftruncate(fd, 0);
+    lseek(fd, 0, SEEK_SET);
+#else
+    _chsize(fd, 0);
+    _lseek(fd, 0, SEEK_SET);
+#endif
+  }
+
   bool good() const { return true; }
   bool fail() const { return false; }
   bool bad() const { return false; }
diff -u -wdB thstat_old/Random.h thstat_new/Random.h
--- thstat_old/Random.h	2003-02-10 16:41:19.000000000 -0600
+++ thstat_new/Random.h	2016-07-08 20:14:02.403812877 -0500
@@ -140,6 +140,43 @@
     return Vector( gaussian(), gaussian(), gaussian() );
   }
 
+  // return a number from a gamma distribution of k degrees
+  BigReal gamma(BigReal k)
+  {
+    Bool lt1 = FALSE;
+    BigReal a, b, x, v, u;
+
+    if ( k <= 0 ) return 0;
+    if ( k < 1 ) {
+      lt1 = TRUE;
+      k += 1;
+    }
+    a = k - 1./3;
+    b = 1./3/sqrt(a);
+
+    for ( ; ; ) {
+      do {
+        x = gaussian();
+        v = 1 + b * x;
+      } while ( v <= 0 );
+      v *= v * v;
+      x *= x;
+      u = uniform();
+      if ( u <= 1 - 0.331 * x * x ) break;
+      u = log(u);
+      if ( u <= 0.5 * x + a * (1 - v + log(v)) ) break;
+    }
+
+    x = a * v;
+    if ( lt1 ) x *= pow(1. - uniform(), 1./(k - 1));
+    return x;
+  }
+
+  BigReal chisqr(BigReal k)
+  {
+    return gamma( k * 0.5 ) * 2;
+  }
+
   // return a random long
   long integer(void) {
     skip();
diff -u -wdB thstat_old/Sequencer.C thstat_new/Sequencer.C
--- thstat_old/Sequencer.C	2016-06-01 17:24:35.531579311 -0500
+++ thstat_new/Sequencer.C	2016-08-02 19:41:34.948814711 -0500
@@ -223,12 +223,7 @@
 
     // Is adaptive tempering on?
     const Bool adaptTempOn = simParams->adaptTempOn;
-    adaptTempT = simParams->initialTemp;
-    if (simParams->langevinOn)
-        adaptTempT = simParams->langevinTemp;
-    else if (simParams->rescaleFreq > 0)
-        adaptTempT = simParams->rescaleTemp;
-        
+    adaptTempT = simParams->thermostatTemp();
 
     int &doMolly = patch->flags.doMolly;
     doMolly = simParams->mollyOn && doFullElectrostatics;
@@ -274,6 +269,8 @@
     if ( accelMDOn && !accelMDdihe ) doEnergy=1;
     //Update energy every timestep for adaptive tempering
     if ( adaptTempOn ) doEnergy=1;
+    if ( simParams->energyLogFreq > 0 && step % simParams->energyLogFreq == 0 )
+      doEnergy = 1;
     runComputeObjects(1,step<numberOfSteps); // must migrate here!
     rescaleaccelMD(step, doNonbonded, doFullElectrostatics); // for accelMD 
     adaptTempUpdate(step); // update adaptive tempering temperature
@@ -325,6 +322,8 @@
     {
       rescaleVelocities(step);
       tcoupleVelocities(timestep,step);
+      langRescaleVelocities(step);
+      tNHCRescaleVelocities(step);
       berendsenPressure(step);
 
       if ( ! commOnly ) {
@@ -382,6 +381,8 @@
       doEnergy = ! ( step % energyFrequency );
       if ( accelMDOn && !accelMDdihe ) doEnergy=1;
       if ( adaptTempOn ) doEnergy=1; 
+      if ( simParams->energyLogFreq > 0 && step % simParams->energyLogFreq == 0 )
+        doEnergy = 1;
       runComputeObjects(!(step%stepsPerCycle),step<numberOfSteps);
  
       rescaleaccelMD(step, doNonbonded, doFullElectrostatics); // for accelMD
@@ -438,7 +439,12 @@
 	submitReductions(step);
 	submitCollections(step);
        //Update adaptive tempering temperature
-        adaptTempUpdate(step);
+        Bool scaled = adaptTempUpdate(step);
+        if ( scaled && (ldbSteps == 1 || LdbCoordinator::Object()->getNumStepsToRun() == 1) ) {
+          // submit Hi's if we're about to rebalance load
+          collection->submitHi(step);
+          //CkPrintf("Sequencer step %d, thread %p\n", step, CthSelf());
+        }
 
 #if CYCLE_BARRIER
         cycleBarrier(!((step+1) % stepsPerCycle), step);
@@ -471,6 +477,7 @@
             sprintf(traceNote, "%s%d",tracePrefix,step); 
             traceUserSuppliedNote(traceNote);
         }
+        //if ( ldbSteps == 1 ) CkPrintf("step %d, before rebalanceLoad(), Sequencer PE %d/%d, thread %p\n", step, CkMyPe(), CkNumPes(), CthSelf());
 	rebalanceLoad(step);
 
 #if PME_BARRIER
@@ -1182,19 +1189,28 @@
 
 }
 
-void Sequencer::adaptTempUpdate(int step)
+Bool Sequencer::adaptTempUpdate(int step)
 {
+   Bool scaled = FALSE;
+
    //check if adaptive tempering is enabled and in the right timestep range
-   if (!simParams->adaptTempOn) return;
+   if (!simParams->adaptTempOn) return scaled;
    if ( (step < simParams->adaptTempFirstStep ) || 
      ( simParams->adaptTempLastStep > 0 && step > simParams->adaptTempLastStep )) {
-        if (simParams->langevinOn) // restore langevin temperature
-            adaptTempT = simParams->langevinTemp;
-        return;
+        // restore the temperature of the active thermostat
+        adaptTempT = simParams->thermostatTemp();
+        return scaled;
    }
    // Get Updated Temperature
    if ( !(step % simParams->adaptTempFreq ) && (step > simParams->firstTimestep ))
+   {
+    BigReal adaptTempTOld = adaptTempT;
     adaptTempT = broadcast->adaptTemperature.get(step);
+    scaled = TRUE;
+    if ( !simParams->langRescaleOn && !simParams->tNHCOn )
+      rescaleVelocitiesByFactor( sqrt(adaptTempT / adaptTempTOld) );
+   }
+   return scaled;
 }
 
 void Sequencer::reassignVelocities(BigReal timestep, int step)
@@ -1289,6 +1305,26 @@
   }
 }
 
+void Sequencer::langRescaleVelocities(int step)
+{
+  if ( simParams->langRescaleOn ) {
+    FullAtom *a = patch->atom.begin();
+    BigReal factor = broadcast->langRescaleFactor.get(step);
+    for ( int i = 0; i < patch->numAtoms; ++i )
+      a[i].velocity *= factor;
+  }
+}
+
+void Sequencer::tNHCRescaleVelocities(int step)
+{
+  if ( simParams->tNHCOn ) {
+    FullAtom *a = patch->atom.begin();
+    BigReal factor = broadcast->tNHCRescaleFactor.get(step);
+    for ( int i = 0; i < patch->numAtoms; ++i )
+      a[i].velocity *= factor;
+  }
+}
+
 void Sequencer::saveForce(const int ftag)
 {
   patch->saveForce(ftag);
@@ -2127,6 +2163,7 @@
     ldbSteps = LdbCoordinator::Object()->getNumStepsToRun();
   }
   if ( ! --ldbSteps ) {
+    //CkPrintf("Sequencer : rebalancing %d, thread %p\n", timestep, CthSelf());
     patch->submitLoadStats(timestep);
     ldbCoordinator->rebalance(this,patch->getPatchID());
     pairlistsAreValid = 0;
diff -u -wdB thstat_old/Sequencer.h thstat_new/Sequencer.h
--- thstat_old/Sequencer.h	2013-10-30 13:26:16.000000000 -0500
+++ thstat_new/Sequencer.h	2016-07-08 20:14:02.403812877 -0500
@@ -74,7 +74,7 @@
     void reloadCharges();
 
     BigReal adaptTempT;         // adaptive tempering temperature
-    void adaptTempUpdate(int); // adaptive tempering temperature update
+    Bool adaptTempUpdate(int); // adaptive tempering temperature update
 
     void rescaleVelocities(int);
     void rescaleaccelMD(int, int, int); // for accelMD
@@ -83,6 +83,8 @@
     void reinitVelocities(void);
     void rescaleVelocitiesByFactor(BigReal);
     void tcoupleVelocities(BigReal,int);
+    void langRescaleVelocities(int);
+    void tNHCRescaleVelocities(int);
     void berendsenPressure(int);
       int berendsenPressure_count;
       int checkpoint_berendsenPressure_count;
diff -u -wdB thstat_old/SimParameters.C thstat_new/SimParameters.C
--- thstat_old/SimParameters.C	2015-12-08 09:41:37.000000000 -0600
+++ thstat_new/SimParameters.C	2016-08-03 19:33:46.932734585 -0500
@@ -187,6 +187,12 @@
   }
   SCRIPT_PARSE_FLOAT("reassignTemp",reassignTemp)
   SCRIPT_PARSE_FLOAT("rescaleTemp",rescaleTemp)
+  SCRIPT_PARSE_BOOL("rescaleAdaptive",rescaleAdaptiveOn)
+  SCRIPT_PARSE_FLOAT("rescaleAdaptiveDedk",rescaleAdaptiveDedk)
+  SCRIPT_PARSE_FLOAT("langRescaleTemp",langRescaleTemp)
+  SCRIPT_PARSE_FLOAT("langRescaleDt",langRescaleDt)
+  SCRIPT_PARSE_FLOAT("tNHCTemp",langRescaleTemp)
+  SCRIPT_PARSE_FLOAT("tNHCPeriod",langRescaleDt)
   SCRIPT_PARSE_BOOL("velocityQuenching",minimizeOn)
   SCRIPT_PARSE_BOOL("maximumMove",maximumMove)
   // SCRIPT_PARSE_BOOL("Langevin",langevinOn)
@@ -1178,6 +1184,58 @@
      "containing the temperature coupling term B(i);\n"
      "default is 'O'", PARSE_STRING);
 
+   //  Get parameters for the Langevin velocity-rescaling thermostat
+   opts.optionalB("main", "langrescale", 
+      "Should Langevin velocity-rescaling thermostat be turned on?",
+      &langRescaleOn, FALSE);
+   opts.require("langrescale", "langRescaleTemp",
+    "Temperature for Langevin velocity-rescaling thermostat",
+    &langRescaleTemp);
+   opts.range("langRescaleTemp", NOT_NEGATIVE);
+   opts.units("langRescaleTemp", N_KELVIN);
+   opts.optional("langrescale", "langRescaleDt",
+    "Inverse viscosity in femtoseconds for Langevin velocity-rescaling thermostat",
+    &langRescaleDt, 20.0);
+
+   //  Get parameters for the Nose-Hoover chain thermostat
+   //  Nose-Hoover chains: The canonical ensemble via continuous dynamics 
+   //  Glenn J. Martyna, Michael L. Klein, and Mark Tuckerman, JCP 97 (4) 2635
+   opts.optionalB("main", "tNHC", "Should Nose-Hoover chain thermostat be turned on?",
+      &tNHCOn, FALSE);
+   opts.require("tNHC", "tNHCTemp", "Temperature for Nose-Hoover chain thermostat",
+    &tNHCTemp);
+   opts.range("tNHCTemp", NOT_NEGATIVE);
+   opts.units("tNHCTemp", N_KELVIN);
+   opts.require("tNHC", "tNHCLen", "Length of Nose-Hoover chain",
+    &tNHCLen, 1);
+   opts.range("tNHCLen", POSITIVE);
+   opts.optional("tNHC", "tNHCPeriod", "Oscillation period in femtoseconds of the Nose-Hoover chain",
+    &tNHCPeriod, 100.0);
+   opts.range("tNHCPeriod", POSITIVE);
+   opts.optional("tNHC", "tNHCFile", "Restart file for the NH-chain",
+       tNHCFile);
+   opts.optional("tNHC", "tNHCFileFreq", "Frequency of writing restart file for the NH-chain",
+       &tNHCFileFreq, 10000);
+   opts.range("tNHCFileFreq", POSITIVE);
+   opts.optionalB("tNHC", "tNHCFileReadMass", "Read mass from the restart file, if any",
+       &tNHCFileReadMass, FALSE);
+
+   opts.optionalB("main", "keHist", "Should kinetic energy histogram be turned on?",
+       &keHistOn, FALSE);
+   opts.optional("keHist", "keHistBin", "Bin size of the histogram of the kinetic energy",
+       &keHistBin, 1.0);
+   opts.optional("keHist", "keHistFile", "Histogram file for the kinetic energy",
+       keHistFile);
+   opts.optional("keHist", "keHistFileFreq", "Frequency of writing the histogram file for the kinetic energy",
+       &keHistFileFreq, 10000);
+   opts.range("keHistFileFreq", POSITIVE);
+
+   opts.optional("main", "energyLogFile", "Energy log file",
+       energyLogFile);
+   opts.optional("energyLogFile", "energyLogFreq", "Frequency of writing the energy log file",
+       &energyLogFreq, 1);
+   opts.range("energyLogFreq", POSITIVE);
+
    opts.optional("main", "rescaleFreq", "Number of steps between "
     "velocity rescaling", &rescaleFreq);
    opts.range("rescaleFreq", POSITIVE);
@@ -1185,6 +1243,17 @@
     &rescaleTemp);
    opts.range("rescaleTemp", NOT_NEGATIVE);
    opts.units("rescaleTemp", N_KELVIN);
+   opts.optionalB("main", "rescaleAdaptive", "Adaptively reduce the magnitude "
+    "of the velocity rescaling", &rescaleAdaptiveOn, FALSE);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveDedk", "Heuristic multiple of the reduction factor ",
+    &rescaleAdaptiveDedk, 0.0);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveFile",
+       "File for writing the adaptive velocity-rescaling restart information",
+       rescaleAdaptiveFile);
+   opts.optional("rescaleAdaptive", "rescaleAdaptiveFileFreq",
+       "Frequency of writing the adaptive velocity-rescaling restart information",
+       &rescaleAdaptiveFileFreq, 10000);
+   opts.range("rescaleAdaptiveFileFreq", POSITIVE);
 
    opts.optional("main", "reassignFreq", "Number of steps between "
     "velocity reassignment", &reassignFreq);
@@ -1374,6 +1443,8 @@
    opts.range("adaptTempTmax", POSITIVE);
    opts.optional("adaptTempMD", "adaptTempBins","Number of bins to store average energies", &adaptTempBins,0);
    opts.range("adaptTempBins", NOT_NEGATIVE);
+   opts.optional("adaptTempMD", "adaptTempWindowSize", "Window size as a fraction of the inverse temperature range", &adaptTempWindowSize, 0.04);
+   opts.range("adaptTempWindowSize", NOT_NEGATIVE);
    opts.optional("adaptTempMD", "adaptTempDt", "Integration timestep for Temp. updates", &adaptTempDt, 0.0001);
    opts.units("adaptTempDt", N_FSEC);
    opts.range("adaptTempDt", NOT_NEGATIVE);
@@ -1383,10 +1454,14 @@
    opts.range("adaptTempCgamma", NOT_NEGATIVE);
    opts.optionalB("adaptTempMD","adaptTempLangevin","Send adaptTemp temperature to langevin thermostat",&adaptTempLangevin,TRUE);
    opts.optionalB("adaptTempMD","adaptTempRescaling","Send adaptTemp temperature to velocity rescaling thermostat", &adaptTempRescale,TRUE);
+   opts.optionalB("adaptTempMD","adaptTempLangRescale","Send adaptTemp temperature to Langevin-style velocity rescaling thermostat", &adaptTempLangRescale,TRUE);
+   opts.optionalB("adaptTempMD","adaptTempTNHC","Send adaptTemp temperature to Nose-Hoover chain thermostat",&adaptTempTNHC,TRUE);
    opts.optional("adaptTempMD", "adaptTempInFile", "File containing restart information for adaptTemp", adaptTempInFile);
    opts.optional("adaptTempMD", "adaptTempRestartFile", "File for writing adaptTemp restart information", adaptTempRestartFile);
    opts.require("adaptTempRestartFile","adaptTempRestartFreq", "Frequency of writing restart file", &adaptTempRestartFreq,0);
    opts.range("adaptTempRestartFreq",NOT_NEGATIVE);
+   opts.optionalB("adaptTempRestartFile", "adaptTempRestartAppend", "Appending instead of overwriting the restart file", &adaptTempRestartAppend, FALSE);
+   opts.optionalB("adaptTempMD", "adaptTempSep", "Using a separate multiple-bin estimator for each bin", &adaptTempSepOn, FALSE);
    opts.optionalB("adaptTempMD", "adaptTempRandom", "Randomly assign a temperature if we step out of range", &adaptTempRandom, FALSE);
 }
 
@@ -2174,6 +2249,22 @@
 
 }
 
+// return the temperature of the active thermostat
+BigReal SimParameters::thermostatTemp(void)
+{
+  if ( langRescaleOn ) {
+    return langRescaleTemp;
+  } else if ( tNHCOn ) {
+    return tNHCTemp;
+  } else if ( langevinOn ) {
+    return langevinTemp;
+  } else if ( rescaleFreq > 0 ) {
+    return rescaleTemp;
+  } else {
+    return initialTemp;
+  }
+}
+
 #ifdef MEM_OPT_VERSION
 //This global var is defined in mainfunc.C
 extern char *gWorkDir;
@@ -2989,9 +3080,15 @@
    }
    // END LA
 
-   if (tCoupleOn && opts.defined("rescaleFreq") )
+   int thstat_cnt = 0;
+   if ( tCoupleOn ) thstat_cnt++;
+   if ( opts.defined("rescaleFreq") ) thstat_cnt++;
+   if ( langRescaleOn ) thstat_cnt++;
+   if ( tNHCOn ) thstat_cnt++;
+
+   if ( thstat_cnt > 1 )
    {
-      NAMD_die("Temperature coupling and temperature rescaling are mutually exclusive");
+      NAMD_die("Temperature coupling, temperature rescaling, Langevin-style velocity rescaling thermostat, and Nose-Hoover chain thermostat are mutually exclusive");
    }
 
    if (globalOn && CkNumPes() > 1)
@@ -3033,16 +3130,22 @@
       maximumMove = 0.75 * pairlistDist/stepsPerCycle;
    }
    if (adaptTempOn) {
-     if (!adaptTempRescale && !adaptTempLangevin) 
-        NAMD_die("Adaptive tempering needs to be coupled to either the Langevin thermostat or velocity rescaling.");
-     if (opts.defined("adaptTempInFile") && (opts.defined("adaptTempTmin") ||
-                                             opts.defined("adaptTempTmax") ||
-                                             adaptTempBins != 0)) 
-        NAMD_die("cannot simultaneously specify adaptTempInFile and any of {adaptTempTmin, adaptTempTmax,adaptTempBins} as these are read from the input file");
+     if (!adaptTempRescale && !adaptTempLangevin && !adaptTempLangRescale && !adaptTempTNHC) 
+        NAMD_die("Adaptive tempering needs to be coupled to one of following: Langevin thermostat, velocity rescaling, Langevin velocity rescaling thermostat, and Nose-Hoover chain thermostat.");
+     if ( !opts.defined("adaptTempInFile") ) {
+       adaptTempInFile[0] = '\0';
+     }
+     //if (opts.defined("adaptTempInFile") && (opts.defined("adaptTempTmin") ||
+     //                                        opts.defined("adaptTempTmax") ||
+     //                                        adaptTempBins != 0)) 
+     //   NAMD_die("cannot simultaneously specify adaptTempInFile and any of {adaptTempTmin, adaptTempTmax,adaptTempBins} as these are read from the input file");
      if (!opts.defined("adaptTempInFile") && !(opts.defined("adaptTempTmin") &&
                                              opts.defined("adaptTempTmax") &&
                                              adaptTempBins != 0 ))  
         NAMD_die("Need to specify either adaptTempInFile or all of {adaptTempTmin, adaptTempTmax,adaptTempBins} if adaptTempMD is on.");
+     if ( rescaleFreq > 0 )
+       iout << iWARN << "Velocity rescaling does not sample the exact Boltzmann distribution "
+	 "and adaptive tempering will not work properly\n" << endi;
    }
    if (langevinOn) {
      if ( ! opts.defined("langevinDamping") ) langevinDamping = 0.0;
@@ -3089,6 +3192,16 @@
   }
    }
 
+    if ( rescaleAdaptiveOn ) {
+      if ( !opts.defined("rescaleAdaptiveFile") ) {
+        strcpy(rescaleAdaptiveFile, "adaptvrescale.dat");
+      }
+    }
+
+   if ( !opts.defined("energyLogFile") ) { // disable energy logging
+     energyLogFreq = 0;
+   }
+
    if (opts.defined("reassignFreq"))
    {
   if (!opts.defined("reassignTemp"))
@@ -3188,6 +3301,8 @@
      else if (reassignFreq > 0)	alchTemp = reassignTemp;
      else if (langevinOn) 	alchTemp = langevinTemp;
      else if (tCoupleOn) 	alchTemp = tCoupleTemp;
+     else if (langRescaleOn)    alchTemp = tNHCTemp;
+     else if (tNHCOn)           alchTemp = tNHCTemp;
      else NAMD_die("Alchemical FEP can be performed only in constant temperature simulations\n");
 
      if (reassignFreq > 0 && reassignIncr != 0)
@@ -3820,6 +3935,16 @@
   tCoupleTemp = 0.0;
    }
 
+   if (!opts.defined("langRescale"))
+   {
+     langRescaleTemp = 0.0;
+   }
+
+   if (!opts.defined("tNHC"))
+   {
+     tNHCTemp = 0.0;
+   }
+
    if (HydrogenBonds)
    {
      if (daCutoffDist > pairlistDist)
@@ -4890,6 +5015,26 @@
       iout << endi;
    }
 
+   if (langRescaleOn)
+   {
+      iout << iINFO << "LANGEVIN-STYLE VELOCITY RESCALING THERMOSTAT ACTIVE\n";
+      iout << iINFO << "    TARGET TEMPERATURE " << langRescaleTemp << " K\n";
+      iout << iINFO << "    INVERSE VISCOSITY  " << langRescaleDt << " fs\n";
+      iout << endi;
+   }
+
+   if (tNHCOn)
+   {
+      iout << iINFO << "NOSE-HOOVER CHAIN THERMOSTAT ACTIVE\n";
+      iout << iINFO << "    TARGET TEMPERATURE " << tNHCTemp << " K\n";
+      iout << iINFO << "    CHAIN LENGTH       " << tNHCLen << "\n";
+      iout << iINFO << "    OSCILLATION PERIOD " << tNHCPeriod << " fs\n";
+      if ( tNHCFileReadMass ) {
+        iout << iINFO << "    READ MASS FROM     " << tNHCFile << "\n";
+      }
+      iout << endi;
+   }
+
    if (minimizeOn)
    {
       iout << iINFO << "OLD STYLE MINIMIZATION ACTIVE\n";
diff -u -wdB thstat_old/SimParameters.h thstat_new/SimParameters.h
--- thstat_old/SimParameters.h	2015-09-04 17:20:03.000000000 -0500
+++ thstat_new/SimParameters.h	2016-08-03 19:29:26.130169288 -0500
@@ -497,8 +497,35 @@
 					//  active
 	BigReal tCoupleTemp;		//  Temperature for temp coupling
 
+	Bool langRescaleOn;		//  Flag TRUE-> Langevin velocity-rescaling thermostat active
+	                   		//  Bussi, Donadio, and Parrinello, JCP 126, 014101 (2007)
+	BigReal langRescaleTemp;	//  Temperature for Langevin velocity-rescaling thermostat
+	BigReal langRescaleDt;	        //  Inverse viscosity in femtoseconds for Langevin velocity-rescaling thermostat
+	int langRescaleFreq;	        //  number of MD steps between two Langevin velocity-rescaling steps
+
+	Bool tNHCOn;			// Flag TRUE-> Nose-Hoover chain thermostat
+	            			// Martyna, Klein, and Tuckerman, JCP 97, 2635 (1992)
+	BigReal tNHCTemp;		// Temperature of the Nose-Hoover chain
+	int tNHCLen;			// Length of the Nose-Hoover chain
+	BigReal tNHCPeriod;		// Oscillation period in femtoseconds of the Nose-Hoover chain
+	char tNHCFile[128];		// Restart file for the NH-chain
+	int tNHCFileFreq;		// Frequency of writing the NH-chain restart file
+	Bool tNHCFileReadMass;		// Read mass from the restart file
+
+	Bool keHistOn;			// Flag TRUE-> Kinetic energy histogram
+	BigReal keHistBin;		// Bin size of the histogram of the kinetic energy
+	char keHistFile[128];		// Histogram file for the kinetic energy 
+	int keHistFileFreq;		// Frequency of writing the kinetic energy histogram file
+
+        char energyLogFile[128];        // Energy log file
+        int energyLogFreq;              // Frequency of writing the energy log file
+
 	int rescaleFreq;		//  Velocity rescale frequency
 	BigReal rescaleTemp;		//  Temperature to rescale to
+	Bool rescaleAdaptiveOn;		//  Adaptively reduce the velocity-rescaling factor
+	BigReal rescaleAdaptiveDedk;	//  Heuristic multiple of the reduction factor
+	char rescaleAdaptiveFile[128];	//  File to save the adaptive veloctiy-rescaling data
+	int rescaleAdaptiveFileFreq;	//  Frequency to save the adaptive veloctiy-rescaling restart file
 
         Bool accelMDOn;                 //  Perform accelerated MD
         Bool accelMDdihe;               //  Apply boost to the dihedral potential
@@ -523,13 +550,18 @@
         BigReal adaptTempTmax;                 //  Upper temperature bound
         BigReal adaptTempAutoDt;               //  Auto jump size. Value determines upper bound, adaotTempDt determines lower bound 
         int adaptTempBins;                     //  Number of bins to store average energy values
+        BigReal adaptTempWindowSize;           //  Window size as a fraction of the inverse temperature range
         BigReal adaptTempDt;                   //  timestep for adaptTemp updates - only affects Temperature random walk
         BigReal adaptTempCgamma;               //  Cgamma variable for adaptive bin averaging Cgamma = 0 is normal Averaging. 1 > Cgamma >= 0
         Bool adaptTempLangevin;                //  Couple to Langevin Thermostat
         Bool adaptTempRescale;                 //  Couple to Vel. Rescaling
+        Bool adaptTempLangRescale;             //  Couple to Langevin-style velocity rescaling thermostat
+        Bool adaptTempTNHC;                    //  Couple to Nose-Hoover chain thermostat
         char adaptTempInFile[128];             //  Restart information for adaptTemp to read
         char adaptTempRestartFile[128];        //  File to write restart information
         int  adaptTempRestartFreq;             //  Frequency of writing restart output
+        Bool adaptTempRestartAppend;           //  Appending instead of overwriting the restart file
+        Bool adaptTempSepOn;                   //  Using a separate multiple-bin estimator for each bin
         Bool adaptTempRandom;                  //  Do we assign random temperatures when we step out of [Tmin,Tmax]?
         /* End Adaptive Temperature Sampling */
 
@@ -921,6 +953,7 @@
         int issetinparseopts(const char* name);
 
        	void readExtendedSystem(const char *filename, Lattice *latptr=0);
+        BigReal thermostatTemp(void);
 private:
         ParseOptions *parseopts;
 
